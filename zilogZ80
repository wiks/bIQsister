`zmiany 20090104:
`----------------
`- w procedurze @DzZda poprawiłem po @L1/2s przy czekaniu na uzupełnienie zdarzenia
`   >bo teoretycznie mogło by się zdarzyć iż oczekiwanie nie trwało by wcale lub tylko 1 NMI
`- w procedurze @DzZda poprawiłem, że przy nie zrealizowaniu zadania wychodzi RET
`   >bo prawdopodobnie mógł to być też przyczynek do olewania niektórych zdarzeń
`- w procedurze @ZdaHL poprawiłem, że jeśli informacja i brak zasięgu poniżej minuty to czeka
`  z SMSem o informacji, bo chyba dlatego olewał czasem niektóre zdarzenia 
`  (mam nadzieję że dlatego)
`- poprawiłem (dodałem) spacje po liczbie dzwonków do drzwi
`- zamiast kropek po zał i wył dodałem przecinki, lepiej to wygląda w TEST no i paru miejscach też 
`  coś chyba zmienia, choć raczej niewiele
`- w pod-procedurze [@dzwon] gdy rozpoczęty dzwonek przychodzący kasuje numer rozpoznany 
`  telefonu stacjonarnego (też drugi)
`- mała optymalizacja zbędnego kodziku w [@InSMS]
`- poprawka w [@rd8CY] aby można było wyczyścić numery na które nadajemy SMS info alarm...
`
`
`tutaj numery do zapisu do konfigu jako tajne: [@_wCO3]
` jako tajny i jako payny jest TakTak 692 866 403
`
`
`uporządkuj @SMsp0..6
`
` gdyby nie było utworzonego numeru centrum SMS to po każdym skasowaniu trza wpisać nowe
`   może sprawdzanie czy jest numer centrum i jak niema to nie wysyła SMS?
` 1. popraw statystykę wysyłania reklam, teraz wysyła przy 9 zawsze (bo za next 256 sekund spasuje)
` 2. zapisywanie ilości wysłanych reklam aby była statystyka, wysyłanie ich potem SMSem
` 
` reklam i SMSów nie wysyłaj na stacjonarne! a właściwie dlaczego? skoro wysyła tam inne SMSy
`    to i reklamowe może ;o))
` połączenie przychodzące z TPSA może być Tone ? bo jest w tekście jako T... !
` może zamiast myślnika lub podkreślenia zrobić dowolny znak? w rozpoznawaniu SMSów?
` 
`zmiany /20081216/:
`------------------
`@SMdAc -poprawiłem sprawdzanie czy tajny/pajny/jawny dla ew. blokady SMSów jawnych
`@Roz42 -zmieniłem #8EF8 na #8EF7 
`
`co trzeba zrobić:
`-----------------
`program:
`--------
` wykonaj obsługę kroków abonamentowych @KR000...@KR003 ...
`   [@AWLKD] wykonuje obliczanie ilości dni od abonamentu /wykonuje w lukach DCF77/
` po odebranych SMSach TEST i PROFIL nie może być spacji przed pytajnikiem -popraw to
`
` spr. czy wykorzystać przy tajnych/paynych: #8ACC, #8DD9, #8DDD ?
`
`zablokowane:
`1. @SMsp4 ->kradzież miejsca na tajny
`2. @SMsp5 ->reklamy
`3. @SMsp6 ->pusta
`
`-Przed Publikacją: zmienić numer tajny i payny na swój jakowyś Tak-Taka np
`
`-w moim układzie:
`  zablokuj kradzież miejsca [@SMsp4]
`  zablokuj reklamy [@SMsp5]
`  zablokuj ...
`  zablokuj all tajne/payne
`
`sprzęt:
`-------
`-detektor dzwonka do drzwi nie działa
`-detektor podniesionej słuchawki nie działa
`-filtr do livebox'a
`-odległość anteny (GSM) od układu!
`
`
`=========================================================
`ewentualnie na przyszłość:    
`1. usprawnij kradzież miejsca 
`   i rozróżnienie między miejscem wpisanym a określonym z LAC...
`=========================================================
` 
` a co jeśli jako nadawca SMSa będzie numer bez prefixu?
` 
` U W A G A ! ! !
`=================
`tabele @TRuRa, @tNOKI, @RxRAM, @RxACK, @TxRAM, @TxACK, @MNkro, @ldnim, 
`       @NaDnT, @DT_MI, @krASt, 
`nie mogą być na przełomie!!!
`
`assembler NOKIA 5110
`autor Wiktor Szymanowski / 24 11 2005 - ...08 11 2007... - ?
`
`============================================================================================
`MAPA ADRESÓW:
`============================================================================================
`#0000-#7FFF -EPROM 32k
`#8000-#FFFF -RAM 32k
`#4000-      -? free
`#4040-#4043 -8255 dla TPSA
` PIO #4040 PA OUT    #4041 PB IN       #4042 PC 0-3 OUT / 4-7 IN     #4043 P@ -sterujący
`  0 CS  \            0 IRQN \          0 brąz linia ->telefon dzwoni 
`  1 RW  | MT8880C    1 RXD  | CML602B  1 MODE \                      
`  2 RS0 |            2 DET  /          2 ZP   | CML602B              
`  3 fi2 /            3 syg.420Hz       3 RXCK /                      
`  4 przek odb telef. 4 monitor 230V    4 D0   \                      
`  5 =1 to IDS1420    5 ?               5 D1   | MT8880C              
`  6 =1 to REC?       6 LowVolt         6 D2   |                      
`  7 =1 ALARMbrąz     7 HighVolt        7 D3   /                      
` trzeba wygospodarować bit OUT stserujący wymuszeniem na brązie poziomu ALARM
` jeden z pomysłów to 7475, inny to PIO 8255 #4040 PA 6 lub 7
`
`#4080-      -? free
`#40C0,#40C1 -8251 w domowym dla domowej RS232, /a w autkowym dla GPS?/
`#5000,#5001 -8251 do mbus'a NOKIA
`#5040-#5043 -8255 dla LCD i brąza i trochę wolnych bitów
` PIO #5040 PA IN (płytka NOKIA)     #5042 PC OUT
`  0 sygnał DCF77 (brąz lub direct)  0 =0 świeci LEDred statusu
`  1 dzwonek telefonu na hamaku/TPSA 1 \
`  2 gong do drzwi                   2  | bez znaczenia /steruje nimi dla LCD/
`  3 otwarte drzwi                   3 /
`  4 alarm -brak napięcia brąza      4 =0 świeci LEDblue zapełnienie LOG_RAM
`  5 n.c.                            5 =0/1 pobudzanie watchdoga
`  6 n.c.                            6 =0 świeci LEDyellow poziom DCF77 / (stanGPS)
`  7 n.c.                            7 =0 świeci LEDgreen poziom GSM
`#5080       -7475 dla NOKIA (sterownik NOKIA OnOff&key)
`#50C0,#50C1 -8251 do PC
`============================================================================================
`MAPA PAMIĘCI RAM:
`----------- blokowanie NMI --------------------------------
`#8000 -> bity systemowe:
` bit7 -> =0 to zablokowana obsługa przerwań NMI
` bit6 -> 
` bit5 -> 
` bit4 -> 
` bit3 -> 
` bit2 -> 
` bit1 -> 
` bit0 -> =1 NIEaktualne ASCII 16& znaków daty/czasu po przestawieniu zegara
` ---------- komórki TIME ----------------------------------
`#8001 -> 1b status TIME:  /zakres #00...#07!/
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA lub z tel. stacjonarnego (może być zły)
`                           to chyba też z SMSa otrzymanego a nie #01 z SMSa?
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno lub z PC
`                      #04-ustawiony z delivery niedawno
`                      #05-ustawiony z DCF77
`-----------------
`#8002 -> komórka cykliczna (zmienia swą wartość z szybkością przerwań)
`        bit0 -> 500Hz czyli 1[ms]+1[ms]
`        bit2 -> 250Hz czyli 2[ms]+2[ms]
`        bit2 -> 125Hz czyli 4[ms]+4[ms]
`        bit3 -> 62,5Hz czyli 8[ms]+8[ms]
`        bit4 -> 31,75Hz czyli 16[ms]+16[ms]
`        bit5 -> ok.16Hz czyli 32[ms]+32[ms]
`        bit6 -> ok.8Hz czyli 64[ms]+64[ms] ??????????? chyba jednak dwa razy rzadziej
`        bit7 -> ok.4Hz czyli 128[ms]+128[ms]
`#8003 -> ułamki sekund zliczane co czwarte NMI. 250 (#FA) przeskakuje na 0 (#00),
`#8004 -> sekundy,       \
`#8005 -> minuty,         \zliczane jako 
`#8006 -> godziny,        /czas rzeczywisty...
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`#800B ->16&bajtów ASCII tekstowo zapisana godzina i data: "20061231ni235959"
`        to ASCII nie może być na przełomie starszego bajtu adresu
`        powyższe ASCII jest zawsze aktualne (bo jest zapisywane zawsze w całości &16znaków),
`        jeśli następuje zmiana czasu (np. przestawienie zegara) wystarczy wyzerować #86C1
`     -----     
`#801B - 1b- free
`     ----- komórki łopaty NOKIA i wyżej -----
`#801C -> 1b nr komunikatu wysyłanego do NOKIA sterujący NORMALEM MASTER modulo 3
`#801D -> 2b adres od którego wysyłamy i pod który odbieramy dla NOKIA /dynamiczny/
`#801F -> 1b długość w bajtach tego co wysyłamy i odbieramy dla NOKIA /dynamiczna/
`#8020 -> 1b powtórzeń nadawanych tej samej ramki (odliczana w dół)
`#8021 -> 1b do dynamicznego obliczania XOR
`#8022 -> 1b ID NOKIA numer komunikatu odebranego z NOKIA
`#8023 -> 1b ID Z80 numer komunikatu nadawanego z Z80
`#8024 -> 1b bajt określający NOKIĘ (#00)
`#8025 -> 1b bajt określający Z80 (#1D)
`#8026 -> 2b biegnący w dół do zera czas oczekiwania np. na ACK lub kolejny bajt odbioru, 
`            lub time guard dla nadawania (w zal. od ilości bajtów do nadania)
`            odliczany (doliczany i ustalany) przez procedury Rx Tx i Slave...
`            rozdzielczość 100mikrosekund. np. &3000 = #0BB8 -> 0,3 sekundy
`#8028 -> 1b krok odbioru ACK, krok odbioru komunikatu z NOKIA
`      bity: 7,6 - niewykorzystane
`           5,4=0 -> procedura odbioru ramki
`              =1 -> procedura odbioru ACK
`              =2 -> procedura nadawania ramki
`              =3 -> procedura nadawania ACK
` bit 3=1 to blokada łopaty,
` poniższy krok jest również znacznikiem wykonania, MASTER jest wykonywany tylko gdy bit3=1
` przed startem ramek odbioru podaj czas, jaki ma czekać na ramkę (ACK)
`                 |   #00       |     #10    |      #20    |    #30
`            krok | odb. ramki  | odb. ACK   | nad. ramki  | nad. ACK  
`  bity:3,2,1,0=0-7 realizacja SlaveNokia
`          =#08 -                        STOP OK
`      =#09-#0E - STOP -nie wykorzystane-
`          =#0F -                STOP error timeover
`       ------------
`#8029 -> 1b numer rutynowej ramki do nadania a gdy =#00 to ramka o adresie =#81C8
`#802A -> 1b kroczek odbioru ramki  (środka):#00 rozkaz          -> do #80C6
`                                            #01 Hb długość =#00 -> do #80C7
`                                            #02 1b długość      -> do #80C8 i #801F
`                                            #03 treść bez ID i bez XOR
`      -> też jako kroczek...
`      -> też jako kroczek In/Out analizy występującej przed nadaniem ACKa w #0A MKroku
`----------
`#802B -> 1b krok MASTER NOKIA
`#802C -> 1b licznik 'bez odpowiedzi'
`#802D -> 1b delay pauzy, 1 jednostka to 32 przerwań czyli 128ms,/posuwany przez @time+/
`         chyba dla OnOff na początku... 
`#802E -> 1b DKROK, oznaczający:
`          #00 -żądaj IMEI
`          #03 -żądaj SMSa z poz #09
`          #04 -żądaj SMSa z poz #0A
`          #05 -żądaj SMSa z poz #09
`          #08 -stwórz ramkę USERA dla zapisu konfigu na poz #09
`          #09 -stwórz ramkę USERA dla zapisu konfigu na poz #0A
`          #0C -zapisz/odczytaj datę i czas do/z NOKIA
`          #0D -zapisz/odczytaj datę i czas do/z NOKIA
`          #0E -ustaw alarm w NOKIA
`          #FF -nic nie rób w tej kwestii (normalna praca mbusa)
`---
`#802F -> 1b komórka do cyklicznego żądania SMSów z @MN_06 kroku,wartości #00-#19
`#8030 -> 25& (#19)bajtów [bez przełomu!] odpowiada poszczególnym pozycjom SMSów na SIM 
`         i określa co zrobić z tą pozycją w czasie analizy (czy ignorować) i w czasie
`         cyklicznego odczytu. W czasie cyklicznego nie sprawdza pozycji konfigu
`          #01 -SMS do skasowania, skasować ten SMS,
`          #02 -zaznaczony do skasowania pierwszy raz -'chińskie'
`          #00, #03-#7F -bez znaczenia dla przeszukiwania cyklicznego
`          #80 -#FF -zablokowany -cykliczna nie żąda tego SMSa
`---
`#8049 -> 2b KEYów co zrobić: /lub co właśnie robimy/
`       1szy bajt bitami:
`         7  6  5  4  32  10  
`         0=nic           
`         1=zrób          
`            0=jeden przycisk (pierwszy)
`            1=dwa przyciski
`               0=krótka przerwa pomiędzy wciśnięciami
`               1=długa    -||-      -||-      -||- 
`                  0=krótkie przyciśnięcie
`                  1=długie   -||-   -||- 
`                     00- C   C
`                     01- C   OK
`                     10- OK  C
`                     11- OK  OK
`                         00=przed wciskaniem
`                         01=1szy wciśnięty
`                         10=przerwa
`                         11=2gi wciśnięty
`
`obsługa przycisków OK i C
`                                            #xx : 7 6 5 4 3 2 1 0
`   wciśnięcie samego OK na krótko:          #84 : 1 0 x 0 x 1 0 0
`   wciśnięcie samego OK na długo :          #94 : 1 0 x 1 x 1 0 0
`   wciśnięcie samego C na krótko:           #80 : 1 0 x 0 x 0 0 0
`   wciśnięcie samego C na długo :           #90 : 1 0 x 1 x 0 0 0
`   wc. C, i OK na krótko z krótką przerwą : #C8 : 1 1 0 0 1 0 0 0
`   wc. C, i OK na krótko z długą przerwą :  #E8 : 1 1 1 0 1 0 0 0
`   wc. C, i OK na długo z krótką przerwą :  #D8 : 1 1 0 1 1 0 0 0
`   wc. C, i OK na długo z długą przerwą :   #F8 : 1 1 1 1 1 0 0 0
`   wc. OK, i C na krótko z krótką przerwą : #C4 : 1 1 0 0 0 1 0 0
`   wc. OK, i C na krótko z długą przerwą :  #E4 : 1 1 1 0 0 1 0 0
`   wc. OK, i C na długo z krótką przerwą :  #D4 : 1 1 0 1 0 1 0 0
`   wc. OK, i C na długo z długą przerwą :   #F4 : 1 1 1 1 0 1 0 0
`   wc. 2* OK na krótko z krótką przerwą :   #CC : 1 1 0 0 1 1 0 0
`   wc. 2* OK na krótko z długą przerwą :    #EC : 1 1 1 0 1 1 0 0
`   wc. 2* OK na długo z krótką przerwą :    #DC : 1 1 0 1 1 1 0 0
`   wc. 2* OK na długo z długą przerwą :     #FC : 1 1 1 1 1 1 0 0
`   wc. 2* C na krótko z krótką przerwą :    #C0 : 1 1 0 0 0 0 0 0
`   wc. 2* C na krótko z długą przerwą :     #E0 : 1 1 1 0 0 0 0 0
`   wc. 2* C na długo z krótką przerwą :     #D0 : 1 1 0 1 0 0 0 0
`   wc. 2* C na długo z długą przerwą :      #F0 : 1 1 1 1 0 0 0 0
`
`   #804A -> 2gi bajt to czas 0-7 trwania wciśnięcia lub przerwy
`---
`#804B -1b zapamiętana pozycja ks tel z tabeli #8502 dla skasowania 7bitu (nadpisania numeru)
`          gdy przyjdzie ramka potwierdzenia zapisania numeru tel na kartę SIM do ks tel
`---
`#804C -> 2b czas, jaki upłynął od lokalizacji GSM telefonu LAC CID /ostatniej chwilowej/
`   #804C -sekundy \
`   #804D -minuty  /cykany przez time+ do wartości minut #F0, później stoi
`#804E -> 2b CID      \
`#8050 -> 2b LAC      |sieć i lokalizacja telefonu (chwilowe)
`#8052 -> 4b SIEĆ GSM /
`---
`#8056 -> 1b ?chwilowy poziom naładowania baterii?
`#8057 -> 1b chwilowy poziom sygnału GSM #00 do #04
`#8058 -> 1b ?chwilowy poziom temp. baterii?
`---
`#8059 -> 8b to &15 cyfr IMEI + zero skompresowanych dwie w jednym bajcie (identycznie jak w NOKII)
`  (ostatnia pusta pozycja to OR #F0)
`   aby sprawdzić czy jest IMEI, wystarczy sprawdzić ostatni bajt, 
`  (po starcie wpisujemy tam #00 (#8060))
`#8061 -> 6b to ASCIIZ nazwa modelu aparatu NOKIA np."NSE-1"
`#8067 -> 8b to ASCIIZ ? "0502562"
`#806F -> 5b to ASCIIZ ? "4230"
`#8074 -> 6b to ASCIIZ ? "05.28"
`#807A -> 1b time -gdy >0 to oczekuje na poz (#807E) z ks. telef.
`#807B -> 1b pozycja SMSa, którą kasujemy (odczytujemy)
`#807C -> 1b poziom sygnału GSM i stan komunikacji mbus 
`                                   #00 to brak komunikacji z tel.
`                                   #01 to poziom GSM odpowiadający 0 kresek na wyśw. NOKIA
`                                   #02-#05 to poziom GSM odpowiadający 1-4 kresek na wyśw. NOKIA
`#807D -> 1b czas (minuty) do zapisu konfigów -biegnie sobie w dół popychany w time+
`            przejście z #01 na #00 powoduje (jeśli DKrok=#FF) wpisanie DKrok =#08, jeśli
`            niemożliwe to pozostaje przez kolejną minutę #01,
`            po potwierdzeniu zapisu SMSa w Dkroku =#09 wpisujemy tu czas w minutach do 
`            następnego zapisu konfigów
`#807E -> 1b dana do odczytu książki telefonicznej (przy odczycie całej książki):
`            =#00 -... -tą pozycję odczytujemy
`            =#80 - odczytano już całą książkę z SIM
`#807F -> 1b oznaczający kolejne #00-#08 przeszukiwane pozycje ks. tel SIM zawierające znane numery
`                 lub >#08 -przełącz, aby przeszukiwać teraz całą książkę (znane już przeszukane)
`                     #FE  -gdy szukaj kolejnego w ks. telefonicznej
`                     #FF  -gdy wszystkie przeszukane
` |odczyt książki telefonicznej wygląda tak: najpierw #807F =#00..#09 to spr. poz znane
` |                                          później  #807F =#FE to sprawdzamy cała ks tel
` |                               według #807E #00..#7F, a później #807F =#80
` |                                       a #807F =#FF i to oznacza przeszukanie całej książki
`                                                                                           
`#8080 -> 1b oznaczający ile kolejnych serii prób nadania będzie dokonywanych w przypadku braku
`            odpowiedzi na oczekiwany komunikat, jest zerowany po otrzymaniu odpowiedzi na żądany
`#8081 -> 1b licznik kolejnych prób żądania SMSów konfigu &09/&0A
`----------
`#8082 -> #16 bajtów tabela &11 sztuk po 2 bajty w kolejności 0 do 9 odpowiadającej znanym numerom
`   i po nich A -dla numeru innego niż znane,
`   odliczanie rozpoczynamy z chwilą potwierdzenia wysłania SMSa!
`         zawiera informację o postępie wysyłania SMSa w dwóch bajtach:
`         bajt +#00 to numer umowny nadany przez NOKIA w momencie wysłania potwierdzenia
`                                              wysłania SMSa (ważna gdy drugi bajt <>#00!)
`         bajt +#01 to czas w sekundach od momentu tego: #00-nic STOP
`                                                        #01-#FE /odliczanie zaczynamy od #01/
`                                                         po #FE przeskakuje na #FF i robi STOP
`   w tym: #8096 -> 2 bajty odpowiadające nieznemu numerowi dla wysłanego SMSa
`#8098 - #809D -> 6b tmp czas z konfigu SMSa &09... /już przeliczone/ rok w #809D
`                jeśli rok (#809D) jest =#00 to nie było SMSa konfigu z poz. &09
`---
`#809E -> 1b licznik godzin czasu od wiarygodnego ustawienia zegara po którym staje się 
`               niedokładny... i przeskakuje na #03 TimeState
`---
`#809F -> 1b numer tylko do rozpoznania: #00-#09 pozycja w znanych numerach
`       po 10 wywołaniach CPIR procedurka poCPR robi tak:
`                                           #FF-zastrzeżony
`                                           #FE-nieznany /przeszuk cała ks.tel/
`                                           #FD-nieznany /NIE przeszuk cała ks.tel/
`                                           #FC-błędny
`                                          lub że rozpoznany (#00-#09) 
`                                               umownie  #0A -jako numer konfigu (20znakowy...)
`#80A0 -> 1b liczba cyfr numeru skompresowanego #80A1...
`#80A1 -> &10b znaki nru przerobione na dwa w 1bajcie -do porównań RING i SMS i KsTel.
`-------------------------
`#80AB -> 1b tu ląduje 8 bitów odczytanych z portu A 8255 IN płytka NOKIA 
`               |7|6|5|4|3|2|1|0| 
`                | | | | | | | |  
`                | | | | | | | --< bit DCF77
`                | | | | | | ----< bit dzwonka telefonu na hamaku/TPSA
`                | | | | | ------< bit gongu do drzwi
`                | | | | --------< bit otwartych drzwi
`                | | | ----------< bit alarmu -brak napięcia brąza
`                | | ------------< n.c. 
`                | --------------< n.c. 
`                ----------------< n.c. 
`#80AC -> 1b z którego 4 bity 3-0 wysyłamy do portu C 8255 OUT
`               |7|6|5|4|3|2|1|0|
`                | | | |       |-> =0/1 pobudzanie watchdoga
`                | | | | |-|-|---> bez znaczenia /steruje nimi dla LCD/
`                | | | ----------> =0 świeci LEDblueLED zapełnienie LOGu
`                | | ------------> =0 świeci LEDgreen poziom GSM
`                | --------------> =0 świeci LEDyellow poziom DCF77
`                ----------------> =0 świeci LEDred statusu
`#80AD ->1b zawiera bity StanuSystemu ->są zamieniane na bajt #00-#04 do #80C5
`         -----------------
`         |7|6|5|4|3|2|1|0| bity stanu: 1= Aktywny, 0= NIEaktywny
`         -----------------
`          1 x x x x x x x  -> \stan #00 -świeci []
`          x 1 x x x x x x  -> /    (cały czas) =bardzo źle []
`          0 0 1 x x x x x  -> \stan #01 -szybko mruga =źle []
`          0 0 x 1 x x x x  -> /                            []
`          0 0 0 0 1 x x x  -> \stan #02 -mruga =niedobrze           []
`          0 0 0 0 x 1 x x  -> /                                     []
`          0 0 0 0 0 0 1 x  -> \stan #04 -wolno mruga =coś szwankuje []
`          0 0 0 0 0 0 x 1  -> /                                     []
`          0 0 0 0 0 0 0 0  ->  stan #05 super, LED zgaszona         []
`-------------------------------------------------------------------------------
`#80AE -6b. pomocniczo używane do zakodowania treści SMSa na ramę USERa do mbusa:
`  #80AE -2b. dynam. adres źródła bajtów/textu
`  #80B0 -2b. dynam. adres w SMSie
`#80B2 - 1b pomocniczy chwilowy poziom sygnału GSM #00-#04 
`                                              lub #FF gdy nieodebrany po żądaniu
`----------------
`#80B3 - 1b sekundy od pierwszego wczytania konfigu po RESET,
`        stoi gdy 7bit=1 lub gdy =#00, else idzie co sekundę do góry
`----------------
`#80B4 -2b licznik sekundowy =#0000 lub 15bit=1 to stoi, 
`                     else idzie ->licznik pozytywnego poziomu GSM
`#80B6 -3b licznik sek/min/godz braku poziomu GSM, stoi gdy 7bit sek =1 else idzie
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
`         bit5: =0 nic, =1 przedstawiono się na LCD
`         bit4: =0 nic, =1 gotowy tekst z bufSMSa czeka na wykorzystanie do przedstawienia
`         bit3: =0 nic, =1 
`         bit2: =0 nic, =1 
`         bit1: =0 nic, =1 
`         bit0: =0 nic, =1 
`#80BA -3b czas najdłuższego braku sygnału GSM, sek/min/godz
`----------------
`#80BD - 1b- liczona dynamicznie autosuma 
`----------------
`#80BE - 1b stoperek blokady gen. zdarzenia #14 TPSA (poł. przychodzące)
`          aktywowany po zaniku/pojawieniu się nap linii telefonicznej
`          oczywiście dłuższym niz pulsowe wybieranie numeru
`                gdy #00 to stoi =nie ma blokady,
`                gdy >0 to idzie i blokuje gen zdarzenia #14
`                     cyka co sekundę                          
`#80BF -2b poprzedni stan napięcia linii TPSA i czas tego napięcia
`#80C1 - 1b zliczana liczba impulsów przy wybieraniu pulsowym
`#80C2 - 2b -adres dynamiczny liczonej autosumy EPROM
`#80C4 - 1b maska dla klawiszy NOKIA, umożliwiająca generację lub zakończenie generacji
`           fali prostokątnej podtrzymującej zasilanie autkowego
`#80C5 - 1b wartość #00-#05 służąca jako dana dla procedury sterującej SystemStatusLED
`           jest obrabiana przez @poINh w wolnej chwili procedury @nokia
`---------------------------------------------------------------
`#80C6 -> bajty bufora odebranego komunikatu z NOKIA
`  !!! / 80C6-80C8 nie może być na przełomie / !!!
`         --------------------------------------struktura:
`         #80C6    -> rozkaz 1b                 
`         #80C7    -> \długośćH =#00 jako 'podkod' ramy: #00-#0F =długie realizacje
`                                                        #10-#FE =krótkie realizacje
`                                                        #FF     =r.niezrozumiała
`         #80C8    -> /długość 1b                 
`      #80C9-#81C7 -> treść o długości jak wyżej (max. &255 #FF)
` --------------                    
`    bajty #80C8-#80CD modą być wykorzystywane jako zmienne pomocnicze przy analizie ramki,
`     dla odczytu pozycji SIM książki telefonicznej są wykorzystane następująco:
`         #80C8- 2b -> zapamietany adres numeru ASCII w ramie (już po pominięciu plusa)
`         #81C5- 2b -> zapamiętany adres w tabeli znanych, na który kompresować numer ASCII,
`         #80CC- 1b -> faktyczna liczba znaków numeru (bez plusa jeśli był)
`         #80CD- 1b -> co to jest: (#00->PREFIX/#01->1ADMIN/#02->2USERS/#03->3KNOWN)
`    dla odczytu/odbioru SMSów są wykorzystane następująco:
`         #80C9- 2b -> adres nru nadawcy czyli dla odczytywanych tekstowego i bajtowego &30bajtu
`                                                  odebranych tekstowego i bajtowego &29bajtu
`         #80CB- 1b -> typ SMSa odebranego :#00-delivery, #01-tekstowy, #02-bajtowy
`                               odczytanego:#80-delivery, #81-tekstowy, #82-bajtowy, (#83-config),
`    to  #80CC- 1b -> liczba liter (dla tekstowego, dla innych śmieci)
`        #80CD- 1b -> dla delivery oznacza numer w przeszukiwanej tablicy wysłanych SMS [#22BE]
`    lub   #80CC- 2b -> adres dynamiczny dla delivery w tabeli nr umownych wysłanych SMSów
`         #80CE- 1b -> pozycja SMSa na SIM
`    to  #80CF- 1b -> nr umowny dla delivery
`    lub   #80CF- 1b -> autosuma obliczana dla bajtowego
`        #80D3 `dynamiczny adres wynikowy tekstu
`        #80D1 `dynamiczny adres rozkodowywanego SMSa
`        #80D5 `dynamiczny adres rozkodowywanego SMSa
`        #8182 `bajt wykorzystywany później do oceny numeru tel. w majstrze
`        #8183 `adres rozkodowywanego SMSa
`---
`#81C8 -> bajty bufora komunikatu USERa
`  !!! / 81C8-81CA nie może być na przełomie / !!!
`         --------------------------------------struktura:
`         #81C8    -> rozkaz 1b
`         #81C9    -> \długośćH =#00 /gdy tu=#00 tzn. że gotowy do nadania kom. USERA/
`                                     gdy #01-#7F to kom. USERA w trakcie tworzenia -nie zmieniać!
`                                     gdy >=#80 (zapalony 7bit) to wolny, można użyć
`         #81CA    -> /długość 1b 
`      #81CB-#82C9 -> treść o długości jak wyżej (max. &255 #FF)
`---
`#82CA-#84ED -> obszar pamięci RAM zawierający treści 4 obszarów (o nr: 0-3) 
`                                                       SMSów bajtowych sterujących
` 1 SMS może przenieść #8C bajtów, ale 1 bajt to autosuma, dwa bajty to klasyfikacja: 
` (obszar/konfig/bajtowy zwykły), tak więc jest to #01 + #88 = #89 = #8C -1 -2 bajtów
` dla jednego  obszaru
` obsz0: #82CA -1b -numer wersji (gdy #00 to pusty),
`        #82CB -#88 bajtów treści (gdy pusty to nieważne bajty)
` obsz1: #8353 -1b -numer wersji (gdy #00 to pusty),
`        #8354 -#88 bajtów treści (gdy pusty to nieważne bajty)
` obsz2: #83DC -1b -numer wersji (gdy #00 to pusty),
`        #83DD -#88 bajtów treści (gdy pusty to nieważne bajty)
` obsz3: #8465 -1b -numer wersji (gdy #00 to pusty),
`        #8466 -#88 bajtów treści (gdy pusty to nieważne bajty)
`-----                                    
`#84EE - #84FE -komórki Managera tworzenia i nadawania SMSów
`  #84EE -1b. polecenie nadania SMSa i etap na jakim się znajduje
`        ! zewnętrzne procedury mogą modyfikować treść SMSa, numeru i tej komórki
`          tylko gdy 7bit=0!!!            
`                     -----------------   
`             bitami: |7|6|5|4|3|2|1|0|   
`                     -----------------   
`                      | | | | | | | |    
`=0 można zmieniać<----- | | | | | | -> =0 z potwierdzeniem odebrania delivery
`=1 NIE zmieniać !!!     | | | | | |    =1 bez potwierdzenia
` ^                      | | | | | |      
` 1=000-przed USERa <--------- | | ---> =0 normalny SMS \dot. tekstowego
` 1=001-czeka bo poprzedni     | |      =1 flash        /przy bajtowym nie ma znaczenia
`    deliv. nie dotarł         | |        
` 1=010-tworzy USERa           | -----> =0 text
` 1=011-jestUSER (przed TxMBUS |        =1 byte
`    lub nadany, czeka..)      |          
` 0=100-nadano SMSa  STOP      -------> =0 \
`    (ew.adres timea w #27..)           =1 /n.c.
` 0=101-NIE nadano SMSa STOP /też gdy brak numeru odbiorcy/
` 0=110-...zapas                          
` 0=111-...zapas                          
`                                         
`#84EF -2b !adres! komórki w RAM zawierającej czas oczekiwania na deliver'a 
`#84F1 -2b adres treści -textu  /zakończony #00 lub do &160 znaków -bez znaczenia 
`                                                                    -to co pierwsze/
`                       -bajtów /zawsze #008C bajtów/
`#84F3 -1b numer odbiorcy ze znanych (#00-#09) a gdy >= #0A to next &11b to odbiorca inny
`#84F4 -&11b numer odbiorcy innego (dowolny) 1b (l.cyfr) + &10b (cyfry)
`#84FF -1b -timeGuard wysyłania SMSa (oczekiwanie na potwierdzenie wysłania lub NIE wysłania)
`       =#00 =stoi, #01... to cyka co sekundę
`-------------
`#8500 -#858A -> #8B = &139 bajtów konfiguracji zapisywanych w SMSach &09 i &0A:
`!` ->->-> #8500-#8508 NIE NA PRZEŁOMIE!!!
`!`#8500 -> 1b pozycja centrumSMS w książce telefonicznej na SIM lub cokolwiek (i tak to jeszcze)
`!`                                                          później analizuje po otrzymaniu
`!`#8501 -> 1b pozycja prefiksu w książce telefonicznej na SIM lub...
`!`#8502 -> 8b oznaczających numer pozycji w książce na SIM z której 
`!`                               odczytano numer tel. do znanych (#00...#FF)
`!`       spróbujmy wprowadzić taką zasadę, przeszukując SIM szuka tylko pozycji 0 do &99
`!`       jeśli =#00 to brak nru z SIM, gdy #01-#64 jest poz z SIM
`!`       tak więc jeśli 7bit jest zapalony, czyli #81-#E4 to na numer z tej pozycji SIM
`!`       nadpisano numer z komputera -> trzeba nadpisać na SIM
`!`       jeśli zaś jest #80 to trzeba zapisać w jakiejkolwiek innej pozycji niż
`!`       znajdujące się pozycje SIM w tej tabeli
`!`#850A -> 5b to dane o domyślnym prefiksie -dołączanym do każdego nru 
`!`            połączenia przychodzącego, który nie zaczyna się plusem
`!`   #850A -> 1b to liczba cyfr(tylko!) ASCII 0-4 domyślnego prefiksu (=0 gdy brak prefiksu)
`!`   #850B -> 4b to 4 kody ASCII cyfr tego domyślnego numeru prefixu
`!`#850F ->1b skonfigurowany max czas w minutach, powyżej którego Z80 żąda sieci,LAC/CID
`!`#8510 ->1b dzień tygodnia [0..6] wysłania ostatniego meldunu dobowego
`!`#8511 ->4b licznik 4bajtowy wysłanych wszystkich SMS /duży bezwzględny/
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|
`!`          | | | | | | | |- =0 nic,=1 wysłano SMSa 'pełny LOG',
`!`          | | | | | | |--- =0 nic,=1 
`!`          | | | | | |----- =0 nic,=1 
`!`          | | | | |------- =0 nic,=1 ---------- skradziono 10 numerów /w tym miesiącu/
`!`          | | | |--------- =0 nic,=1 raportowano_płatność po RESET na tajny
`!`          | | |----------- =0 nic,=1 skradziono opis miejsca
`!`          | |------------- =0 nic,=1 przedstawiono się na 1szy jawny
`!`          |--------------- =0 nic,=1 
`!`#8516 ->2b licznik 2bajtowy wysłanych wszystkich SMS /mały, "zerowalny"/
`!`#8518 - 8b &64 klucze zapisz zdarzenie (=1) lub olej zdarzenie (=1)
`!`        gdzie #8518 bit0 to zdarzenie #01 a bit1 to #02...
`!`   poniższe to znów pamięć wieczna a matryce są organizowane w RAM...
`!`   warto zauważyć że zdarzenie które będzie uznane za informację nie będzie sprawdzane,
`!`   czy jest alarmem                                               
`!`#8520 - 8b &64 klucze informacja (=1) lub nie (=0)
`!`#8528 - 8b &64 klucze alarm (=1) lub nie (=0)
`!`#8530 -> &11 bajtów numeru własnego: 1b + &10b /normalnie jak standard/
`!`         l.znaków +&20 połówek bajtu=cyfr, uzup #F0 i reszta #00
`!`         jeśli l.cyfr=#00 to brak numeru
`!`#853B -> 1b pamiętający przesłanie skradzionych numerów 7b=0 nie wysłano alarmów
`!`                                                          =1 wysłano już alarmy
`!`                             bity 6-0 ... coś z kradzieżą numerów nie będących alarmami
`!`#853C -> 2b ID konfigu służący do sprawdzenia, czy nie wymieniono kart SIM -> [#8DF7]
`!`
`!`
`!`#853E -> free
`!`[...]    free
`!`#8548 -> free
`!`
`!`
`!`#8549 -> &11b treść SMSa paynego /treść ASCIIZ lub ASCII gdy &11 znaków/
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit6 -> tryb 0..1
`!`             -bit5 -> wysłano SMSa paya
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7..6 -> krok 0..15
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
`!`#8557 -1b godz wysłania melduna dobowego 
`!`      7bit=0 z meldunkiem dobowym, =1 bez meldunku dobowego
`!`#8558 -1b &8 kluczy zdarzeń specjalnych nie zapisywanych do LOGu na które wysyła SMS
`!`       bit 7 - 0=nic, 1=generuj SMSa o wysłaniu 100SMS
`!`       bit 6 - 0=nic, 1=generuj SMSa o pełnym LOGu
`!`       bit 5 - 0=nic, 1=redirect nierozpoznane SMSy
`!`       bit 4 - 0=nic, 1=SMS o połączeniu przychodzącym gdy nieznany numer
`!`       bit 3 - 0=nic, 1=połączenie ze znanych traktowane jako polecenie TEST
`!`       bit 2 - 0=nic, 1=
`!`       bit 1 - 0=nic, 1=
`!`       bit 0 - 0=nic, 1=
`!`#8559 -1b profil ustalający siatkę zdarzeń generujących alarm/informację (0...&15)
`!`       AND #0F oczywiście, siatka >#0E to siatka z SIM =MISC=
`!`       bit7=0  ='priorytet ALARM'
`!`           =1  ='priorytet INFORMACJA'
`!`#855A -1b numery na które dzwonimy TPSA gdy ALARM i bez SMSa (jak w niżej)
`!`#855B -1b numery na które wysyłamy SMSspecjalny (jak w niżej)
`!`#855C -1b numery na które wysyłamy ALARM SMSem bit0 to 0 użytkownika, =1 to wysyłamy
`!`#855D -1b numery na które wysyłamy INFORMACJĘ SMSem j.w.    
`!`  powyżej bit0 odpowiada pozycji #02 nr telefonu jawną      
`!`---znane numery w konfigu:                                  
`!`#855E-#8569 ->12& bajtów centrum SMS (jak w SMSie)         |gdy (#855E)=#00 to pusty
`!`#856A: 1b + #856B-#8574 &10b numer 0 ('0' tajny)           |po &11 bajtów
`!`#8575: 1b + #8576-#857F &10b numer 1 ('1' payny)           |skompresowanych cyfr 
`!`#8580: 1b + #8581-#858A &10b numer 2 ('0' dla użytkownika) |(jak w SMSie)
`------------- koniec obszaru konfigu ------------            |ostatnia nieparzysta 
`  #858B: 1b + #858C-#8595 &10b numer 3 ('1' dla użytkownika) |uzupełniona o #F0
`  #8596: 1b + #8597-#85A0 &10b numer 4 ('2' dla użytkownika) |a po niej same zera!!!
`  #85A1: 1b + #85A2-#85AB &10b numer 5 ('3' dla użytkownika) |
`  #85AC: 1b + #85AD-#85B6 &10b numer 6 ('4' dla użytkownika) |jeśli jakaś pozycja zawiera
`  #85B7: 1b + #85B8-#85C1 &10b numer 7 ('5' dla użytkownika) |długość =0 
`  #85C2: 1b + #85C3-#85CC &10b numer 8 ('6' dla użytkownika) |to traktujemy ją jako pustą
`  #85CD: 1b + #85CE-#85D7 &10b numer 9 ('7' dla użytkownika) |
`         ^-----1b to liczba cyfr numeru tel.                  
`------------------------------------------------------------------------------------------
`#85D8 -> rozkodowany odebrany/odczytany SMS tekstowy/bajtowy:
`   #85D8 -> 1b =#00 to pusty bufor, =#FF to w trakcie rozkodowywania,
`               wartość tego bajtu różna od #00 i od #FF i od #FE oznacza, że to SMS tekstowy 
`               a ta właśnie wartość jest liczbą znaków ASCII rozkodowanego SMSa,
`               #FE oznacza że to SMS bajtowy o stałej długości treści =#008A bajtów
`   #85D9 -> 1b nr rozpoznany:
`                       #00-#09 pozycja w znanych numerach
`                       #FC-błędny
`                       #FD-nieznany (ale nie cała ks.tel jeszcze przeszukana)
`                       #FE-nieznany
`                       #FF-zastrzeżony
`   #85DA -> &11b numeru: /gdy rozpoznany to też tu jest numer/
`        #85DA -> 1b liczba cyfr numeru skompresowanego
`        #85DB -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0
`   #85E5 -> 7b sek/min/godz/dnmca/mce/rok/dztyg- czas z SMSa (otrzymano)
`                                      [gdy rok =#00 to błąd w dacie/czasie]
`   #85EC -> (do#868C)&161b /=#A1/ kodów ASCIIZ rozkodowanej treści SMSa/ 
`                                         /lub #89 bajtów z bajtowego
`#868D -1b -pozycja SMSa na SIM /do zaznaczania do usunięcia albo ignorowania/text/bajt/
`
`#868E -1b =#00 REC wyłączony, =#01 REC włączony dla obserwowanej TPSA 
`---------
`#868F -8b używanych do analizy czasu i jego ustawiania. wywoływać TYLKO w NMI!
`   komplet procedur do analizy 6 bajtów daty i czasu        
`   umieszczonych od dowolnego adresu umieszczonego np. w DE 
`   i dalej, jeśli analiza jest błędna to wynikowa wartość   
`   roku =#00.  wynik to:   /działa od 2005 roku i powżej/   
`  [@SMSd3]   (#868F) <- sekundy (#00-#3B)                   
`  [@SMSd3]   (#8690) <- minuty  (#00-#3B)                   
`  [@SMSd3]   (#8691) <- godziny (#00-#17)                   
`  [@SMSd2]   (#8692) <- dni miesiąca (#00 - #1E)            
`  [@SMSd1]   (#8693) <- miesiące nasze:[#00 - #0B]          
`                         /#00 to styczeń, #0B to grudzień/  
`  [@SMSd1]   (#8694) <- lata    (#05 = 2005r)        
`  [@SMSd4]   (#8695) <- dni tygodnia (#00-#06)              
`                           (#00 to poniedziałek)            
`  [@SMSd5]   (#8696) <- decyzja, czy można ustawiać         
`                        =#00 to nie ustawiaj,               
`       inna to ustaw zegar i zapisz tą wartość do StatusTime
`  [@SMSd6]   ustawia zegar w zależności od bajtu (#8696)    
`------------------------------------------------------------
`#8697 -2b adres na który przesłać (?) komunikaty RS232 z PC
`------------------------------------------------------------
`zmienne dla wykonywania połączeń fonicznych WYCHODZĄCYCH:
`#8699 -1b numer odbiorcy ze znanych (#00-#09) a gdy >= #0A to nr odbiorcy w #869A
`   #8699 -> 1b nr jako wyjściowy dla MakeCall:
`                       #00-#09 pozycja w znanych numerach
`                       #inny- podany ręcznie
`   #869A -> &11b numeru: /gdy znany to wartości dowolne/
`        #869A -> 1b liczba cyfr numeru skompresowanego
`        #869B -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0
`#86A5 -1b cyklicznie zmieniany sprawdzający konieczność/możliwość wysłania SMSa innego
`          niż opisującego zdarzenie, np. kradzież numerów, SMS specjalny, 
`          SMS płacący i SMS przedstawiający się cyklicznie od #00 do ... 
`          przy każdej próbie (nieregularnie) @ZdaGO gdy brak zdarzeń
`#86A6 1b IncommingCallResponse
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic nie rób, czekaj na decyzję,
`         1 --------------->zrób to co określają bity 6-0 a później zmień biy 7 na =0,
`         1 ? ? 0 ? ? 0 0  =zakończ outgoing ring/dial
`         1 ? ? 0 G M 0 1  =odbierz połaczenie używając G lub M lub GM lub wcale,(0=aktywny),
`         1 ? ? 0 ? ? 1 0  =odrzuć przychodzące połączenie ring/dial,
`#86A7 1b IncommingCallFlag
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic się nie dzieje,
`         1 --------------->ring lub dial,
`         dr vvv  G M ----->aktywność głośnika / mikrofonu (=0 to aktywny),
`         dr vvv      rd -->gdy zakończone połączenie to zakończone na ringu(=0) lub dialu (=1),
`         dr vvv        dN->gdy zakończone to przez kogo drugi/system (=0) lub NOKIA (=1),
`         1 011 xx00 => dzwoni, ale czas trwania dzwonka do 3 sekund
`         1 010 xx00 => dzwoni, czas trwania dzwonka powyżej 3 sekund
`         1 010 xx10 => rozmowa,
`         0 011 xx00 => po dzwonku uznanym za cynk,
`         0 010 xx00 => po dzwonku,
`         0 010 xx10 => po rozmowie,
`     np. 0 000 -po RESET...
`#86A8 1b MakeCall      
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic nie wykonuj,
`         1 --------------->ring lub dial,
`           x x x G M ----->aktywność głośnika / mikrofonu (=0 to aktywny),
`           x x x     rd -->gdy zakończone połączenie to zakończone na ringu(=0) lub dialu (=1),
`           x x x       dN->gdy zakończone to przez kogo drugi/system (=0) lub NOKIA (=1),
`         1 000 =wykonaj całość od początku,
`     ew. 1 001 =w trakcie wykonywania USERa,
`         1 010 =sporządzono USERa, czeka na nadanie i kwit z NOKIA,
`         1 100 =NOKIA przyjęła polecenie wybrania numeru,
`         1 110 xx00 =w drugim zaczęło dzwonić,
`         1 110 xx10 =trwa rozmowa
`         0 100 xx00 =po odrzuceniu przed dzwonkiem,
`         0 110 xx00 =po ring,
`         0 110 xx10 =po dial,
`#86A9 1b RingStatusLED/ obecny i jak zakończono ostatnią rozmowę/
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic się nie dzieje /pamięć ostatniego połączenia/
`         1 --------------->trwa ring lub dial,
`           1=outgoing
`           0=incomming
`             nc 
`                nc
`                 G M ----->aktywność głośnika / mikrofonu (=0 to aktywny),
`                     0=ring
`                     1=dial
`                       0=zakończył drugi/system
`                       1=zakończyła NOKIA
`#86AA 7b data i czas rozpoczęcia ring/dial (sek,min,godz,dniM,m-ce,rok,dz.tyg)
`#86B1 -> 3b pomiar czasu: -dzwonienia przychodzącego, 
`                          -rozmowy przychodzącej,
`                          -dzwonienia drugiego telefonu,
`                          -rozmowy wychodzącej,
`                          -wybierania numeru,
`      #86B1 -> sekundy,\
`      #86B2 -> minuty, |bieżące tego co się dzieje od zera w górę...
`      #86B3 -> godziny /
`   czas tutaj jest cykany przez time+ wtedy gdy godziny <#7F (&128),
`   co pozwoli nam blokować czas z zapamiętaniem jego wartości poprzez zapalenie 7bitu godzin,
`   wartość =#7F oznacza że trwa zdarzenie, ale czas jest równy lub większy od &127 godzin
`#86B4 -> 1b numer: z kim/do kogo dzwonisz: #00-#09 pozycja w znanych numerach
`       po 10 wywołaniach CPIR procedurka poCPR robi tak:
`                                           #FF-zastrzeżony
`                                           #FE-nieznany /przeszuk cała ks.tel/
`                                           #FD-nieznany /NIE przeszuk cała ks.tel/
`                                           #FC-błędny
`                                          lub że rozpoznany (#00-#09) 
`                                               umownie  #0A -jako numer konfigu (20znakowy...)
`#86B5 -> 1b liczba cyfr numeru skompresowanego #86B6...
`#86B6 -> &10b znaki nru przerobione na dwa w 1bajcie -do porównań RING i SMS i KsTel.
`#86C0 1b ID połączenia ring/dial in/out
`#86C1 -> 1b kroczku tworzenia ASCII daty i czasu w przerwach NOKIA z #8002-#8009
`                   `zerowanie #86C1 oznacza że ASCII daty/czasu nieaktualne
`#86C2 -> &16 bajtów tmp tworzenia ASCII daty i czasu 
`------------------------------
`#86D2 -1b poprzednio odczytany bajt z PIO PA 8255 brąz linii 
`#86D3 -1b czas trwania obecnego stanu na brąz linii w liczbie próbek (&255=8,16sekund)
`          bo 1 jednostka to 32[milisekundy], po zmianie zaczyna liczyć od #00
`#86D4 -1b przyjęcie otwarcia drzwi:
`          bit7=0 nie przyjęto
`               1 przyjęto
`             6=0 nie było PZD że otwarte za długo
`               1 było PZD otwarte za długo
`#86D5 -1b przyjęcie dzwonka do drzwi:
`          bit7=0 nie przyjęto
`               1 przyjęto
`             6=0 nie było PZD że dzwoni za długo
`               1 było PZD dzwoni za długo
`             5=0 nie było testowane PZD po 60sek konieczność wysłania o dzwonkach
`               1 było PZD dzwoni za długo
`               ...      
`             0=0 nie było PZD o alarmie/usterce
`               1 było PZD o alarmie/usterce
`#86D6 -2b CTOD =czas trwania otwartych drzwi        \
`#86D8 -2b CPZD =czas od ostatniego zamknięcia drzwi  \czas w sekundach od #0000 do #7FFF to idzie
`#86DA -2b CTDZ =czas trwania dzwonka                 /później stoi
`#86DC -2b CPDZ =czas przerwy od ostatniego dzwonka  /
`#86DE -7b czas i data (jak w zegarze) ostatniego otwarcia drzwi
`#86E5 -1b liczba dzwonków
`-------------------
`#86E6 -1b liczba próbek od ostatniego początku stanu 0 (aktywnego) DCF77
`#86E7 -1b przyjęty stan DCF77 #00 lub #01
`#86E8 -1b numer kolejnego bitu DCF77, jeśli =#FF to oczekiwanie na brak bitu,
`#86E9 -1b tryb pracy wyświetlacza LCD (drugiej linijki):
`  #00  `inicjacja wyświetlania LCD
`  #01  `przedstawianie się na LCD
`  #02  `reklama z EPROM
`  #03  `reklama z RAM
`  #04  `wyświetlanie naprzemiennie dwu buforów zdarzeń od prawej do lewej
`  #05  `alarmowo gdy nie ma np. możliwości wysłania SMS...
` wyższe to linijka nie wykorzystana
`#86EA -1b poziom sygnału DCF77 /#00 - #09/ liczba kolejnych poprawnych sekund
`odebrana informacja z DCF77:
`#86EB -> minuty,         \
`#86EC -> godziny,        /
`#86ED -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#86EE -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#86EF -> lata (#00 = 2000r)
`#86F0 -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`#86F1 -1b parzystość i kroczek analizy dogłębnej DCF
`#86F2 -1b l. bitów od ostatniego braku bitu o polaryzacji odwrotnej
`#86F3 -1b poprawka na polaryzację #00 gdy normalna (impulsy L na tle H) lub #FF gdy odwrócona
`#86F4 -1b bit7 =0 to dozwolona zmiana standardowa czasu, =1 to zabroniona,
`          bit6 =0 dziś nie było jeszcze zmiany czasu, =1 była już dziś zmiana czasu,
`#86F5 -1b poprawka przy przeskoku godziny #FF (-1h), #00 brak poprawki, #01 (+1h)
`-------------------
`#86F6 -1b czas TimeGuarda 5sek dla odczytu CID
`#86F7 -1b odczytany PB z 8255 125razy/sek
`bit0 IRQN \                            `
`   1 RXD  | CML602B                    `
`   2 DET  /                            `
`   3 syg.420Hz                         `
`   4 monitor 230V (własnego zasilania) `
`   5 -?                                `
`   6 LowVolt                           `
`   7 HighVolt                          `
`#86F8 -1b etap RingStatusTepsa:
`          #00 =stand-by normal
`          #01 =brak napięcia na linii telefonicznej
`          #02 =podniesiona słuchawka
`          #03 =uszkodzenie modułu alarmu
`          #04 =incomming ring
`          #05 =incomming dial
`          #06 =outgoing ring
`          #07 =outgoing dial
`          #08 =outgoing my connection
`#86F9 -2b (L=stany/H=czas) stan i czas bitów pomiaru napięcia na linii telef.
` #00-> Stand-by
` #40-> uszkodzenie/error
` #80-> podniesiona słuchawka
` #C0-> brak napięcia tel.
`#86FB -1b podetap odczytu CID 
`#86FC -1b autosuma FSK
`#86FD -1b liczba bajtów do odebrania całego CID
`#86FE -1b liczba bajtów do odebrania tej podtreści
`#86FF -2b adres do zapisu treści odebranych bajtów CID
`#8701 -&22 bajty długość + treść ASCII numeru dzwoniącego  (1+&21) też numeru wychodzącego T/P
`      w przypadku wychodzącego połączenia bity 7i6 (#8701) oznaczają odpow. ton/puls gdy =1
`         kompresowany następnie do #8891
`#8717 -&22 bajty długość + treść ASCII daty i czasu z TPSA (1+&21)
`  podczas dekodowania inf czasowej z CIDa używa następujących adresów tmp:
`    #8720 -sekundy (wpisuje tutaj #00, ale może lepiej &30?)
`    #8721 -minuty odczytane z CID       \
`    #8722 -godziny odczytane z CID       \w formacie moim
`    #8723 -dni miesiąca odczytane z CID  /
`    #8724 -miesiąc odczytany z CID      /
`    #8725 -rok wykoncypowany           
`    #8726 -dzień tygodnia obliczony z powyższego
`#872D -1b czas trwania braku napięcia w sekundach gdy =#00 to stoi
`#872E -1b wskaźnik(kroczek) interpretacji CID:
`     =#00 -przed odbiorem CIDa
`     =#01 -odebrano CIDa rozpoczynamy interpretację
`      ...
`     =#80 -już zinterpretowano CIDa i nadano zdarzenie do LOGu
`#872F -7b data i czas rozpoczęcia dzwonienia/rozmowy
`#8736 -2b czas w 1/125 sek trwania dzwonka/przerwy 
`         (#8736) =sam młodszy bajt też w okoliczności pierwszego dzwonka...
`#8738 -3b czas trwania dzwonka/rozmowy w sek/min/godz od 0 do &128 godzin potem nie idzie już
` #8738 -1b sekundy \
` #8739 -1b minuty  |
` #873A -1b godziny / od 0 do &127, gdy &128 (#80) tzn że przekroczył 127:59:59...
`#873B -1b sklasyfikowany czas poprzedniej przerwy
`#873C -1b 7bit =0 gdy aktualnie brak sygnału, =1 gdy jest sygnał 420Hz
`          6bit =1 gdy był 420Hz -> kasowane po wybraniu pierwszej cyfry nru tel. poł. wych.
`                 aby wiedzieć kiedy znów pojawi się 420Hz co oznacza koniec numeru
`                 i rozpoczęcie wybierania
`          5bit =0 gdy należy zapisać zdarzenie 'poł. wychodzące'
`               =1 gdy zapisano już takie zdarzenie
`#873D -1b sklasyfikowany czas bieżący
`#873E -1b bieżący pomiar czasu sygnału 420Hz w próbkach co 32[ms] (ok.31razy/sek)
`#873F -1b czas klasyfikacji finalnej (w próbkach co 32[ms])
`#8740 -1b kod zinterpretowanego sygnału 420Hz:
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły
`               ?   =#05 -UFO =niezidentyfikowany
`#8741 -2b adr. z którego przesłać RS232 z PC
`#8743 -1b ile bajtów do przesłania z PC
`#8744 -&161 (#A1) bajtów ASCII z których można zakodować treść SMSa wychodzącego
`#87E5 -1b liczba dni od daty abonamentowej 0..&255
`#87E6 -1b gdy = #00 (np. po RESET) to znaczy że nie było
`              <>#00 tzn że było zdarzenie typu nieznany error:
`                bit0 =1 -error polegający na wystąpieniu sprzętowego błędu przy detekcji
`                         poziomu napięcia na linii tel. stacjonarnego, 
`                         tzn. H pokazywał wyższe od wysokiego progu 
`                              a L pozkazywał niższe od niskiego (transoptory)
`                bit1 =1 -
`                bit2 =1 -
`                bit3 =1 -
`                bit3 =1 -
`                bit4 =1 -
`                bit5 =1 -
`                bit6 =1 -
`-------------------       
`#87E7 -1b bity ustawień detektora 230V
`         bit7 -=1 jest 230V, =0 brak 230V
`         bit6 - \
`         bit5 -  | nic
`         bit4 - /
`         bit3 -=1 było zdarzenie NIESTABILNE 230V
`         bit2 -=1 było zdarzenie ZASILANIE 230V
`         bit1 -=1 było zdarzenie BRAK 230V
`         bit0 -=1 było zdarzenie ZANIK 230V
`#87E8 -2b CT230 =czas trwania napięcia 230V 7bitH =1 to stoi
`#87EA -3b (godz/min/sek) CP230 =czas przerwy 230V bit7 w godzinie (#87EA) =1 to stop
`    #87EA -godz 0-127&  gdy bit7=1 to stoi 
`    #87EB -min  0-59&             
`    #87EC -sek  0-59&            
`#87ED -2b (godz/min) =zapamiętany sumaryczny czas przerw 230V
`    #87ED -godz 0-255&             
`    #87EE -min  0-59&            
`#87EF -1b licznik proponowanych informacji zanik? 230V -> powyżej pewnej wart. blok. wysyłanie
`#87F0 -2b adres tmp w tekście w buforze SMSa dla tworzenia opisu zdarzenia na LCD
`#87F2 -1b licznik odczytów konfigu z SIM, gdy jest jeden to zeruje książkę tel. w RAM
`#87F3 -2b pomocnicza zapamiętuje adres numeru tel dla interpretacji SMSa przychodzącego
`#87F5 -1b pomocnicza przechowuje liczbę określającą profil po zinterpretowaniu SMSa
`#87F6 -1b sekundowy stoper pomocniczy do wysyłania reklam
`#87F7 -2b sekundowy stoper od RESET idzie od #0000 do #FFFF potem stoi
`#87F9 -3b free
`#87FC -2b pomocniczy adres, gdzie kończy się opis tekstu dla LCD w buforze SMSa
`#87FE -3b stoperek sekundowy zerowania znacznika wystąpienia zdarzenia brąz alarm
` cyka co 1 sekundę gdy osiągnie zero to jest zerowany bit wystąpienia (i blokowania następnych)
` zdarzenia brąz alarmu /ten bit zerowany jest też po RESET/
`-------------------
`#8801 -1b wstępnie jak zaklasyfikowano zdarzenie z LOGu
`#8802 -1b wstępnie jak zareagowano na zdarzenie z LOGu
`#8803 -1b TimeGuard alarmowego wywoływania TPSA
`-------------------
`#8804 -2b -czas w sekundach gdy >#0000 blokady wysyłania info o braku napięcia TPSA (#0000 to stoi)
`                      cykany w dół co 1 sekundę [12h = 43200& [s] = #A8C0]
`-------------------
`#8806 -2b adr. small cykany w czasie Tx do PC,
`#8808 -1b ilość wysłanych bajtów cykana w górę po Tx/Rx każdego,
`#8809 -2b adr. big nadawanego obszaru MEMORY cykany po potwierdzonym Tx wiersza,
`#880B -2b długość big nadawanego obszaru MEMORY cykany po potwierdzonym Tx wiersza,
`#880D -2b adr. small nadawany w wierszu,
`#880F -1b długość small nadawana w wierszu,
`#8810 -2b TimeGuard oczekiwania na odbiór /pauzę przed nadaniem ACK/
`#8812 -1b autosuma XOR wiersza liczona dynamicznie,
`#8813 -1b KROK RS232 odbioru/nadawania wiersza,
`#8814 -1b Rx/Tx rozkaz,
`#8815 -1b Rx/Tx długość,
`#8816- #888F (#7A bajtów) Rx/Tx treść gdy odbierane/nadawane jest do/z bufora,
`#8890- 1b liczba wykonanych fauli kolejnych przy nadawaniu ramki z systemu
`-------------------
`#8891- &11 (#0B) bajtów numeru tel. stacjonarnego skompresowanego z #8701 in/out,
`       zarówno CID jak i tone/pulse
`   #8891- 1b liczba cyfr i tone/pulse,
`   #8892- #889B ->&10 do &20 cyfr skompresowanych 2 w jednym bajcie (jak w GSM), uzupełnione #F0
`                  i reszte zera...
`---
`#889C -1b numer odbiorcy ze znanych (#00-#09) a gdy >= #0A to nr odbiorcy w #889D
`        #889C ->       #00-#09 pozycja w znanych numerach
`                       #inny- podany ręcznie nr skompresowany
`        #889D -> 1b liczba cyfr numeru skompresowanego
`        #889E -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0
`#88A8 -1b MakeCall_TPSA
`        |7|6|5|4|3|2|1|0|
`         | | | | | | | |
`         | | | | | | | -> =0 zakończony przez system
`         | | | | | | |    =1 zakończony przed drugi
`         | | | | | | -> =0/1 pomocnicza
`         | | | | ---> =10 zlecenie wykonania połączenia
`         | | | |      =11 po error
`         | | | |      =01 po ring
`         | | | |      =00 po dial
`         | | | -> =0 nic
`         | | |    =1 autoredial gdy nie zakończona full sukcesem
`         | | -> czy używamy ISD1420 ? =0 nie (czas poł. =120[s])
`         | |                          =1 tak (czas poł. =32[s])
`         | -> czy aktywujemy bit REC: =0 nie
`         |                            =1 tak, z bitem REC
`         -> czy tylko cyna? =0 nie, normalne połączenie
`                            =1 tak, tylko cyna
`#88A9- &22b bufor numeru do wybrania w TPSA (gdy 7bit =1 i l.cyfr >#00)
` #88A9- 1b liczba cyfr (AND #7F -> #00 to pusty bufor),
` #88AA- 1b bieżąca cyfra do wybrania (#00-...)
` #88AB- &20b cyfry (mogą być też ASCII bo liczy się tylko prawa połówka bajtu)
`#88BF- 1b podetap/kroczek wybierania numeru TPSA
`#88C0- 2b TimeGuard wybierania połączenia wychodzącego...
`          najpierw oczekiwanie na ciągły 420Hz,
`          ...
`#88C2- 1b ilość fauli przy wybieraniu numeru (rośnie w górę)
`#88C3 -2b pom do rozkompresowania adr źródłowy skompresowanych
`#88C5 -2b pom do rozkompresowania adr wynikowy rozkompresowanych
`#88C8 -1b licznik sekundowy cykający w dół redialu, gdy dojdzie do zera to przy odpowiedniej
`          wartości uruchamia na nowo dzwonienie na stacjonarny
`---
`#88C9 -1b rozkaz jaki nadać z systemu do PC na RS232
`---
`#88CA -2b adres aktualnej siatki dla analizy zdarzeń (i zapisu do LOGu) lub ich olania
`#88CC -2b adres aktualnej siatki dla klasyfikacji INFORMACJI
`#88CE -2b adres aktualnej siatki dla klasyfikacji ALARMÓW
`---
`#88D0 -6b czas odczytany z DCF w naszym formacie, do porównania z kolejnym odczytanym
`          w celu akceptacji, kolejno min, godz, dnimca, mce, rok, dni-tyg
`          cykany przez zegar systemu raz na minutę (tylko minuty i godziny)
`#88D6 -4b licznik/zegar pędzący z szybkością co 4 NMI a więc do ok. >18 godzin
`          służący do określania czasu (w funkcji naszego kwarca) od ostatniego 
`          ustawienia z DCF77 (GPS) może do wykorzystania dla określania poprawki naszego zegara
`#88DA -4b przepisane z powyższego w momencie ustalania poprawki
`#88DE -1b wartość ułamka sekund zegara systemu odczytywana w momencie ustawienia zegara
`          z dokładnego źródła, dla ew. oceny poprawki zegara systemu
`#88DF -2b uł. sekund i sekundy w momencie ustawienia zegara systemu z DCF77
`#88E1 -1b kroczek do analizy, zerowany w momencie odebrania poprawki
`---
`#88E2 -1b sekundowy TimeGuard oczekiwania na delivery jakiegokolwiek SMSa po 
`          zleceniu wysłania SMSów alarmowych, idzie w dół gdy >0, potem stoi
`#88E3 -2b sekundy od ostatniego wykonania telefonu stacjonarnego
`          na alarmowy numer wraz z informacją foniczną z IDS1420 [1h = #0E10]
`---
`#88E5 -1b określający ile razy informacja o zdarzeniach została wyświetlona
`          od ostatniej zmiany/reklamy
`#88E6 -1b określający który z komunikatów jest właśnie wyświetlany na LCD #00..#02
`#88E7 -1b określający od którego znaku wyświetlamy ten komunikat na LCD
`#88E8 -1b określający który komunikat jest najmłodszy
`#88E9 -#A1 (&161) ASCIIZ komunikat nr #00 na LCD \ 
`#898A -#A1 (&161) ASCIIZ komunikat nr #01 na LCD | jeśli pusty to zaczyna się #00
`#8A2B -#A1 (&161) ASCIIZ komunikat nr #02 na LCD / 
`---
`#8ACC -2b sekundowy stoper czasowej blokady wysyłania SMSów tajnych/pajnych,
`        jeśli <>#0000 to nie wysyła pajnych i tajnych
`        po RESET gdy większy od 15minut to ustalany na 15 minut
`---
`#8ACE -&11b bufor rozpoznanego numeru telefonu nadanego w treści SMSa
`   #8ACE -1b liczba cyfr numeru
`   #8ACF..#8AD8 -&10b numeru dwa w jednym bajcie uzup #F0 i zera do końca /jak w SMSie/
` też #8ACF 2b pomocnicze do przechowania np. adresu w @FAN__
`---
`#8AD9 -1b kod rozkazu zinterpretowanego z SMSa przychodzącego
`#8ADA -1b bity zamienione z 8 liczba z SMSa przychodzącego
`#8ADB -1b liczba 1-2 cyfrowa z SMSa przychodzącego
`#8ADC -1b wartość 0..7 określająca TELEFONx
`#8ADD -free...
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`
`#8DD9 -4b całość stopera resms dla tajnego
` #8DD9 -7bit =0 -> można nadawać tajny
`             =1 -> czekaj jeszcze bo ostatnio nieudane nadanie tajnego
`        bity6..0 to KROK dla =0 idzie do 5 sekund  |
`                              1 idzie do 24 sekund |
`                              2 idzie do 5 minut   |potem stop
`                              3 idzie do 24 minut  |
`                              4 idzie do 5 godzin  |
`                     5 i więcej idzie do 24 godzin |
` #8DDA -sekundy #00..#3B
` #8DDB -minuty  #00..#3B
` #8DDC -godziny #00..#FF
`#8DDD -4b całość stopera resms dla paynego
` #8DDD -7bit =0 -> można nadawać payny
`             =1 -> czekaj jeszcze bo ostatnio nieudane nadanie paynego
`        bity6..0 to KROK dla =0 idzie do 5 sekund  |
`                              1 idzie do 24 sekund |
`                              2 idzie do 5 minut   |potem stop
`                              3 idzie do 24 minut  |
`                              4 idzie do 5 godzin  |
`                     5 i więcej idzie do 24 godzin |
` #8DDE -sekundy #00..#3B
` #8DDF -minuty  #00..#3B
` #8DE0 -godziny #00..#FF
`#8DE1 -6b ukryta data abonamentowa w postaci 3b+3b jak w #8554 tylko razy dwa
`#8DE7 -1b /ADRESY ZWIĄZANE z #8DF0../ autosuma #8DE8..#8DEF (ADD)
`#8DE8..#8DEF -8b liczniki REKLAM wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów reklamowych
`#8DF0 -1b /ADRESY ZWIĄZANE z #8DE8../ autosuma #8DF1..#8DF8 (ADD)
`#8DF1..#8DF8 -8b liczniki wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów o zdarzeniach i specjalnych
`              do celu wysyłania reklam na te numery
`#8DF9..#8DFF -kopia wiecznego zegara wraz z autosumą
`#8E00 -1b sek  \              
`#8E01 -1b min   \wieczny zegar
`#8E02 -1b godz  /             
`#8E03 -2b dni  /              
`#8E05 -2b suma (#8E00..#8E02) + (#8E03) + wartość #55AA
`#8E07 -1b free
`#8E08 - autosuma dla tej informacji poniżej, XOR do bajtu #00 daje #00
`#8E09 - #9F ASCIIZ zawierających informację reklamową ASCIIZ
`        z policzoną autosumą do pierwszego bajtu (#8E08), która wyświetlana jest na LCD
`        lub wysyłana SMSami
`#8EA8 -1b stała, minut przerwy 230V, po których generuje zdarzenie BRAK 230V zakres #01-#3B
`#8EA9 -2b stała, czas po którym po zanikach i brakach generujemy powrót zasilania 230V
`#8EAB -1b stała, liczba braków 230V po których generujemy NIESTABILNE 230V
`#8EAC -1b autosuma XOR konfiguracji 230V #8EA8-
`#8EAD -2b czas, powyżej którego kolejne otwarcie drzwi generuje nowe zdarzenie /np. #00C8 to 2min/
`#8EAF -2b czas, powyżej którego generujemy zdarzenie "dzwonek ciągły" /np. #003C to 1min/
`#8EB1 -2b czas, powyżej którego uznajemy kolejny dzwonek za nowy dzwonek /np. #003C to 1min/
`#8EB3 -2b czas, po którym otwarcie drzwi nie ma nic wspólnego z dzwonkiem /np. #000F to 15sek/
`#8EB5 -1b autosuma XOR konfiguracji dzwonka/drzwi #8EAD-
`#8EB6 -3b konfiguracja czasu blokowania next brąz alarmów, w postaci:
` #8EB6 -2b HA (High i veryHigh, Low przyjmujemy =0),
` #8EB8 -1b autosuma dająca w obszarze #8EB6-#8EB8 wynik #00
`#8EB9 -#3F bajtów 1b+ #3Eb () ASCIIZ zawierających informację typu: 
`           'Swinoujscie, ul. Grunwaldzka 66/27 IV pietro'#00 
`           z policzoną autosumą do pierwszego bajtu (#8EB9), która dołączana jest do 
`           wysyłanych SMSów informacyjnych i alarmowych a wpisywana z komputera lub SMS
`  generalnie ten opis może być w jednym z 4 stanów:
`                1) pusty (na polecenie z PC) gdy autosuma zgodna i opis zaczyna się od #00,
`                2) nieokreślony gdy autosuma niezgodna,
`                3) utworzony przez system w postaci tekstowej NET/LAC/CID
`                4) zapisany z PC w postaci tekstowej
`      przy: (tworzeniu konfigu) lub (RESET gdy jest 2)) robi -> 3)
`#8EF8 - 1b pomocnicza decydująca o wysłaniu SMSów reklamowych, delta do liczby losowo ustalona
`#8EF9 - 1b free liczba SMSów skradzionych dzisiaj
`#8EFA - 1b free dzień tygodnia w którym skradliśmy tyle SMSów,
`                przy innym dniu tygodnia zapisujemy nowy DT i zerujemy liczbę wysłanych 
`                skradzionych
`#8EFB - 1b sekundowy stoper interwału SMS taj/pay idzie w dół do #00 potem stoi
`#8EFC - 2b licznik 'absolutny' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
` ---------- komórki VRAM ----------------------------------
` vram NIE MOŻE BYĆ NA PRZEŁOMIE STARSZEGO BAJTU ADRESU!!!
`#8F00 -#8F2F ->#30(&48) bajtów obszaru VRAM
`     #8F00 -> pierwsza linijka &24bajtów
`     #8F18 -> druga linijka &24bajtów
`tego narazie nie przenosimy bo może w pszyszłości jakiś np. 40 znakowy LCD i co wtedy? -zonk!
` ---------- koniec komórek VRAM ---------------------------
`
`
`
`--------------------------------------------------------
`RAM LOG:                                      
`#8FF3- 1b -wskaźnik 'kierujący' sposobem świecenia LED_BLUE: #00->ciągle=źle, #05->zgaszona=OK
`#8FF4- 1b -wskaźnik procentowego zapełnienia LOGu #00 to 0%, #3F to 100% 
`           zapalony 7bit to PRE_OVER_LOG
`           zapalony 6bit to OVER_LOG
`           odczytując robimy AND #7F bo 7bit odrzucamy
`           z tego wskaźnika ustalana jest LEDka zapełnienia bufora
`#8FF5- 1b -TimeGuard oczekiwania na gotowość zdarzenia /cyka &250razy w sekundzie INC/
`#8FF6- 1b -free
`#8FF7- 2b -[DO ODCZYTANIA] adr. wykorzystywany tylko przez PC i ustawiany tylko przez PC,
`                ew. zerowany przez RESET gdy syf w logu
`#8FF9- 2b -adr. pierwszego bajtu za ostatnim zrealizowanym zdarzeniem
`                używany tylko przez CPU w czasie realizacji zdarzeń,
`                zerowany gdy RESET i syf, ew. przesuwany za zdarzenie po jego realizacji
`#8FFB- 2b -adr. pierwszego bajtu ZA ostatnim zapisem przed górną granicą logu 
`                zmieniany tylko gdy syf po RESET lub podbijany przez WOLNY
`#8FFD- 2b -[WOLNY] adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
`#8FFF- 1b -max. długość zdarzenia do zapisu przed górną krawędzią LOG RAMu lub #00
`#9000- pierwszy bajt logu
`         R A M   L O G  (26624 bajtów)
`#F7FF- ostatni bajt logu
`#F800- bajt za ostatnim LOG RAMu /też może być wykorzystywany przez zapis RAM LOGu/
`------------------------------------------------------------------------------------------
`pojedyncze zdarzenie w RAM LOGu wygląda tak:
`+#00 1b długość =#00 -> brak zdarzenia
`                >#00 -> długość zdarzenia w bajtach (max #FF)
`                          #03 - dla ALARMU       
`                          #02 - dla INFORMACJI   
`                          #01 - dla UZUPEŁNIENIA 
`+#01 1b kod zdarzenia z zakresu #01...#24 ?
`+#02 7b to data/czas i TimeStatus (kopia:)
`      +#02 -> sekundy,                                      \
`      +#03 -> minuty,                                        \
`      +#04 -> godziny,     [#00 - #17] +StatusTime [#00..#07] \
`      +#05 -> dni miesiąca [#00 - #1E] +DniTygodia [#00..#06]  \
`      +#06 -> miesiące     [#00 - #0B] +klasyfikacja            | czas rzeczywisty
`                       7bit=1 zdarzenie jeszcze nieskończone    /
`                  5i6bity =00 =uzupełnienie,                   /
`                  5i6bity =01 =informacja,                    /
`                  5i6bity =10 =alarm,                        /
`                  5i6bity =11 =?,                           /
`+#07 dane dodatkowe (lub ich brak)
`+#0x 1b długość zdarzenia w bajtach (to samo co w bajcie +#00)
`------------------------------------------------------------------------------------------
`old #8C00..#8C8B -obszar przesyłany jako SMS majstra
`#F801-#F88C -obszar przesyłany jako SMS majstra
`#F88D -?
`
`
`...#FFFF stos
`=======================================================================
`=============== KONIEC KOMÓREK RAM dużego =============================
`=======================================================================
`
DEFADR #0000                        `
LD SP,#FFFF                         `stos na końcu (62256) RAM`u 
SUB A                               `czyli #01 bo nieaktualne ASCIIdatyczasu
LD (#8000),A                        `zablokuj NMI,
`#5000,#5001 -8251 do mbus'a NOKIA   
LD BC,#5001                         `
` SUB A już jest zrobione patrz wyżej...
OUT (C),A                           `
OUT (C),A                           `
OUT (C),A                           `
LD A,#40                            `
` w słowie rozkazu 6 bit = 1 to RESET
OUT (C),A                           `
LD A,#4E                            `
` słowo trybu pracy dla asynchronicznej:
`       ---------------------------------
`       | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
`       ---------------------------------
`      bit7, bit6                    
`         0   1   --> 1 bit stopu    
`      bit5=0 --> kontrola nieparzystości
`      bit4=0 --> kontrola (nie)parzystości włączona /przy nadawaniu!/
`      bit3, bit2                    
`         1   1   --> 8 bitów        
`      bit1, bit0                    
`         1   0   --> podział TxC i RxC przez 16
OUT (C),A                           `
DEC C                               `
IN A,(C)                            `
IN A,(C)                            `
INC C                               `
LD A,#07                            `
`   słowo rozkazu ma bity o następującym znaczeniu:
`             bit    0 -TxEn =1 nadawanie dozwolone
`             bit   1  -DTR  =1 linia wyj.DTR w stanie niskim -aktywnym
`             bit  2   -RxEn =1 odbiór dozwolony
`             bit 3    -SBRK =0 linia TxD pracuje normalnie
`      bit    4        -ER   =0 wyzerowanie wskaźników PE, OE i FE w słowie stanu
`      bit   5         -RTS  =0 linia wyj.RTS w stanie niskim -aktywnym
`      bit  6          -IR   =0 nic  
`      bit 7           -EH   =0 nic  
OUT (C),A                           `
LD A,#FF                            `
LD (#81C9),A                        `czyli że nie ramka USERA
`inicjacja procedury reakcji na sygnały z PIO
LD (#80AB),A                        `nieaktywne sygnały wejściowe
LD (#80AC),A                        `nieaktywne sygnały wyjściowe
LD A,#0F                            `stop NOKIA-łopata, aby można było działać z MASTER NOKIA...
LD (#8028),A                        `
CALL @R_AcD                         `działa jako RESET 8255 od NOKIA i LCD
SUB A                               `\zeruj znacznik było zdarzenie: 'nieznany error'
LD (#87E6),A                        `/
JP @dalll                           `
`     tabela liczby dni w miesiącach (wartości pomniejszone o 1!)
` !!! ta tablica nie może być na przełomie !!!
DEFETYK @ldnim                       
DEFBAJT1 #1E #FF #1E #1D #1E #1D `bajt dni lutego [#FF nie jest wcale wykorzystywany]
DEFBAJT1 #1E #1E #1D #1E #1D #1E `i może tu być dowolna wartość!
`     tabela dwuliterowych nazw dni tygodnia
` nie na przełomie!!!                
DEFETYK @NaDnT                       
`DEFBAJT1 #50 #4E #57 #54 #53 #52 #43 #5A `PNWTSRCZ
`DEFBAJT1 #50 #54 #53 #4F #4E #49         `PTSONI
DEFBAJT1 #70 #6E #77 #74 #73 #72 #63 #7A `pnwtsrcz
DEFBAJT1 #70 #74 #73 #6F #6E #69         `ptsoni 
`------------------------------------
`                                      
` !!! ta tablica nie może być na przełomie !!!
DEFETYK @DT_MI `poprawki na DT w funkcji miesiąca
DEFBAJT1 #03 #03 #06 #01 #04 #06 #02 #05 #00 #03 #05 
`01 &31dni -> +3  -> +3                
`02 &28dni*->  0  -> +3 *              
`03 &31dni -> +3  -> +6                
`04 &30dni -> +2  -> +1 (+8)           
`05 &31dni -> +3  -> +4                
`06 &30dni -> +2  -> +6                
`07 &31dni -> +3  -> +2 (+9)           
`08 &31dni -> +3  -> +5                
`09 &30dni -> +2  ->  0 (+7)           
`10 &31dni -> +3  -> +3                
`11 &30dni -> +2  -> +5                
`za 12 nie ma sensu bo jest poprawka za cały rok = +3dni (nieprzestępny)
`                                     
DEFBAJT1 #FF #FF #FF #FF #FF `nic      
`---------------------------------- NMI
`w ciągu sekundy mamy 4.000.000 taktów,
`i 1000 razy jest wywoływane NMI,->4000 taktów w przerwaniu
`a więc dla procedury NMI jest około 4000-109(dla trzech CALL)-1=3890 taktów
`obierając zapas 10% daje to max 3501 taktów na wewnątrz wszystkich CALL
EX AF,AF^           `przerwanie NMI   
EXX                                  `
LD A,(#8000)                         `
BIT 7,A                              `czy włączone przerwania?
JR Z,@notNM                          `
CALL @nokia                          `trwa +1029tkt =17+max1012tkt
CALL @time+                          `trwa +2146tkt=17+max2129tkt
`CALL free_time                      ` do +17 +551tkt wewnątrz
EXX                           @notNM `
EX AF,AF^                            `
RETN                                 `
`======================================================================
DEFBAJT1 #21 #43 #65 #87 `#0079 adres 4b identyfikujących EPROM
`--------------------------------------
`wykonaj NOKIA (MASTER i łopata)
DEFETYK @tNOKI  `tabele adresów kroków dla:
DEFTABE RxRAM   `odbiór ramki 
DEFTABE RxACK   `odbiór ACK   
DEFTABE TxRAM   `nadawanie ramki
DEFTABE TxACK   `nadawanie ACK
`                                    
`poniższe czasy wynikowe to całkowite czasy trwania dla @nokia w przypadku
`wykonywania procedurki spod danego kroku,
`   jeśli uwzględnimy opcję wykonywania czegokolwiek po testowaniu i braku bajtu,
`   czasy w @RxRAM i @RxACK mogą ulec zmianie
`
DEFETYK @RxRAM  `odbiór ramki [trwa max 525tkt dla @Rrr_4]
DEFTABE Rrr_0   `501tkt=149+352 ustal time Guard i przejdź do odbioru #1F
DEFTABE Rrr_1   `455tkt=149+306 krok 1 odbierz i spr #1F
DEFTABE Rrr_2   `398tkt=149+249 krok 2 odbierz i spr odbiorcę (Z80)
DEFTABE Rrr_3   `427tkt=149+278 krok 3 odbierz i spr odbiorcę (NOKIA)
DEFTABE Rrr_4   `525tkt=149+376 krok 4 odbierz treść, sprawdź #01#08#00, długość <>0 i >3, Hdł=#00
DEFTABE Rrr_5   `348tkt=149+199 krok 5 odbierz ID NOKIA
DEFTABE Rrr_6   `373tkt=149+224 krok 6 odbierz i spr XOR przejdź do kroku 8
`                                
DEFETYK @RxACK  `odbiór ACK [trwa max 554tkt dla @Rar_4]
DEFTABE Rar_0   `513tkt=149+364 ustal time Guard i przejdź do odbioru #1F
DEFTABE Rrr_1   `455tkt=149+306 krok 1 odbierz i spr #1F
DEFTABE Rrr_2   `398tkt=149+249 krok 2 odbierz i spr odbiorcę (Z80)
DEFTABE Rrr_3   `427tkt=149+278 krok 3 odbierz i spr odbiorcę (NOKIA)
DEFTABE Rar_4   `558tkt=149+409 krok 4 odbierz i spr #7F
DEFTABE Rar_5   `427tkt=149+278 krok 5 odbierz i spr ID Z80
DEFTABE Rar_6   `373tkt=149+224 krok 6 odbierz i spr XOR przejdź do kroku 8
`                                 
` w czasie odbierania bajtów (czekania na bajty), ACK i RAMA w sytuacji gdy nie odebrano bajtu,
` marnuje się sporo czasu.
` wyjście z procedur przy @ifTim przez RET NZ następuje po wykorzystaniu od początku wywołania
` @nokia, następującej liczby taktów:
`       @Rrr_0 149+211=
`       @Rrr_1 149+211=
`       @Rrr_2 149+167=
`       @Rrr_3 149+179=
`       @Rrr_4 149+180=
`       @Rrr_5 149+138=
`       @Rrr_6 149+138=
`       @Rar_0 149+211=360tkt, 1000-360=640tkt free do wykorzystania!
`       @Rar_4 149+138=
`       @Rar_5 149+177=
`       @Rar_6 149+138=
` aby wykorzystać te wolne takty trzeba zamiast RET NZ wstawić JR NZ,@wykorzystywanie...
` no i odpowiednio zmodyfikować czasy @RxRAM i @RxACK
`
DEFETYK @TxRAM  `nadawanie ramki [max 576tkt dla @Ttr_0]
DEFTABE Ttr_0   `576tkt=149+431 krok 0 odtwórz adres dynamiczny, ustaw TimeGuarda i nadaj #1F
DEFTABE Tar_1   `408tkt=149+263 krok 1 nadaj #1F /nie zawsze wchodzi do trgo kroku, chyba nigdy/
DEFTABE Tar_2   `396tkt=149+251 krok 2 nadaj odbiorcę (NOKIA)
DEFTABE Tar_3   `396tkt=149+251 krok 3 nadaj nadawcę (Z80)
DEFTABE Ttr_4   `485tkt=149+340 krok 4 nadaj treść (#801F) bajtów z adresu (#801D)
DEFTABE Ttr_5   `396tkt=149+251 krok 5 nadaj ID Z80
DEFTABE Ttr_6   `349tkt=149+204 krok 6 nadaj XOR i zatrzymaj 
`                                
DEFETYK @TxACK  `kroki dla nadania ACK [max 467tkt dla @Tar_0]
DEFTABE Tar_0   `467tkt=149+322 krok 0 ustaw TimeGuarda i nadaj #1F
DEFTABE Tar_1   `408tkt=149+263 krok 1 nadaj #1F
DEFTABE Tar_2   `396tkt=149+251 krok 2 nadaj odbiorcę (NOKIA)
DEFTABE Tar_3   `396tkt=149+251 krok 3 nadaj nadawcę (Z80)
DEFTABE Tar_4   `388tkt=149+245 krok 4 nadaj ACK (#7F)
DEFTABE Tar_5   `396tkt=149+251 krok 5 nadaj ID odebranej NOKIA
DEFTABE Tar_6   `396tkt=149+251 krok 6 nadaj XOR i zatrzymaj
`                               
` w czasie nadawania bajtów, ACK i RAMA w sytuacji gdy nie nadano bajtu /raz na 8 bajtów/,
` marnuje się trochę czasu.
` wyjście z procedur przy @TO?Tx przez RET NZ następuje po wykorzystaniu od początku wywołania
` @nokia, następującej liczby taktów:
`       @Tar_0 149+245=
`       @Ttr_0 149+354=503tkt, 1000-503=497tkt free do wykorzystania!
`       @Tar_1 149+177=
`       @Tar_2 149+175=
`       @Tar_3 149+175=
`       @Tar_4 149+175=
`       @Ttr_4 149+173=
`       @Tar_5 149+175=
`       @Ttr_5 149+175=
`       @Tar_6 149+163=
`       @Ttr_6 149+163=
` aby wykorzystać te wolne takty trzeba zamiast RET NZ wstawić JR NZ,@wykorzystywanie...
` no i odpowiednio zmodyfikować czasy @TxRAM i @TxACK
`
`============================ kroki MASTER NOKIA =============================
DEFETYK @MNkro  `kroki MASTER NOKIA
` Algorytm RESET
DEFTABE MN_00   `176tkt=112+64 adres dla kroku 0 MASTER NOKIA Totoal ZEROWANIE,
DEFTABE MN_01   `419tkt=112+297 adres dla kroku 1 MASTER NOKIA RESET ale bez zerowania kom. USERA,
`              MN_01 przedłużony o kilka instrukcji
DEFTABE MN_02   `228tkt=112+116 adres dla kroku 2 MASTER NOKIA odbiór ramki ...i tak nic nie odbiera
DEFTABE MN_03   `256tkt=112+144 adres dla kroku 3 MASTER NOKIA nadawanie ramki rejestracyjnej
DEFTABE MN_04   `204tkt=112+92 adres dla kroku 4 MASTER NOKIA odbiór ramki rejestracyjnej
DEFTABE MN_05   `329tkt=112+217 adres dla kroku 5 MASTER NOKIA spr czy oki, jeśli tak to dalej, 
` Algorytm NORMAL
DEFTABE MN_06   `1008tkt=112+896 adres dla kroku 6 MASTER NOKIA szykuj ramkę do nadania i nadaj
DEFTABE MN_07   `204tkt=112+92 adres dla kroku 7 MASTER NOKIA odbierz ACK
DEFTABE MN_08   `381tkt=112+269++ adres dla kroku 8 MASTER NOKIA odbierz ramkę
DEFTABE MN_09   `236tkt=112+124 adres dla kroku 9 MASTER NOKIA szykuj się do analizy
DEFTABE MN_0A   `@InOuA+159tkt=112+47* adres dla kroku 10 MASTER NOKIA analizuj a potem nadaj ACK
DEFTABE MN_0B   `204tkt=112+92 adres dla kroku 11 MASTER NOKIA ustaw pauzę 
DEFTABE MN_0C   `252tkt=112+140 adres dla kroku 12 MASTER NOKIA czekaj i od początku...
`
`jeśli przerwanie z częstotliwością 1kHz (bo dla 9600bodów tak trzeba)
`to przy zegarze 4MHz przerwania występują co 4000 taktów,
`zostawiając 10% mamy max. 3600 taktów na jedno przerwanie
`
`sposób odczytu ACK:
`1.zapis do #8028 wartości #10 
`2.oczekiwanie aż #8028 przyjmie jedną z wartości:
`  #18 -> ok, odczytano ACK z ID Z80,
`  #08 -> ok, odczytano ramkę do #80C6...
`  #0F -> error timeover,
`
`sposób odczytu ramki:
`1.zapis do #8028 wartości #00
`  treść jest odczytywana pod adres #80C6 - #81C3
`      #80C6 -> & bajtów bufora odebranego komunikatu z NOKIA
`         --------------------------------------struktura:
`         #80C6 ->  \
`         #80C7 ->  /rozkaz 2b 
`         #80C8 ->  długość 1b 
`   #80C9-#81C3 ->  treść o długości jak wyżej (max. &255 #FF)
`
`2.oczekiwanie aż #8028 przyjmie jedną z wartości:
`  #08 -> ok, odczytano ramkę do #80C6
`  #18 -> ok, odczytano ACK z ID Z80,
`  #0F -> error timeover,
`
`sposób nadania ACK:
`1.zapis do #8028 wartości #30
`2.oczekiwanie aż #8028 przyjmie jedną z wartości:
`  #38 -> ok,
`  #0F -> error timeover,
`
`sposób nadania treści: 
`/sposób A:  LD (#8029),#01 -to numer ramki, a gdy to =#00 to nadajemy USERA, wtedy mamy...
` sposób B: kom. USERA: LD (#8029),#00 i w bajtach #81C8-#82C9 przygotowany stosowny komunikat/
`1.zapis do #8028 wartości #20
`2.oczekiwanie aż #8028 przyjmie jedną z wartości:
`  #28 -> ok,
`  #0F -> error (timeover),
`
` ID_Z80 jest zwiększany: -po odebraniu ACK z NOKIA -automatycznie przez Slave
`                         -po X nieudanych próbach nadania przez Manager
` ID_NOKIA jest po prostu odbierany przy odczycie ramki, procedura nie zajmuje się
`          sprawdzaniem jego poprawności
`
`formuła ramki:
`---------------------------------------------------------------------@-
`|#1F|odb|nad|roz|Hdlug|Ldług|  <--treść w liczbie HLdług-->  | ID | XOR |
`----------------------------------------------------------------------
`formuła ACK:
`-----------------------------------------
`|#1F|odb|nad|#7F| IDpotwierdzanej | XOR |
`-----------------------------------------
`all NOKIA obsługa -zakładamy że nie może w sumie przekroczyć 1000tkt
`trwa dla bit3=1 (MASTER) 116tkt + to co po skoku w MASTER,
`              0 (SLAVE)  149tkt + to co po skoku  w SLAVE 
`  oczywiście część dokonuje się także w @time (odliczanie time keya)
`max dla @MN_06   ->`1012tkt=116+896
LD DE,#8028            @nokia `szybciej i taniej!
LD A,(DE)                     `wykonaj allNOKIA -> SLAVE i MASTERA i...
LD B,A                        `
BIT 3,A                       `zatrzymuje łopatę NOKIA bo to krok 8 lub wyższy...
JR Z,@SlaNo                   `przechodzi do łopaty NOKIA 
LD A,(#802B)                  `czyli kroki dla MASTERA
CP #0D                        `zabezpieczenie -zakres kroków tylko #00-#0C
LD HL,@MNkro                  `kroki MASTER NOKIA
JR C,@JPtab                   `+12+38tkt czyli dodaj do HL wektor 2*Acc 
`                                       i skocz do adresu tym adresowanego ;o)
LD A,#01                      `jeśli jest tutaj to musiał być jakiś error
LD (#802B),A                  `tak więc RESETuj bez zerowania komunikatu USERa
RET                           `
`  #8028 -> 1b krok odbioru ACK, krok odbioru komunikatu z NOKIA
`      bity: 7,6- niewykorzystane
`       ------------
`           5,4=0 -> procedura odbioru treści
`              =1 -> procedura odbioru ACK
`              =2 -> procedura nadawania treści
`              =3 -> procedura nadawania ACK
`       ------------
` bit 3=1 to blokada łopaty, wtedy tylko jest wykonywany MASTER i InOutAnalizy
` krok jest również znacznikiem wykonania, MASTER jest wykonywany tylko gdy bit3=1
RRCA                  @SlaNo `
RRCA                         `
RRCA                         `po tym bity 6,5,4 to 3,2,1
AND #06                      `zostają bity 2,1 
`                             /w jeśli bit6 będzie używany to w przyszłości AND #0E /
LD HL,@tNOKI                 `tabela tabel procedur wykonawczych łopaty
ADD A,L                      `
LD L,A                       `
LD A,(HL)                    `pobierz adres tabeli tej procedury z tabeli tabel procedur
INC L                        `oczywiście gdy nie jest na przełomie H z HL!
LD H,(HL)                    `
LD L,A                       `adres tabeli w HL
LD A,B                       `
AND #07                      `połówka -> numer kroku
ADD A,A               @JPtab `+38tkt+to co po JP...
ADD A,L                      `tutaj masz HL, dodaj do niego wektor(A) i skocz do tego adresu
LD L,A                       `
LD A,(HL)                    `pobierz adres z tabeli
INC L                        `oczywiście gdy nie jest na przełomie H z HL!
LD H,(HL)                    `
LD L,A                       `
JP (HL)                      `wykonaj procedurę z pod tego adresu
`==========================================================================
`
`wyślij bajt Acc jeśli to możliwe
`0stos, zmienia: FBCE
`wyjście:
`   CY & Z  -> nadano                   (trwa 136 tkt)
`   NC & NZ -> nie nadano bo full bufor (trwa 111 tkt)
`   NC & Z  -> time over                (trwa  43 tkt) 
LD E,A             @TxNOK `
LD BC,(#8026)             `
LD A,B                    `
OR C                      `zeruje CY
RET Z                     `43tkt NC & Z
DEC BC                    `
LD (#8026),BC             `
LD BC,#5001               `-8251 do mbus'a
IN A,(C)                  `
`                          bit0 -TxRdy =1 to nadajnik gotowy do przyjęcia słowa danych
CPL                       `odwrócenie bitów  =0
AND #01                   `Z (po odwróceniu) to gotowy na przyjęcie słowa danych
LD A,E                    `
RET NZ                    `111tkt NC & NZ
DEC C                     `po tym C=#00 i ustawiona flaga Z
OUT (C),A                 `#5000 nie zmienia rej. F
SCF                       `CY
RET                       `136tkt CY & Z
`---------------------------
`
`czytaj bajt -sprawdza czy jest w 8251 odebrany bajt,
`1stosu, zmienia AFBCE
`wyjście:
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
LD BC,#5001        @RxNOK `-8251 do mbus'a
IN A,(C)                  `
CPL                       `
AND #02                   `
`       bit1 -RxRdy    - =1 to w buforze odbiornika czeka bajt
JR NZ,@_RxNO              `hop -> brak bajtu 103tkt
DEC C                     `
IN E,(C)                  `to odebrany bajt,
INC C                     `
IN A,(C)                  `odczyt słowa stanu,
AND #38                   `
`     bit   3 -PE - =1 to błąd parzystości
`     bit  4  -OE - =1 to błąd straty bajtu
`     bit 5   -FE - =1 to błąd formatu,
SCF                       `
RET Z                     `CY & Z -> oki 94 tkt
PUSH AF                   `
LD A,#37                  `
`   słowo rozkazu ma bity o następującym znaczeniu:
`             bit    0 -TxEn =1 nadawanie dozwolone
`             bit   1  -DTR  =1 linia wyj.DTR w stanie niskim -aktywnym
`             bit  2   -RxEn =1 odbiór dozwolony
`             bit 3    -SBRK =0 linia TxD pracuje normalnie
`      bit    4        -ER   =1 wyzerowanie wskaźników PE, OE i FE w słowie stanu
`      bit   5         -RTS  =1 linia wyj.RTS w stanie niskim -aktywnym
`      bit  6          -IR   =0 nic
`      bit 7           -EH   =0 nic
OUT (C),A                     `flaga CY zerowana przez OR, flaga Z zależna od OR
`                              OUT nie zmienia Z i C
`zakładamy że nie jest potrzebne gaszenie bitu erroru...
POP AF
RET                       `C & NZ -> error 128 tkt
LD BC,(#8026)      @_RxNO `tutaj gdy brak bajtu
LD A,B                    `
OR C                      `-> NC
RET Z                     `NC, Z  timeover 84 tkt
DEC BC                    `nie zmienia rej.F
LD (#8026),BC             `
RET                       `NC & NZ -> brak bajtu 115 tkt
`------------------------------------------------------------------------------
`przykładowy obszar pamięci stanowiący ramkę dla procedury łopaty NOKIA nadawania ramki:
`adres+#00 \Lrozkaz /oczywiście różny od #7F bo to ACK ;o) /
`     +#01 Hdługość [=#00!]
`     +#02 Ldługość
`     +#03 ...treść o długości = wartości komórki(+#02)
`
`tabela @TRuRa nie może być na przełomie!!!
DEFETYK @TRuRa  `tabela adresów rutynowych ramek
`wiadomo że jak jest numer ramki #00 to jest to ramka nierutynowa...
DEFTABE RR_1_   `adres ramki 1 -rejestracyjnej
DEFTABE RR_2_   `adres rutynowej ramki 2 -poziom GSM
DEFTABE RR_3_   `adres ramki 3 -IMEI
DEFTABE RR_4_   `adres rutynowej ramki 4 -numer wersji
DEFTABE RR_5_   `adres ramki 5 -odczytaj czas z NOKIA
DEFTABE RR_6_   `adres ramki 6 -żądanie lokalizacji i sieci
`te z gwiazdką wymagają modyfikacji a więc nie są wysyłane jako rutynki i nie muszą być
`w tej tablicy
`DEFTABE RR_7*   `żądanie pozycji z książki numerów na SIM
`DEFTABE RR_8*   `żądanie odczytu SMSa z SIM
`DEFTABE RR_A*   `żądanie skasowania SMSa z SIM
`DEFTABE RR_C*   `zapis czasu i daty do NOKIA
`DEFTABE RR_D*   `zapis alarmu do NOKIA
`
`poniżej ramka 1 -rejestracyjna
DEFETYK @RR_1_
`        #1F #00 #1D 
DEFBAJT1 #D0 #00 #01 #04
`i na koniec numerID i XOR
`
`poniżej rutynowa ramka 2 -poziom GSM
DEFETYK @RR_2_
`        #1F #00 #1D 
DEFBAJT1 #04 #00 #04
DEFBAJT1 #00 #01 #00 #01 
```````````DEFBAJT1 #40 #00 #04
```````````DEFBAJT1 #00 #01 #6E #01 `tmp pytanie o kod zabezpieczający telefonu
```````````domyślnie jest chyba '12345'
`
`i na koniec numerID i XOR
`
`poniżej ramka 3 -numer IMEI
DEFETYK @RR_3_
`        #1F #00 #1D 
DEFBAJT1 #04 #00 #04
DEFBAJT1 #00 #01 #00 #03 
`i na koniec numerID i XOR
`
`poniżej ramka 4 -numer wersji
DEFETYK @RR_4_
`        #1F #00 #1D 
DEFBAJT1 #D1 #00 #05
DEFBAJT1 #00 #01 #00 #03 #00 
`i na koniec numerID i XOR
`
`poniżej ramka 5 -odczytaj czas z NOKIA
DEFETYK @RR_5_
`        #1F #00 #1D 
DEFBAJT1 #11 #00 #04
DEFBAJT1 #00 #01 #00 #62 
`i na koniec numerID i XOR
`
`poniżej ramka 6 -żądanie lokalizacji i sieci
DEFETYK @RR_6_
`        #1F #00 #1D 
DEFBAJT1 #0A #00 #05
DEFBAJT1 #00 #01 #00 #70 #01 
`i na koniec numerID i XOR
`
`poniżej ramka 7 -żądanie pozycji z książki numerów na SIM
DEFETYK @RR_7*
`        #1F #00 #1D 
DEFBAJT1 #03 #00 #07
DEFBAJT1 #00 #01 #00 #01 #03 #FF #00 `gdzie bajt #FF to pozycja żądana
`i na koniec numerID i XOR
`
`poniżej ramka 8 -żądanie odczytu SMSa z SIM
DEFETYK @RR_8*
`        #1F #00 #1D 
DEFBAJT1 #14 #00 #0A
DEFBAJT1 #00 #01 #00 #07 #02 #FF #01 #64 #01 #43 `gdzie bajt #FF to pozycja żądanego SMSa
`i na koniec numerID i XOR
`
`poniżej ramka A -żądanie skasowania SMSa z SIM
DEFETYK @RR_A*
`        #1F #00 #1D 
DEFBAJT1 #02 #00 #07
DEFBAJT1 #00 #01 #00 #0A #02 #FF #01 `gdzie bajt #FF to pozycja SMSa
`i na koniec numerID i XOR
`
`poniżej ramka C -zapis czasu i daty do NOKIA
DEFETYK @RR_C*
`        #1F #00 #1D 
DEFBAJT1 #11 #00 #0D
DEFBAJT1 #00 #01 #00 #60 #01 #01 #07 #07 `#FF #FF #FF #FF #FF `rok/m-c/dz/godz/min
`i na koniec numerID i XOR
`
`poniżej ramka D -zapis alarmu do NOKIA
DEFETYK @RR_D*
`        #1F #00 #1D 
DEFBAJT1 #11 #00 #0D
DEFBAJT1 #00 #01 #00 #6B #01 #20 #03 #01 #FF #05 #00 #01 #40` gdzie #FF #05 to godzina i minuta
`i na koniec numerID i XOR
`
`poniżej ramka Ea -wybieranie połaczenia fonicznego
`DEFETYK @RR_Ea
`        #1F #00 #1D 
`DEFBAJT1 #01 #00 #FF
`DEFBAJT1 #00 #01 #00 #01 
`DEFETYK @RR_Eb
`DEFBAJT1 #05 #01 #01 #05 #81 #01 #00 #00 #01 #01 #41`
`i na koniec numerID i XOR
`-----------------------
`
LD HL,#0008          @Tar_0  `+322tkt `ustaw TimeGuarda dla nadawania ACK
JR @StTGu                    `
LD A,(#8029)         @Ttr_0  `+431tkt `krok 0 -> ustaw dynamiczne adr i dł dla danej Tramki
AND A                        `czy to ramka inna niż rutynowa? (Z = tak)
JR NZ,@_TRUs                 `hop -> ramka rutynkowa
LD HL,#81C8                  `ramka nierutynowa Usera
JR @_UsDy                    `
LD HL,@TRuRa         @_TRUs  `adres tabeli adresów rutynowych ramek
DEC A                        `bo dla Acc=1 ma być pierwszy adres z tabeli...
ADD A,A                      `
ADD A,L                      `
LD L,A                       `oblicz adres komórki w tabeli dla bieżącej ramki
LD A,(HL)                    `odczytaj do HL adres z tabeli
INC L                        `
LD H,(HL)                    `
LD L,A                       `
LD (#801D),HL        @_UsDy  `obliczony(ustalony) adres zapisz w dynamicznym
INC L                        `
INC L                        `teraz to adres długości
LD A,(HL)                    `
LD (#801F),A                 `zapisz w dynamicznym liczniku długości
LD HL,#0116                  `czas Time Guarda dla maksymalnej ramki o dł. =&255+1
LD (#8026),HL        @StTGu  `300tkt  `zapisz Time Guarda
LD HL,#8028                  `
INC (HL)                     `tu robi przejście do kroku 1
SUB A                @Tar_1  `trwa: +263tkt
LD (#8021),A                 `zeruj parzystość XOR
LD (#802A),A                 `zeruj kroczek
LD A,#1F                     `-> bajt startowy #1F
CALL @TxNOK          @nadaj  `226tkt gdy wysłano i 151tkt gdy nie wysłano i 118 gdy error
`   CY & Z  -> nadano     (trwa 136 tkt)
`   NC & NZ -> nie nadano (trwa 111 tkt)
`   NC & Z  -> time over  (trwa  43 tkt) 
JR NC,@TO?Tx                 `hop gdy NIE wysłano
LD B,A                       `66tkt  `zachowaj wysłany bajt w Brej
LD A,(#8021)                 `
XOR B                        `dolicz parzystość
LD (#8021),A                 `
LD HL,#8028                  `->inc(krok)
INC (HL)                     `
RET                          `
RET NZ              @TO?Tx   `stąd może wykonywać coś innego w czasie zarezerwowanym dla @nokia
`                             od @TO?Tx minęło +10tkt (bo JP)
`                             od @nadaj minęło +133tkt
`                             
`                             46tkt  `nie wysłano, czy timeover?
`   NC & NZ -> nie nadano (trwa 11 tkt) RET
`   NC & Z  -> time over  (trwa 46 tkt) hop gdy TimeError
JP @tXerr
LD A,(#8024)        @Tar_2   `+251tkt  `krok 1 -> bajt odbiorcy NOKIA
JR @nadaj                    `
LD A,(#8025)        @Tar_3   `+251tkt  `krok 2 -> bajt nadawcy Z80
JR @nadaj                    `
LD A,#7F            @Tar_4   `+245tkt  `krok 3  -> bajt ACK
JR @nadaj                    `
LD HL,(#801D)       @Ttr_4   `+340tkt  `krok 3-> wyślij poleconą zawartość 
LD A,(HL)                    `odczytaj bajt
CALL @TxNOK                  `nadaj go
`   CY & Z  -> nadano     (trwa 136 tkt)
`   NC & NZ -> nie nadano (trwa 111 tkt)
`   NC & Z  -> time over  (trwa 43 tkt) 
JR NC,@TO?Tx                 `gdy nie udało się nadać to sprawdź czy nie Time Over
LD B,A                       `
LD A,(#8021)                 `
XOR B                        `dolicz parzystość
LD (#8021),A                 `
INC HL                       `
LD (#801D),HL                `zwiększ adres next bajtu do nadania
LD A,(#802A)                 `kroczek
CP #03                       `
JR C,@if<3_                  `hop jeśli kroczek <3 tzn. gdy nadajesz bajty rozkazu/długości
LD A,(#801F)                 `
DEC A                        `zmniejsz liczbę bajtów do nadania
LD (#801F),A                 `
JR Z,@nexKR                  `inc(KROK)
RET                          `jeszcze są bajty do nadania
INC A                @if<3_  `28tkt tu tylko liczysz w kroczku bo nadałeś b.rozk/dł
LD (#802A),A                 `
RET                          `
LD A,(#8023)         @Ttr_5  `+251tkt  `krok 4 -> bajt ID Z80
JR @nadaj                    `
LD A,(#8022)         @Tar_5  `+251tkt  `krok 4 -> bajt ID odebranej od NOKIA
JR @nadaj                    `
LD A,(#8021)         @Tar_6  `+251tkt  `krok 5 -> bajt XOR
CALL @TxNOK                  `nadaj bajt
`   CY & Z  -> nadano     (trwa 136 tkt)
`   NC & NZ -> nie nadano (trwa 111 tkt)
`   NC & Z  -> time over  (trwa 43 tkt) 
JR NC,@TO?Tx                 `nie nadano -> sprawdź time
LD A,#38                     `STOP ->nadano ACK
LD (#8028),A                 `
RET                          `
LD A,(#8021)         @Ttr_6  `+204tkt  `krok 5 -> bajt XOR
CALL @TxNOK                  `nadaj bajt
`   CY & Z  -> nadano     (trwa 136 tkt)
`   NC & NZ -> nie nadano (trwa 111 tkt)
`   NC & Z  -> time over  (trwa 43 tkt) 
JR NC,@TO?Tx                 `nie nadano -> sprawdź time
LD A,#28                     `STOP ->nadano ramkę
LD (#8028),A                 `
RET                          `
`-------------------
LD HL,#0100          @Rar_0  `365tkt TimeGuard dla odbioru ACK
LD A,#11                     `krok=1 odbiór ACK
JR @LEUDS                    `
LD HL,#0400          @Rrr_0  `352tkt TimeGuard dla odbioru ramki
LD A,#01                     `
LD (DE),A            @LEUDS  `krok=1 odbiór ramki
LD (#8026),HL                `zapisz TimeGuard
SUB A                @Rrr_1  `306tkt
LD (#8021),A                 `zeruj XOR
LD (#802A),A                 `kroczek zeruj
LD HL,#80C9                  `adres pod który ładowana jest treść,
LD (#801D),HL                `dynamiczny od początku
CALL @RxNOK                  `odbierz bajt (ignoruj error straty bajtu)
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JR NC,@ifTim
JR Z,@_RrR1                  `tu bezbłędnie odebrany bajt,
AND #28                      `ignoruj błąd straty bajtu,
RET NZ                       `to error ramki lub parity -> czekaj dalej na #1F w kroku 1
LD A,E               @_RrR1  `+78tkt
CP #1F                       `czy to pierwszy #1F?
RET NZ                       `RET bo to inny bajt niż oczekiwany #1F...
LD A,(#8021)         @AsWnt  `+62tkt `tutaj mamy taki bajt, jakiego oczekiwaliśmy -add parity
XOR E                        `
LD (#8021),A                 `
LD HL,#8028          @nexKR  `+32tkt ->inc(krok)
INC (HL)                     `
RET                          `
LD A,(#8025)         @Rrr_2  `249tkt `krok 2 odbierz i spr odbiorcę (Z80)
LD D,A                       `
CALL @RxNOK          @odbie  `232tkt
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JR C,@mamRx                  `
JP NZ,@freTi         @ifTim  `NZ->11tkt, Z->36tkt `RET = brak bajtu /tak było dla RET NZ/
`                             dla [@freTi] będzie nieco inaczej
LD A,#0F             @tXerr  `31tkt `error timeover
LD (#8028),A                 `
RET                          `
LD A,E               @mamRx  `+109tkt `odebrano bajt
JR NZ,@kro=1                 `to error straty, ramki lub parity -> zacznij od początku
CP D                         `bajt odebrany poprawnie,
JR Z,@AsWnt                  `hop -> odebrano taki bajt jakiego oczekiwano
CP #1F               @if#1F  `+87tkt `inny bajt -> może to początek nowego?
JR Z,@#1F..                  `to chyba pierwszy bajt [#1F]
LD A,(#8028)         @kro=1  `+51tkt
AND #F0                      `
OR #01                       `ustal krok #01 czyli oczekuj na #1F...
LD (#8028),A                 `
RET                          `
LD A,(#8028)         @#1F..  `+68tkt
AND #F0                      `1 krok tej proc bo odebrano chyba pierwszy bajt [#1F]
OR #02                       `krok drugi to po odebraniu #1F...
LD (#8028),A                 `tu ustawiamy następny krok: 2-gi
LD A,E                       `
LD (#8021),A                 `zeruj XOR na bajt #1F
RET                          `
LD A,(#8024)         @Rrr_3  `+278tkt `krok 3 odbierz i spr nadawcę (NOKIA)
LD D,A                       `
JR @odbie                    `
LD A,(#802A)         @Rrr_4  `+376tkt `krok 4 odbierz treść 
CP #03                       `
JR NC,@RnTre                 `hop to już senso stricte treść
LD HL,#80C6                  `adres Lrozkazu
ADD A,L                      `
LD L,A                       `
CALL @RxNOK                  `
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JP NC,@ifTim                 `
JR NZ,@kro=1                 `error straty, ramki lub parity
LD (HL),E            @_rr_4  `+195tkt `zapamiętaj bajt:
`                                 w #80C6 rozkaz
`                                 w #80C7 Hdługości (to ma być =#00 !!!)
`                                 w #80C8 Ldługości
LD A,(#8021)                 `dolicz do XOR
XOR E                        `
LD (#8021),A                 `
LD HL,#802A                  `zwiększ kroczek treści
INC (HL)                     `
LD A,(HL)                    `
CP #03                       `zostań, jeśli 3 kroczek, bo trzeba przygotow. odbiór bajtów
JR Z,@kr3cz                  `hop bo 3 kroczek, czyli przygotuj all
CP #01                       `+59tkt
RET NZ                       `wyjdź -> kroczek 2
LD A,#7F                     `tutaj kroczek 1 więc sprawdź czy to nie przypadkiem bajt #7F(ACK)
CP E                         `
RET NZ                       `
LD A,#15                     `odbiór ACK i krok 5
LD (#8028),A                 `ustaw odbiór ACK i krok 5
RET                          `
LD A,(#80C8)          @kr3cz `122tkt `długość treści w bajtach
LD (#801F),A                 `zapisz w wart. dynamicznie zmniejszanej
AND A                        `
JR Z,@kro=1                  `wartość długości musi być różna od zera!
LD A,(#80C7)                 `Hdługość
AND A                        `
RET Z                        `=#00 to prawidłowo
JR @kro=1                    `hop bo starszy bajt długości różny od zera ->zacznij od nowa
CALL @RxNOK           @RnTre `a tutaj odbieramy treść...
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JR NC,@ifTim                 `
JR NZ,@kro=1                 `error straty, ramki lub parityLD HL,(#801D)             
LD HL,(#801D)                `
LD (HL),E                    `zapisz bajt
INC HL                       `
LD (#801D),HL                `zwiększ adres na next bajt
LD A,(#8021)                 `dolicz parzystość
XOR E                        `
LD (#8021),A                 `
LD HL,(#8026)                `dodaj jedną jednostkę czasu, wszak odebrałeś poprawnie bajt
INC HL                       `
LD (#8026),HL                `
LD HL,#801F                  `
DEC (HL)                     `/DEC (HL) wpływa na flagę Zero/
RET NZ                       `
LD HL,#8028                  `kolejny krok
INC (HL)                     `
RET                          `
CALL @RxNOK           @Rar_4 `+409tkt `adres dla kroku 4 odbierz i spr #7F
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JP NC,@ifTim                 `brak poprawnego bajtu -> sprawdź czy czas
JP NZ,@kro=1                 `error straty, ramki lub parity
LD A,#7F                     `
CP E                         `
JP Z,@AsWnt                  `hop bo taki jak oczekiwany czyli #7F
LD A,#04                     `
LD (#8028),A                 `przełącz na 4 krok odbioru treści
LD HL,#0113                  `czas dla odbioru treści
LD (#8026),HL                `ustaw czas dla odbioru treści
LD HL,#80C6                  `to potrzebne w proc. @_rr_4
SUB A                        `
LD (#802A),A                 `zeruj kroczek
JP @_rr_4                    `rób jakby odbiór treści...
LD A,(#8023)         @Rar_5  `+278tkt `krok 5 odbierz i spr ID (Z80)
LD D,A                       `
JP @odbie                    `
CALL @RxNOK          @Rrr_5  `+199tkt `krok 5 odbierz ID NOKIA
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JP NC,@ifTim                 `brak poprawnego bajtu -> sprawdź czy czas
JP NZ,@kro=1                 `error straty, ramki lub parity
LD A,E                       `
LD (#8022),A                 `ID odebrany z NOKIA
JP @AsWnt                    `
CALL @RxNOK          @Rrr_6  `224tkt `krok 6 odbierz i spr XOR
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JP NC,@ifTim                 `brak poprawnego bajtu -> sprawdź czy czas
JP NZ,@kro=1                 `error straty, ramki lub parity
LD A,(#8021)                 `
CP E                         `
JP NZ,@if#1F                 `parityXOR inna niż obliczona -> zrób od początku
LD A,#08                     `STOP -> odebrano poprawnie ramkę
LD (#8028),A                 `
RET                          `
CALL @RxNOK          @Rar_6  `+224tkt `krok 6 odbierz i spr XOR
`   CY & Z  -> odebrany poprawnie bajt w rej E       (trwa  94 tkt)
`   CY & NZ -> odebrany bajt w rej E, błąd a rej Acc (trwa 128 tkt)
`   NC & Z  -> time over                             (trwa  84 tkt) 
`   NC & NZ -> brak bajtu                            (trwa 115 tkt) 
JP NC,@ifTim                    `brak poprawnego bajtu -> sprawdź czy czas
JP NZ,@kro=1                    `error straty, ramki lub parity
LD A,(#8021)                    `
CP E                            `
JP NZ,@if#1F                    `parityXOR inna niż obliczona -> zrób od początku
LD HL,#8023                     `
INC (HL)                        `INC (ID_Z80)
LD A,#18                        `STOP -> odebrano poprawnie ACK
LD (#8028),A                    `
RET                             `
`-------------------------- kroki MASTER NOKIA ----------------------------
`                               
`krok MASTER #00 zeruje tylko komunikat USERa
`i przechodzi do następnego     
LD A,#01                 @MN_00 `+64tkt adres dla kroku 0 MASTER NOKIA Total ZEROWANIE,
LD (#81C9),A                    `zeruj ramkę USERA
JR @IncMK                       `następny MASTER KROK
`-------------------------------
`ustawia adresy NOKIA=#00, Z80=#1D, zeruje licznik bez odpowiedzi,
SUB A                    @MN_01 `+297tkt adres dla kroku 1 MASTER NOKIA RESET 
`                                ale bez zerowania kom. USERA,
LD (#8023),A                    `numer ID nadawanego z Z80
LD (#8024),A                    `adres określający NOKIA =#00
LD (#802C),A                    `licznik bez odpowiedzi -zeruj
LD A,#1D                        `
LD (#8025),A                    `ustaw początkowy adres Z80 [olewamy 'do wszystkich']
`             ZERUJEMY 8251 -port NOKIA 5110
SUB A `LD A,#00                 `
LD BC,#5001                     `
OUT (C),A                       `
OUT (C),A                       `
OUT (C),A                       `
LD A,#40                        `
` w słowie rozkazu 6 bit = 1 to RESET
OUT (C),A                       `
LD A,#5F                        `
` słowo trybu pracy dla asynchronicznej:
`       ---------------------------------
`       | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
`       ---------------------------------
`      bit7, bit6                
`         0   1   --> 1 bit stopu
`      bit5=0 --> kontrola nieparzystości
`      bit4=1 --> kontrola (nie)parzystości wyłączona /przy nadawaniu!/
`      bit3, bit2                
`         1   1   --> 8 bitów    
`      bit1, bit0                
`         1   1   --> podział TxC i RxC przez 64
OUT (C),A                       `
DEC C                           `
IN A,(C)                        `
IN A,(C)                        `
INC C                           `
LD A,#37                        `słowo rozkazu
`   słowo rozkazu ma bity o następującym znaczeniu:
`             bit    0 -TxEn =1 nadawanie dozwolone
`             bit   1  -DTR  =1 linia wyj.DTR w stanie niskim -aktywnym
`             bit  2   -RxEn =1 odbiór dozwolony
`             bit 3    -SBRK =0 linia TxD pracuje normalnie
`      bit    4        -ER   =1 wyzerowanie wskaźników PE, OE i FE w słowie stanu
`      bit   5         -RTS  =1 linia wyj.RTS w stanie niskim -aktywnym
`      bit  6          -IR   =0 nic
`      bit 7           -EH   =0 nic
OUT (C),A                       `
LD BC,#5081                     `sterowanie klawiszami,
LD A,#80                        `nic nie wciśnięte,
` bitD7=1 to OnOff nie wciśnięte
` bitD6=0 to C     nie wciśnięte
` bitD5=0 to OK    nie wciśnięte
` bityD0-4 bez znaczenia        `
OUT (C),A                       `
LD HL,#80AD                     `
SET 7,(HL)                      `zapal bit świecenia ciągłego LED StatusSystemu
LD A,#20                        `czas gdy nic nie wciśnięte po włączeniu
LD (#802D),A                    `jako delay przed-keya ustaw 1[s] czyli 64
SUB A                           `\
LD (#807C),A                    `/LEDgreen -poziom GSM
JR @IncMK                       `następny MASTER KROK
`--------------------------------
`                                
`czekaj na delay keya, wciśnij OnOff i ustaw czas wciśnięcia na ok. 1[s]
LD A,(#802D)             @MN_02 `+116tkt adres dla kroku 2 MASTER NOKIA 
AND A                           `
RET NZ                          `jeśli nie minął czas to czekaj jeszcze...
LD BC,#5081                     `sterowanie klawiszami
LD A,#00                        `wciśnięte OnOff,
` bitD7=1 to OnOff wciśnięte     
` bitD6=0 to C     nie wciśnięte 
` bitD5=0 to OK    nie wciśnięte 
` bityD0-4 bez znaczenia         
OUT (C),A                       `
LD A,#80                        `czas wciśnięcia OnOff
LD (#802D),A                    `delay keya ustaw na ok.1[s] czyli 256 przerwań /co czwarte/
`                      w powyższym czasie powinny nadejść 3 ramki resetowe z NOKIA (olewamy)
LD HL,#802B              @IncMK `+32tkt zwiększ krok MASTER NOKIA
INC (HL)                        `
RET                             `
`-----------------------------------------
`
`zamień 7 bajtów na 8 znaków z (HL) na (DE)
`trwa +597tkt
`zmienia: AFBCDEHL, stos 0
`wyjście NC =skończono, CY =nie skończono
LD DE,(#80D3)            @ENIGI `dynamiczny adres wynikowy tekstu
LD HL,(#80D1)            @kode1 `dynamiczny adres rozkodowywanego SMSa
`---                              
LD A,(HL)                       `
AND #7F                         `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RLCA                            `
AND #01                         `
LD C,A                          `------mamy zrobiony 1szy bajt, 
LD A,(HL)                       `
RLCA                            `
AND #7E                         `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RLCA                            `
RLCA                            `
AND #03                         `
LD C,A                          `------mamy zrobiony 2gi bajt, 
LD A,(HL)                       `
RLCA                            `
RLCA                     @kode2 `
AND #7C                         `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RLCA                            `
RLCA                            `
RLCA                            `
AND #07                         `
LD C,A                          `------mamy zrobiony 3ci bajt, 
LD A,(HL)                       `
RLCA                            `
RLCA                            `
RLCA                            `
AND #78                         `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RLCA                            `
RLCA                            `
RLCA                            `
RLCA                            `
AND #0F                         `
LD C,A                          `------mamy zrobiony 4ty bajt, 
LD A,(HL)                       `
RLCA                            `
RLCA                            `
RLCA                            `
RLCA                            `
AND #70                  @kode3 `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                @kode5 `
INC HL                          `
RRCA                            `
RRCA                            `
RRCA                            `
AND #1F                         `
LD C,A                          `------mamy zrobiony 5ty bajt, 
LD A,(HL)                       `
RRCA                            `
RRCA                            `
RRCA                            `
AND #60                         `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RRCA                            `
RRCA                            `
AND #3F                         `
LD C,A                          `------mamy zrobiony 6ty bajt, 
LD A,(HL)                       `
RRCA                            `
RRCA                            `
AND #40                  @kode4 `
OR C                            `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY
LD A,(HL)                       `
INC HL                          `
RRCA                            `
AND #7F                         `po tym NC
LD (DE),A                       `
INC DE                          `nie zmienia CY`------mamy zrobiony 7my bajt, 
LD (#80D1),HL                   `dynamiczny adres rozkodowywanego SMSa
LD (#80D3),DE                   `dynamiczny adres wynikowy tekstu
RET                             `
`--------------------------------
`                               
`czekaj na delay keya (z wciśniętym OnOff), wyciśnij OnOff, nadaj ramkę rejestracyjną
`(nie odbieramy ramki rejestracyjnej, zakładamy że przyjdzie)
LD A,(#802D)            @MN_03 `+144tkt adres dla kroku 3 MASTER NOKIA 
AND A                          `
RET NZ                         `jeśli nie minął czas to czekaj jeszcze...
LD BC,#5081                    `sterowanie klawiszami
LD A,#80                       `nic nie wciśnięte,
` bitD7=1 to OnOff nie wciśnięte
` bitD6=0 to C     nie wciśnięte
` bitD5=0 to OK    nie wciśnięte
` bityD0-4 bez znaczenia
OUT (C),A                      `
LD A,#01                @_MN3a `+84tkt
LD (#8029),A                   `ustaw ramkę do nadania nr #01 (czyli rejestracyjną)
LD A,#20                       `
LD (DE),A               @In#28 `nadaj ramkę rejestracyjną
JP @IncMK                      `następny MASTER KROK
`-------------------------------
`                               
LD A,(DE)               @MN_04 `adres dla kroku 4 MASTER NOKIA 
CP #28                         `/pośrednich wart nie będzie bo w czasie nadawania 
`                               i tak do MASTERA nie wejdzie/
JR Z,@_MN4_                    `hop -> nadano
LD A,#01                @RESEt `+31tkt tutaj error
LD (#802B),A                   `przejdź do kroku RESETowego, bo nie nadano
RET                            `
LD BC,#8023             @_MN4_ `
LD A,(BC)                      `
INC A                          `
LD (BC),A                      `numer ID nadawanego z Z80
LD A,#00                       `
JR @In#28                      `
`LD (#8028),A                   `odbierz ramkę
`JP @IncMK                      `następny MASTER KROK
`-------------------------------
`                               
LD HL,#802C             @MN_05 `szybciej i taniej!
LD A,(DE)                      `+217tkt adres dla kroku 5 MASTER NOKIA 
CP #08       `/pośrednich wart nie będzie bo w czasie odbioru i tak do MASTERA nie wejdzie/
JR NZ,@_MN5a                   `hop -> nie odebrano ramki 
LD A,(#80C8)                   `odebrano ramkę, czy to rejestracyjna?
CP #01                         `Ldługość =#01 to komunikat rejestracyjny z NOKIA
JR NZ,@_MN5a                   `hop -> to nie rama rejestracyjna
SUB A                          `
LD (HL),A                      `zeruj licznik 'bez odpowiedzi'
LD (#801C),A                   `0-1-2-0-1-2-0... licznik kolejnych komunikatów dla NOKIA
JP @IncMK                      `następny MASTER KROK
LD A,(HL)               @_MN5a `
INC A                          `
LD (HL),A                      `
CP #05                         `=czyli do 5 powtarza, potem RESET
JR NC,@RESEt                   `hop -> error -> RESETuj
LD A,#03                       `HL=#802C
DEC HL                         `HL=#802B
LD (HL),A                      `przejdź do kroku 3ego -> rejestruj raz jeszcze
JR @_MN3a                      `
` --------------- ALGORYTM NORMAL ------------------------
`                               
LD HL,#801C             @MN_06 `+878tkt adres dla kroku 6 MASTER NOKIA 
LD A,#02                       `
LD (#8020),A                   `2 powtórki
LD A,(HL)                      `
INC A                          `kolejna ramka
CP #03                         `wiadomo -modulo 3
JR C,#01                       `
SUB A                          `
LD (HL),A                      `zapisz kolejną ramkę
JP C,@_MN6b                    `+10+178tkt hop -> poziom GSM
LD A,(#81C9)                   `czy jest gotowa treść USERA? 
AND A                          `(gdy =#00 to gotowa, gdy <>#00 brak treści)
JR NZ,@_MN6d                   `+12+772tkt hop -> nie ramka USERA (nie czeka na nadanie)
LD A,#05                @_MN6_ `+99tkt powtórki dla ramki USERa
LD (#8020),A                   `5 powtórek
SUB A                          `
JP @_MN6a                      `+10+65tkt hop -> nadaj ramkę USERA Acc =#00 !
`--------------sieć/LAC/CID-----
LD A,(#804D)            @_MN6d `+772tkt #804D -minuty  /czas od określenia ostaniej 
LD B,A                         `sieci LAC i CID,
LD A,(#850F)                   `tutaj skonfigurowany maksymalny czas w minutach, 
AND A                          `
JR Z,@_MN6D                    `+12+710tkt hop -> =#00 a więc nieokreślony czas sprawdzania 
`                                         LAC CID, więc przyjmujemy że nie żądamy LAC CID
`                               powyżej którego Z80 żąda znów LAC i CID
SUB B                          `
LD A,#06                       `ramka -żądanie sieci LAC i CID
JP C,@_MN6a                    `+10+65tkt hop -> trzeba teraz określić CID i LAC
LD A,(#802E)            @_MN6D `+710tkt odczytaj DKROK
CP #FF                         `
JP Z,@_MN6p                    `+10+690tkt hop -> nic z DKrokiem, rób dalej...
AND A                          `
JR NZ,@_MN6m                   `+12+591tkt hop -> krok <>#00 a więc sprawdź dalej
LD A,#03                       `ramka -żądania IMEI
JP @_MN6a                      `+10+65tkt hop -> ustaw do nadania ramkę USERa Acc
LD DE,#81C8             @_MN6m `+591tkt adres kom USERa dla NOKIA
CP #0E                         `
JP Z,@MN6__                    `+10+558tkt hop -> ramka D ustawiania alarmu NOKIA
CP #0C                         `
JR Z,@_MN6o                    `+12+545tkt hop -> odczytaj/zapisz czas z NOKIA
CP #0D                         `
JR Z,@_MN6O                    `+12+508tkt hop -> zapisz czas do NOKIA
CP #03                         `
JP C,@_MN6z                    `+10+84tkt hop -> rutynowa ramka żądania wersji 
CP #06                         `
JR C,@_MN6n                    `+12+478tkt hop -> #03 lub #04 lub #05 czyli żądanie SMSa konfiga
JP @_MN6z                      `hop -> rutynowa ramka żądania wersji (czyli nie angażuj nic)
`poniżej ramka @RR_D* -zapis alarmu do NOKIA
` #1F #00 #1D #11 #00 #0D        
` #00 #01 #00 #6B #01 #20 #03 #01 #FF #05 #00 #01 #40` gdzie #FF #05 to godzina i minuta
LD HL,@RR_D*            @MN6__ `+558tkt ramka D -alarmu do NOKIA
LD BC,#0010                    `
LDIR                           `
LD B,#0C                       `przesuń do Brej
LD A,(#8006)                   `godzina Z80
LD C,A                         `godzina bieżąca
ADD A,B                        `dodaj deltę godzin dla alarmu
SUB #18                        `modulo &24
JR NC,@_MN6r                   `+12+122tkt nie było przeniesienia, więc OKI
ADD A,#18                      `zwróć, bo przeholowałeś
LD B,A                  @_MN6r `
LD A,(#8510)                   `dzień tygodnia wysłania ostatniego al. dobowego
LD HL,#800A                    `adr. bieżącego dnia tygodnia
CP (HL)                        `porównaj czy ostatni dzień wysłania dobowego to dziś?
JR Z,@bzMDo                    `hop -> już dziś wysłano meldun dobowy
LD A,(#8557)                   `czy chcemy i godzina meldunku dobowego
BIT 7,A                        `czy chcemy meldunu dobowego?
JR NZ,@bzMDo                   `hop -> bez meldunku dobowego
` zasada: jeśli godzina dobowego już była (lub jest) to ustaw alarm na bieżący +12h [B]
`         jeśli nie to ustaw na godzinę alarmu [C]
CP C                           `dobowy - bieżąca, CY -> jeszcze nie było
JR C,@bzMDo                    `już był, ustaw na za 12h
LD B,A                         `ustaw na godzinę dobowego
LD A,B                  @bzMDo `ustaw bieżący +12h
LD (#81D3),A                   `
` po wysłaniu meldunku dobowego, i tak zapiszemy konieczność zapisu konfigu
` do SIM, co spowoduje przejście przez DKrok zapisu alarmu (i obliczenia godziny),
` tak więc nie ma w zasadzie obawy że jeśli godzina alarmu była wcześniejsza niż
` obecna to alarm będzie za więcej niż 12h
``` do tego miejsca             
`                               zawsze =#05 /w ramce @RR_D* w LDIR/)
JP @_MN6_                      `+10+99tkt hop -> nadaj ramkę USERA
SUB #03                 @_MN6n `+478tkt hop -> bo krok #03, #04 lub #05
JR NZ,@_MN6N                   `hop gdy NIE pierwsze żądanie SMSa konf
LD HL,#0000                    `to zeruj rok w jego tmp dacie (czyli tak, jakby go nie było)
LD (#809C),HL                  `zeruj tymczasowy bo pierwszy raz pytamy o SMS konfigu
`                               i ustawiamy datę SMSa z poz #09 gdyby go nie było.
ADD A,#09               @_MN6N `+438tkt żądanie SMSa konfig #09 lub #0A
`dodajemy do wartości #03   ->  #09
`                     #04   ->  #0A
`                     #05   ->  #0B -> #09
CP #0B                         `
JR C,@RdSms                    `
LD A,#09                       `
LD HL,@RR_8*            @RdSms `+410tkt ramka 8 -żądanie odczytu SMSa z SIM
`poniżej ramka  @RR_8* -żądanie odczytu SMSa z SIM
` #1F #00 #1D #14 #00 #0A   
` #00 #01 #00 #07 #02 #FF #01 #64 #01 #43 `gdzie bajt #FF to pozycja żądanego SMSa
LD BC,#000D                    `
LDIR                    @_dSms `
LD (#81D0),A                   `zapisz pozycję SMSa do odczytu w ramce mbus'a
JP @_MN6_                      `+10+99tkt hop -> nadaj ramkę USERA
LD A,(#8001)            @_MN6o `+545tkt StatusTime
CP #03                         `czy ustawiony?
LD A,#05                       `ramka -żądanie daty i czasu z NOKIA
JP C,@_MN6a                    `hop -> czas nieustawiony (a więc odczytaj z NOKIA)
`poniżej ramka @RR_C* -zapis czasu i daty do NOKIA
` #1F #00 #1D #11 #00 #0D       
` #00 #01 #00 #60 #01 #01 #07 #07 `#FF #FF #FF #FF #FF `rok/m-c/dz/godz/min
LD HL,@RR_C*            @_MN6O `+508tkt ramka C -czasu i daty do NOKIA
LD BC,#000B                    `
LDIR                           `
`  #8005 -> minuty,         \zliczane jako 
`  #8006 -> godziny,        /czas rzeczywisty...
`  #8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`  #8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`  #8009 -> lata (#00 = 2000r)  
LD HL,#8009                    `+262tkt rok Z80
LD DE,#81D3                    `rok NOKIA
LD A,(HL)                      `
OR #C0                         `
LD (DE),A                      `rok
DEC HL                         `
INC DE                         `
LD A,(HL)                      `
INC A                          `
LD (DE),A                      `miesiąc
DEC HL                         `
INC DE                         `
LD A,(HL)                      `
INC A                          `
LD (DE),A                      `dzień
DEC HL                         `
INC DE                         `
LD A,(HL)                      `
LD (DE),A                      `godzina
DEC HL                         `
INC DE                         `
LD A,(HL)                      `
LD (DE),A                      `minuta
JP @_MN6_                      `+10+99tkt hop -> nadaj ramkę USERA
`--------------książka telef.- MUSI BYĆ PO SIECI!!!--------
`to poniższe spowoduje, że książka będzie odczytywana dopiero po 10 sekundach od odczytu sieci
LD A,(#807F)            @_MN6p `+690tkt którą ze znanych pozycji teraz sprawdzamy/status
CP #FF                         `
JR Z,@_MN6j                    `+12+658tkt hop -> skończone szukanie w książce
LD C,A                         `zachowaj
LD A,(#8080)                   `czy była odpowiedź na ostatni żądany? 
AND A                          `(=#00 to była, >#00 nie było)
JR Z,@_MN6i                    `+12+488tkt hop -> była odpowiedź, teraz kolejny
DEC A                          `dec(krotność prób)
LD (#8080),A                   `zapisz
JR NZ,@_MN6f                   `+12+360tkt jeszcze raz ten sam, na który nie było odpowiedzi
LD A,C                  @_MN6i `+488tkt odtwórz którą ze znanych pozycji teraz sprawdzamy
CP #FE                         `
JR NZ,@_MN6e                   `+12+465tkt hop -> szukaj w znanych poz.
LD HL,#807E                    `adr. przy której teraz jesteśmy pozycji
LD A,(HL)                      `sprawdzimy przy której teraz jesteśmy pozycji
INC A                          `kolejna poz z ks. tel. (sprawdzamy wszystkie)
LD (HL),A                      `zapisz
CP #80                         `jeśli przy tej lub wyżej to kończ szukanie
JR C,@_MN6h                    `+12+380tkt hop -> szukaj dalej w całej książce
` tutaj, jeśli brak prefixu to zrób prefix domyślny
LD HL,@PRdom                   `
LD DE,#850A                    `
LD BC,#0005                    `
LDIR                           `
LD A,#FF                       `przeszukano całą książkę
LD (#807F),A                   `tu przeszukana cała książka, więc zablokuj szukanie w ks.tel
LD A,#01                       `czas [min] po którym zrobi DKrok=8 czyli zapisze konfigi
LD (#807D),A                   `zapisz konfigi [bo znalazłeś nowe poz. znane na SIM]
JP @_MN6z                      `+10+84tkt hop -> skończone szukanie w książce
LD A,#03                @_MN6h `+380tkt ustal krotność na 3
LD (#8080),A                   `zapisz krotność 
LD HL,@RR_7*            @_MN6f `+360tkt adr.ramki żądania poz. z ks. tel.
`                               
`@RR_7* : #1F #00 #1D #03 #00 #07 #00 #01 #00 #01 #03 #FF #00 _ID XOR
`                                              gdzie bajt #FF to pozycja żądana
LD DE,#81C8                    `
LD BC,#000A                    `
LDIR                           `
LD A,(#807E)                   `żądana pozycja
LD (#81D0),A                   `zmień bajt 
LD A,#05                       `czekasz na komunikat z ks. telefonicznej (przez 5 sekund)
LD (#807A),A                   `
SUB A                          `
JP @_MN6a                      `+10+65tkt hop -> wyślij jak kom.USERA ale z małą liczbą powtórek
CP #0A                  @_MN6e `+465tkt szukaj w znanych poz.
`                               tyle jest znanych pozycji (+prefix+centrumSMS)
JR NC,@_MN6g                   `+12+429 zaznacz (bo właśnie skończono przeszukiwanie znanych) że 
`                               przeszukujemy wszystkie i startuj od #00 z przeszukiwaniem 
`                               wszystkich
INC A                          `czyli przeszukujemy kolejne znane
LD (#807F),A                   `to następnym razem
DEC A                          `teraz wracamy do aktualnej pozycji
LD HL,#8500                    `adres RAM 9 znanych pozycji (bo też prefix i centrumSMS)
ADD A,L                        `nie na przełomie!
LD L,A                         `
LD A,(HL)                      `tu pozycja SIM z kolejnych
LD (#807E),A                   `pozycja do zażądania
JR @_MN6h                      `+12+380tkt hop -> czyli na nowo krotność i żądaj tej poz.
LD A,#FE                @_MN6g `+429tkt 
LD (#807F),A                   `rozpocznij przeszukiwanie całej ksiązki
SUB A                          `od początku
LD (#807E),A                   `pozycja z kolejnych do zażądania (wszak od początku)
JR @_MN6h                      `+12+380tkt hop -> czyli na nowo krotność i żądaj tej poz.
`--------------czy trzeba coś z SMSami-odczyt/kasowanie
LD B,#02                @_MN6j `+658tkt sprawdź cyklicznie all SMSy... odczyt/kasowanie
LD HL,#802F                    `
LD A,(HL)                      `odczytaj pozycję SMSa
CP #1A                  @_MN6t `czy poza zakr?
JR NC,@_MN6u                   `hop -> poza &25
CP #09                         `poz konfigu1
JR Z,@_MN6x                    `
CP #0A                         `poz konfigu2
JR Z,@_MN6x                    `hop -> ignorowany SMS bo pozycja konfiga
LD C,A                         `zachowaj sprawdzaną pozycję SMSa
ADD A,L                        `
LD L,A                         `
LD A,(HL)                      `bajt odpowiadający temu SMSowi
CP #80                         `czy ma być ignorowany?
JR NC,@_MN6x                   `hop -> ignorowany SMS
DEC A                          `czyli dla =#01 będzie Z dla pozostałych NZ
LD A,C                         `odtwórz sprawdzaną pozycję SMSa
LD DE,#81C8                    `adres kom USERa dla NOKIA
JP NZ,@RdSms                   `+10+410tkt czyli utwórz ramkę żądania SMSa z poz Acc
`      tutaj kasujemy          `
LD HL,@RR_A*                   `adr.ramki kasowania SMSa
`poniżej ramka @RR_A* -żądanie skasowania SMSa z SIM
` #1F #00 #1D #02 #00 #07 `      
` #00 #01 #00 #0A #02 #FF #01  `gdzie bajt #FF to pozycja SMSa
LD BC,#000A                    `
JP @_dSms                      `+10+327tkt czyli przeładuj i wyślij z poz. Acc jako USERa
LD HL,#802F             @_MN6x `jeśli omijamy to sprawdzamy kolejny...
LD A,(HL)                      `\
INC A                          ` |kolejny SMS sprawdź bo ominąłeś jeden...
LD (HL),A                      `/
DJNZ @_MN6t                    `
JR @_MN6z                      `rutynkę nadaj
LD A,#01                @_MN6u `+110tkt 
LD (HL),A                      `zacznij przeszukiwanie od początku
JR @_MN6z                      `+12+84tkt rutynka bo przeszukał &23 SMSy
LD A,#04                @_MN6z `+84tkt rutynowa ramka żądania versji (czyli zapchajdziura)
JR @_MN6a                      `+12+65tkt hop -> w Acc nr ramki rutynowej
LD HL,#80B2             @_MN6b `+178tkt adr. pomocn. bieżącego poziomu GSM
LD A,(HL)                      `odczytaj poziom GSM
INC A                          `czyli #FF -> #00
LD B,A                         `zapamiętaj stary poziom
LD A,#FF                       `poziom =#FF to brak
LD (HL),A                      `wyzeruj
LD A,B                         `
LD (#807C),A                   `zapisz opracowany poziom 0-5
CP #02                         `bo #00 i #01 to stany alarmowe
LD HL,#80AD                    `adr. bajtu znaczników mrugającej LED stanu
JR C,@_Mn66                    `+12+86 hop -> ustaw bit zerowego poziomu GSM
`           zeruj bit braku zasięgu GSM
RES 7,(HL)                     `
JR @_Mn65                      `
SET 7,(HL)              @_Mn66 `+86tkt świeci ciągle =bardzo źle!
LD A,#02                @_Mn65 `+72tkt ramka -poziom GSM
LD (#8029),A            @_MN6a `+65tkt ustaw ramkę do nadania nr Acc
LD A,#20                @_MN6c `+52tkt nadaj ramkę USERA
LD (#8028),A                   `
LD HL,#802B                    `+32tkt zwiększ krok MASTER NOKIA
INC (HL)                       `
RET                            `
`-------------------------------
`                               
LD A,(DE)               @MN_07 `adres dla kroku 7 MASTER NOKIA 
CP #28                         `tyle jest gdy nadano ramkę
`                               lub #0F tzn. error
JP NZ,@RESEt                   `hop -> nie nadano -> zrób krok RESETu
LD A,#10                `@_MN7a `
JR @IN#28                      `
`LD (#8028),A                  `odbierz ACK
`JP @IncMK                     `następny MASTER KROK
`-------------------------------
`                               
LD A,(DE)               @MN_08 `adres dla kroku 8 MASTER NOKIA 
CP #18                         `tyle jest gdy odebrano ACK
JR Z,@_MN8b                    `hop -> odebrano ACK
CP #08                         `tyle gdy odebrano ramę
JR Z,@_MN8c                    `hop -> odebrano ramkę
`         tu error              
LD BC,#802C                    `
LD A,(BC)                      `czytaj 'bez odpowiedzi'
INC A                          `zwiększ 'bez odpowiedzi'
LD (BC),A                      `zapisz 'bez odpowiedzi'
CP #03                         `czy bez odpowiedzi
JR C,@_MN8e                    `hop -> bez odpowiedzi < 3
CP #05                  @_MN8e `
JP NC,@RESEt                   `hop -> bezodpowiedzi>5 -> zrób krok RESETu
LD HL,#8020                    `powtórzeń tej ramki
DEC (HL)                       `ustawia Z w rejF
JR Z,@_MN8a                    `hop -> skończyły się powtórzenia
LD A,#06                       `MKrok:=6
LD (#802B),A                   `przejdź do kroku ponownego nadania tego samego komunikatu
JR @_MN6c                      `przejdź
`LD A,(HL)               `@_MN8b `
`AND #BF                        `zgaś bit świecenia ciągłego LED StatusSystemu
`LD (HL),A                      `
SUB A                   @_MN8b `+159tkt odebrano ACK, zeruj bez odpowiedzi
LD (#802C),A                   `zeruj
LD A,(#801C)                   `teraz sprawdź czy nadawana była ramka USERA, 
AND A                          `jeśli tak to ją zablokuj
JR NZ,@_MN8d                   `hop -> była nadawana inna ramka niż USERa
LD A,(#81C9)                   `
AND A                          `
JR NZ,@_MN8d                   `bo to ramka poziomu GSM a nie USERa
SET 7,A                        `zapalenie 7 bitu powoduje że ramka jest traktowana jak wolna
LD (#81C9),A                   `
JR @_MN8d                      `
LD HL,#8023             @_MN8a `+92tkt tutaj koniec powtórek i bez sukcesu -trza inc(ID_Z80)
INC (HL)                       `inc(ID_Z80)
SUB A                   @_MN8d `
LD (#8028),A            @IN#28 `odbierz ramkę
JP @IncMK                      `następny MASTER KROK
LD A,#09                @_MN8c `+108tkt MKrok:=9
LD (#802B),A                   `przejdź do kroku ponownego nadania tego samego komunikatu
`???????????????????????????????????????????????????????????
LD A,(#801C)                   `teraz sprawdź czy nadawana była ramka USERA, 
AND A                          `jeśli tak to ją zablokuj
JR NZ,@_MN8f                   `hop -> była nadawana inna ramka niż USERa
LD BC,#81C9                    `
LD A,(BC)                      `
AND A                          `
JR NZ,@_MN8f                   `bo to ramka poziomu GSM a nie USERa
LD A,(#81C8)                   `rozkaz USERa
` zamień kolejność sprawdzania to będzie szybciej i taniej!
CP #02                         `czy to wysyłanie SMSa? /też kasowanie SMSa!/
JR NZ,@_MN8f                   `bo to inna ramka USERa niż wysłanie SMSa
LD A,(BC)                      `
SET 7,A                        `zapalenie 7 bitu powoduje że ramka jest traktowana jak wolna
LD (BC),A                      `
`???????????????????????????????????????????????????????????
JR @_MN9b               @_MN8f `przejdź do analizy odebranego komunikatu
`-------------------------------
`                               
LD A,(DE)               @MN_09 `adres dla kroku 9 MASTER NOKIA 
CP #08                         `
JR NZ,@_MN9a                   `hop -> error lub odebrano ACK
SUB A                   @_MN9b `+76tkt tu odebrano ramkę
LD (#802C),A                   `zeruj bez odpowiedzi
SUB A                          `startuj kroczek, który będzie wykładnikiem In/Out analizy
LD (#802A),A                   `zapisz
JP @IncMK                      `następny MASTER KROK
LD A,#0B                @_MN9a `+94tkt MKrok:=10
LD (#802B),A                   `przejdź do kroku pauzy 1s bo nie odebrano ACK
JR @_MNBa                      `przejdź do oczekiwania
`-------------------------------
`                               
`minęło już 116tkt od wywołania @nokia...
LD E,#2A                @MN_0A `
LD A,(DE)                      `DE=#802A
INC A                          `zwiększ kroczek
LD (DE),A                      `zapamiętaj
CP #50                         `
JP C,@InOuA                    `czyli wykonaj InOut analizę [f(Acc)] już 158tkt(=116+42)
SUB A                          `
LD (HL),A                      `zapisz
LD A,#30                       `nadaj ACK
JR @IN#28                      `
`LD (#8028),A                  `nadaj ACK
`JP @IncMK                     `następny MASTER KROK
`-------------------------------
`                               
LD A,(DE)               @MN_0B `+92tkt adres dla kroku 10 MASTER NOKIA 
CP #38                         `tyle gdy nadano ACK,
JP NZ,@RESEt                   `hop -> nie nadano -> zrób krok RESETu
SUB A                   @_MNBa `+62tkt odbierz ramkę
JR @IN#28                      `
`LD (#8028),A                  `i już
`JP @IncMK                     `następny MASTER KROK
`-------------------------------
`                               
LD A,(DE)               @MN_0C `+140tkt adres dla kroku 11 MASTER NOKIA
CP #08                         `czy odebrano ramkę?
JR Z,@_MN8c                    `hop -> odebrano ramkę
LD A,#06                       `krok 6-y
LD (#802B),A                   `przejdź do kroku 6-ego, czyli początek pętli
RET    `JP @MN_06   `dla skoku do MN_06 trwał za długo!, bo +55tkt + @MN_06
`---------------- POZIOM NOKIA MANAGER -----------------------
`
` minęło już 158tkt od początku @nokia
`            zakres Acc: #01-#4F
SUB #05                 @InOuA `czyli wykonaj InOut analizę [f(Acc)]
LD D,#00                       `!! to #00 wykorzystywane jeszcze później !!
`                               odjęcie wartości krótkiej analizy (wartośc Acc=#00 nie występuje!)
JR NC,@InDLU                   `hop -> to będzie analiza długiego komunikatu
ADD A,#04                      `jednak analiza krótkiego, ma on 4 kroki, tak więc dodaj 4 ponieważ 
`             wartość Acc=#00 nie występuje tak więc pierwszym będzie krok #00 a potem aż do #03
LD HL,@TInAk                   `czyli adres tabeli adresów 4 kroków analizy 
`                               i wykonania krótkich ramek
ADD A,A                        `
LD E,A                         `
JR @InGO!                      `hop do pobrania adresu z tablicy @TInAk i skoku do niego 
CP #3B                  @InDLU `bo #40 - #05
JR NC,@In_PO                   `hop -> do SecondInAnalizy i dalej do NOKIA DIRECTORA [Acc #3B-#4A]
`LD D,#00    już jest          `!! to #00 wykorzystywane jeszcze później !!
LD B,A                         `zachowaj kroczek w Brej
`            zakres Acc: #00-#3A
ADD A,A                        `tutaj analiza i wykonanie długich komunikatów
LD E,A                         `obliczona delta adresu w zależności od szczegółowego kroku
LD A,(#80C7)                   `odczytaj podkod ramy
CP #08                         `czyli zezwala tylko na analizy #00-#07
JR NC,@iFSec                   `hop ->minęło 158+77=235
LD HL,@TIAAd            @MkSec `+96tkt adres tabeli do długich ram, tabela zawiera adresy 
`                               podtabel dla poszczególnych RODZAJÓW analizowanych ram
ADD A,A                        `*2 do obliczenia delty adresu
LD B,D                         `oczywiście #00
LD C,A                         `obliczona delta w zależności od rodzaju ramy: ks.tel/ring/SMS...
ADD HL,BC                      `
LD A,(HL)                      `odczytaj bajty adresu procedury dla kroku
INC HL                         `
LD H,(HL)                      `odczytano adres podtabeli
LD L,A                         `teraz w tej podtabeli znajdź adres kroku analizy
ADD HL,DE               @InGO! `+39tkt In analiza GO! -> wykonaj
LD A,(HL)                      `odczytaj bajty adresu procedury dla kroku
INC HL                         `
LD H,(HL)                      `
LD L,A                         `
JP (HL)                        `i wykonaj ta procedurę (minęło 326tkt dla długich @TIAAd)
`                                                      (minęło 255tkt dla krótkich @TInAk)
`                                                      (minęło 436tkt dla pierwszego z @SsmsK)
`                                                      (minęło 452tkt dla pierwszego z @SsmsN)
`                                                      (minęło 491tkt dla pierwszego z @Scall)
LD A,(#802E)            @iFSec `DKrok
CP #FF                         `jeśli nie używamy DKroku to można coś innego...
JR Z,@CÓŚin                    `hop -można coś zmajstrować...
CP #08                         `
JP C,@OkZro                    `hop -> kroki 0 - 7 -nie interesują, ale też nie zajmujemy USERA
JP Z,@KTsim                    `hop -> zapis ks telef na SIM
CP #0B                         `
JP NC,@OkZro                   `hop -> kroki inne niż 9 i A
`          tutaj DKrok 9 lub A a więc tworzenie kom. USERA tworzenia i zapisu konfigu
LD A,#05                       `czyli tworzenie SMSa konfigu
JR @_MkSe                      `wykonaj podkod dla długich ramek
LD A,B                  @CÓŚin `\kroczek InOuAnalizy
AND A                          `/
JP NZ,@OkZro                   `hop -> to nie początek tworzenia ramki więc wyjdź
LD A,(#84EE)                   `czy mamy do tworzenia textowy/bajtowy SMS?
AND #F0                        `było #E0, czyli SMSy które odrzucone ze względu na delivera
`LD B,A                         `tu chyba niepotrzebne ???
CP #80                         `
LD A,#06                       `tworzenie SMSa text/bajt
JR Z,@_MkSe                    `hop -> twórz SMSa
AND #80                        `
CP #80                         `
JP Z,@OkZro                    `hop -> nie zajmujemy USERA, bo jeszcze zajęty wysyłaniem SMSa
LD A,(#86A8)                   `czy jest numer do wybrania?
AND #F0                        `
CP #80                         `
LD A,#04                       `tworzenie USERa wybierania numeru
JP NZ,@OkZro                   `hop -> koniec bo nic nie trzeba
LD (#80C7),A            @_MkSe `+121tkt zapisz podkod ramy
JR @MkSec                      `wykonaj podkod dla długich ramek
LD A,#07                @KTsim `czyli tworzenie ramki (gdy trzeba) zapisu nr tel na SIM
JR @_MkSe                      `wykonaj podkod dla długich ramek
`  przy lądowaniu na @In_PO minęło już 158+38=196tkt od wywołania @nokia
JP Z,@OK_C_             @In_PO `dla Acc=#3B realizuj polecenia odb/zak/odrzuc połączeń fonicznych
`                               według IncommingCallResponse
`                       [Acc #3C-#4A]
RET                            `tutaj jest, gdy kroczek z zakresu NokiaDirectora
`-------------------------------
`                               
DEFETYK @TInAk                   `tablica adresów procedur wstępnej analizy i wykonania 
` krótkich ram dla poniższych procedur minęło już: 255tkt od wywołania @nokia
DEFTABE InAk0   `adres procedury 1 krok InAnalizy wstępnej i krótkich
DEFTABE InAk1   `adres procedury 2 krok InAnalizy wstępnej i krótkich
DEFTABE InAk2   `adres procedury 3 krok InAnalizy wstępnej i krótkich
DEFTABE InAk3   `adres procedury 4 krok InAnalizy wstępnej i krótkich
`
DEFETYK @TIAAd               `tablica adresów tablic analizy i wykonania długich ram
`  dla poniższych procedur minęło już: 326tkt od wywołania @nokia,
DEFTABE Iring   `#00 adres tablicy adresów kroków do analizy RING czyli numeru przychodzącego
DEFTABE Ikste   `#01 adres tablicy adresów kroków do analizy książki telefonicznej
DEFTABE ISMrx   `#02 adres tablicy adresów kroków do analizy SMSów odebranych/del/...
DEFTABE ISMrd   `#03 adres tablicy adresów kroków do analizy SMSów odczytanych/txba/...
`  dla poniższych procedur minęło już: 326tkt od wywołania @nokia,
`    za wyjątkiem pierwszego wywołania:
`          @Scall gdzie minęło 491tkt
DEFTABE Scall   `#04 adres tablicy adresów kroków do tworzenia połączenia fonicznego
`          @SsmsK gdzie minęło 436tkt
DEFTABE SsmsK   `#05 adres tablicy adresów kroków do tworzenia SMSa konfigu
`          @SsmsN gdzie minęło 452tkt
DEFTABE SsmsN   `#06 adres tablicy adresów kroków do tworzenia SMSa text/bajt
DEFTABE KsTeW   `#07 adres tablicy adresów kroków do tworzenia ramki zapisu ks telef na SIM
`-------------------------------
`
`   poniżej sprawdź, czy długość >3 i czy pierwsze trzy bajty treści to #01,#08,#00...
`   jeśli nie -to kończ InAnalizę (i zeruj kod rozkazu)
` trwa: +735max + 255 = 990tkt
LD HL,#80C8               @InAk0 `adres młodszego bajtu długości 
LD A,(HL)                        `odczytaj długość
CP #04                           `sprawdź długość komunikatu
JR C,@NoZro                      `wartość długości musi być >=4 czyli niezrozumiała...
INC L                            `adr pierwszego bajtu treści
LD A,(HL)                        `odczytaj
`    #01                         `
`XOR #08 -> #09                  `
`XOR #00 -> #09                  `
INC L                            `
XOR (HL)                         `
INC L                            `
XOR (HL)                         `
CP #09                           `
JR NZ,@NoZro                     `hop -> nie kończy się na #00, czyli niezrozumiała...
LD A,(#80CC)                     `drugi ważny (duży) bajt z komunikatu z mbus`a
LD B,A                           `zapamiętaj
LD A,(#80C6)                     `kod rozkazu
CP #04                           `IMEI/LEVEL
JP Z,@#04__                      `+735=+125+610tkt
CP #11                           `czas i alarm
JP Z,@#11__                      `+730=+142+588tkt
CP #0A                           `komunikat sieci i LAN/CID
JP Z,@#0A__                      `+436=+159+277tkt
CP #02                           `informacje o odebranym SMSie
JP Z,@#0214                      `+356=+176+180
CP #14                           `odczyt SMSów
JP Z,@#0214                      `+373=+193+180
CP #01                           `informacje o połączeniu telefonicznym
JR Z,@#01__                      `+357=+212+145
CP #03                           `książka telefoniczna
JR Z,@#03__                      `+312=+226+86
`
`  ew. tu dla innych rozpoznawalnych ramek
`
LD A,#FF                  @NoZro `+31tkt niezrozumiały, zrobione, zapisz 
LD (#80C7),A              @SvPkd `+24tkt zapisz podkod do dalszej analizy
RET                              `
LD A,#02             @OkSpd `
LD (#801C),A                `
LD A,#3F             @OkZro `+31tkt pierwszy krok SecondInAnalizy
LD (#802A),A                `zapisz, tak więc następne przerwanie to krok SecondInAnalizy
RET                         `...kończ analizę wejściową
`----------------------------------------------
`
`1 RING czyli sprawy związane z dzwonieniem telefonu itd.
`       wszystkie krótkie -> realizowane są w @InAk2, jedynym
`       długim jest informacja o numerze przychodzącym ->podkod #00
`trwa: +145tkt max
LD A,B               @#01__ `tkt analizuj informację o poł. telefonicznym
SUB #05                     `
JR Z,@SvPkd                 `długi -> numer przychodzący podkod #00
ADD A,#14                   `
CP #11              `(#02)  `krótki -> podkod #11 w drugim zaczyna dzwonić
JR Z,@SvPkd                 `hop -> 
CP #12              `(#03)  `krótki -> podkod #12 rozpoczęto rozmowę
JR Z,@SvPkd                 `hop -> 
CP #13              `(#04)  `krótki -> podkod #13 błąd/odrzucenie/zakończenie przez drugi
JR Z,@SvPkd                 `hop -> 
CP #19              `(#0A)  `krótki -> podkod #19 odrzucenie/zakończenie przez nas
JR Z,@SvPkd                 `hop -> 
SUB #30
CP #1F              `(#40)  `krótki -> podkod #1F potwierdzenie otrzymania numeru do wybrania
JR Z,@SvPkd                 `hop -> 
JR @NoZro                   `hop -> nieznany
`------------------------
`
`2 KSTEL czyli analizuj informacje o książce telefonicznej
`       krótki -> realizowany w @InAk2, zaś
`       długi to informacja o odczytanej pozycji w książce ->podkod #01
`trwa: +86tkt ++++++
LD A,B               @#03__ `tkt analizuj informację o książce telefonicznej
DEC A                       `oblicz podkod
CP #01              `(#02)  `
JR Z,@SvPkd                 `hop -> odczytano poz z ks tel na SIM
ADD A,#2E                   `oblicz podkod
CP #30              `(#03)  `
JR Z,@SvPkd                 `hop -> odczytywana pozycja jest pusta
`               ------------------
CP #32              `(#05)  `
JR Z,@SvPkd                 `hop -> potwierdzenie wykonania operacji na książce telefonicznej
`CP #33              `(#06)  `
`JR Z,@SvPkd                 `hop -> nie zapisano numeru na SIM
`               ------------------
JR @NoZro                   `hop -> nieznany
`------------------------
`
`3/4 SMS czyli sprawy związane z odbiorem/wysłaniem/nie wysłaniem/zapisem SMSów
`      wszystkie krótkie -> realizowane są w @InAk2, jedynym
`      długim jest informacja o odebraniu SMSa ->podkod #02
` trwa: max +180tkt
LD A,B               @#0214 `analizuj informację o SMSie odebranym /wysyłanym 
`                                                       /zapisywanym/ kasowanym
SUB #0E                     `oblicz podkod
CP #02              `(#10)  `długi -> podkod #02
JR Z,@SvPkd                 `już +37tkt hop -> zapisz -> odebrano właśnie SMSa
ADD A,#09                   `
CP #03              `(#08)  `
JR Z,@SvPkd                 `hop -> odczytano SMS,
SUB #DD                     `oblicz podkod
CP #20              `(#02)  `
JR Z,@SvPkd                 `już +61tkt hop -> wysłano SMSa
CP #21              `(#03)  `
JR Z,@SvPkd                 `już +78tkt hop -> nie wysłano SMSa
CP #23              `(#05)  `
JR Z,@SvPkd                 `już +95tkt hop -> zapisano SMSa do SIM
`CP #24              `(#06)  `
`JR Z,@SvPkd                 `już +112tkt hop -> nie zapisano SMSa do SIM
SUB #03                     `oblicz podkod
CP #26              `(#0B)  `
JR Z,@SvPkd                 `już +136tkt hop -> skasowano SMSa z SIM
ADD A,#04                   `
CP #28              `(#09)  `
JR Z,@SvPkd                 `hop -> brak SMSa na tej pozycji
JR @NoZro            @__NzR `hop -> nieznany
`------------------------
`
`5    sprawy związane z czasem
`     krótkie
`trwa +588tkt
`     (#868F) <- sekundy (#00-#3B)                 
`     (#8690) <- minuty  (#00-#3B)                 
`     (#8691) <- godziny (#00-#17)                 
`     (#8692) <- dni miesiąca (#00 - #1E)          
`     (#8693) <- miesiące nasze:[#00 - #0B]        
`                         /#00 to styczeń, #0B to grudzień/
`     (#8694) <- lata           (#05 = 2005r)      
LD A,B                @#11__ `analizuj informację związaną z zapisem/odczytem czasu
CP #63                       `
JR NZ,@nSprC                 `+12+ hop -> inny niż 'odczytano czas z NOKIA'
LD A,(#80C8)                 `długość ramy
CP #0F                       `#0F to długość ramy z czasem, krótsza uznajemy że bez czasu
LD HL,#802E                  `szybciej i taniej
LD A,#0D                     `DKrok zapisz czas do NOKIA
LD (HL),A                    `zapisz DKrok
JR NZ,@__NzR                 `hop -> zła rama z czasem
`LD A,#0E                     `DKrok zapisz alarm do NOKIA
`LD (HL),A                    `zapisz DKrok
LD BC,#8694                  `docelowy adres roku
LD L,#D2 `LD HL,#80D2                  `+493tkt tutaj odczytano czas
LD A,(HL)                    `rok ZAKODOWANY
AND #3F                      `zgaś bity 7 i 6
LD (BC),A                    `odkoduj i zapamiętaj
DEC C                       `
LD E,A                       `rok
INC L                       `
LD A,(HL)                    `miesiąc
DEC A                        ` teraz #00...#0B
LD (BC),A                    `zapamiętaj
DEC C                       `
CP #0C                       `
JR NC,@__NzR                 `+12+43 hop -> miesiąc >&12 nieznany
PUSH BC                      `
PUSH HL                      `zachowaj
CALL @DmArE                  `+17+149 w Acc wychodzi liczba dni w miesiącu A roku E
POP HL                       `odtwórz
POP BC                       `
`       (0..&30)             `
INC A  `( do&31)             `
LD E,A                       `max. liczba dni +1
INC L                        `
LD A,(HL)                    `dzień
DEC A                        `teraz 0...&30
CP E                         `
LD (BC),A                    `zapamiętaj
DEC C                       `
JR NC,@__NzR                 `+12+43 hop -> dzień >max -> nieznany
INC L                        `
LD A,(HL)                    `godzina
LD (BC),A                    `zapamiętaj
DEC C                       `
CP #18                       `
JR NC,@__NzR                 `+12+43 hop -> godzina >&23 nieznany
INC L                       `
LD A,(HL)                    `minuta
LD (BC),A                    `zapamiętaj
DEC C                       `
CP #3C                       `
JR NC,@__NzR                 `+12+43 hop -> minuta >&59 nieznany
INC L                        `
LD A,(HL)                    `sekunda
LD (BC),A                    `zapamiętaj
CP #3C                       `
JR NC,@__NzR                 `+12+43 hop -> sekunda >&59 nieznany
LD A,#63                     `
` #00=< rok =< #3F
` #00=< miesiąc =<#0B
` #00=< liczba dni =<max w miesiącu
`   nie znamy dnia tygodnia  
` godzina =<&24              
` minuta =<&60               
` sekunda =<&60              
LD (#80C7),A          @SvPk3 `+12++++++++++++24tkt zapisz podkod odczytu sieci/LAC/CID
` ************* ++++++++++++++++tkt!
LD A,#02                     `
LD (#801C),A                 `
` ************* przyspieszenie odczytu po starcie systemu
RET                          `
CP #61                @nSprC `
JR Z,@SvPk3                  `hop -> potwierdzenie zapisu czasu do NOKIA
CP #6C                       `
JR Z,@SvPk3                  `hop -> potwierdzenie ustawienia alarmu
JP @NoZro                    `hop -> nieznany xxl
`--------------------------
`6    sprawy związane z siecią i lokalizacją LAC/CID
`trwa: +277tkt
LD A,B               @#0A__ `analizuj komunikat sieci i bieżącej lokalizacji LAC i CID
CP #71                      `bez generacji podkodu, robi się w krótkich tylko
JR NZ,@__NzR                `+12+43 hop -> tu nieznany kod
LD A,(#80C8)                `długość ramy
CP #13                      `sprawdź długość ramy
JR NZ,@__NzR                `+12+43 hop -> tu nieznana długość
LD HL,(#80D7)               `
LD A,H                      `
OR L                        `Acc=0 to brak 2bajtów pierwszych numeru kraju 0260 to PL
LD E,L                      `\
LD D,H                      `/do DE
LD HL,(#80D9)               `
OR H                        `\czy jest numer sieci 0200 to Era
OR L                        `/
JP Z,@NoZro                 `+10+31 brak sieci (cztery bajty =#00), ale rama zrozumiała
`     tu jest sieć, więc ją zapamiętaj
LD (#8054),HL               `...zapisz aktualną sieć (#02#00 to Era)
EX DE,HL                    `
LD (#8052),HL               `zapisz aktualny kod kraju sieci... (#02#60 to PL)
`#804E -> 2b CID      \     `
`#8050 -> 2b LAC      |sieć i lokalizacja telefonu
`#8052 -> 4b SIEĆ GSM /     `
LD HL,(#80D3)               `\
LD (#804E),HL               `/zapisz aktualny CID
LD HL,(#80D5)               `\
LD (#8050),HL               `/zapisz aktualny LAC
LD HL,#0000                 `\zeruj
LD (#804C),HL               `/zeruj czas ustalenia pozycji
`#804C -> 2b czas, jaki upłynął od lokalizacji telefonu
`   #804C -sekundy \        `
`   #804D -minuty  /cykany przez time+ do wartości minut #F0, później stoi
LD A,#42                    `ten kod nie jest już analizowany, można sobie podarować...
JR @SvPk2                   `
`------------------------
`     sprawy związane z IMEI i LEVEL_GSM
`     krótkie -> realizowane całkowicie w @InAk1 i @InAk2
`trwa: +610tkt
LD A,B               @#04__ `tkt analizuj komunikat LEVEL / IMEI
CP #04                      `czy IMEI?
JR Z,@_IMEI                 `+12+587tkt hop -> IMEI
CP #02                      `czy LEVEL?
````JR Z,@Level                 `hop -> poziom sygnału
JR NZ,@#NoZr                `hop -> niezrozumiały
`... przechodzi do @Level ...
`----------------------------
` odebrano poziom sygnału GSM (chyba)
`#1F #1D #00 #04 #00 #09 #01 #08 #00 #02 #03 #00 #63 #02 #04 _ID XOR
`trwa: +212tkt               
LD A,(#80C8)         `@Level `długość ramy
CP #09                      `sprawdź długość ramy
JR NZ,@#NoZr                `hop -> tu nieznana rama
LD A,(#80CF)                `
CP #63                      `sprawdzenie
JP NZ,@NoZro         @#NoZr `hop -> tu nieznana rama
LD DE,#80CD                 `
LD HL,#8056                 `
LD A,(DE)                   `
LD (HL),A                   `zapisz aktualny poziom naładowania akumulatora?
INC DE                      `
INC HL                      `
LD A,(DE)                   `
LD (HL),A                   `zapisz aktualny poziom sygnału GSM
LD (#80B2),A                `i pomocniczy poziom też zapisz
INC DE                      `
INC DE                      `
INC DE                      `
INC HL                      `
LD A,(DE)                   `
LD (HL),A                   `zapisz aktualny poziom czegoś tam? może temp. baterii?
LD A,#41                    `
JR @SvPk2                   `->10+24tkt zapisz podkod odczytu LEVEL_GSM
`------------------------
` odebrano IMEI i dane o telefonie
`      #1F #1D #00 
`#80C6:#04 #00 #2E #01 #08 #00 #04 #01 
`#80CE:#34 #34 #39 #32 #30 #39 #32 #30 #31 #36 #36 #38 #35 #32 #38 #00 
`#80DE:#4E #53 #45 #2D #31 #00 
`#8693:#30 #35 #30 #32 #35 #36 #32 #00 
`#80EC:#34 #32 #33 #30 #00 
`#80F1:#30 #35 #2E #32 #38 #00 ID XOR
`
`trwa +587tkt max
LD DE,#80CD          @_IMEI `
LD A,(DE)                   `
INC E   `INC DE             `
DEC A                       `sprawdzenie, tu powinno być #01 czyli teraz #00
LD HL,#80DD                 `
OR (HL)                     `tu powinno być #00
`tutaj mamy zawsze NC i Z gdy OK i NZ gdy error
LD (HL),#30                 `kod zera /żeby nie było błędu przy kompresji/
LD L,E                      `#80CE <- tu przesyłamy, 
`LD H,D                     `są równe
CALL Z,@ZIPek               `+17+473tkt pomocnicza kompresująca IMEI
JP NC,@NoZro                `error
LD A,#40                    `podkod IMEI
LD (#80C7),A         @SvPk2 `+24tkt to samo co @SvPkd, tyle że brak nam czasu
RET                         `
`-----------------------------------
`
`od początku przerwania minęło 256tkt
`trwa: +714tkt max
LD A,(#80C7)          @InAk1 `drugie wspólne przerwanie dla krótkich i długich realizacji
LD HL,#802E                  `adr. DKroku
CP #23                       `                  
JP Z,@_#23_                  `+703=+40+663 hop -> /potwierdzenie zapisu SMSa do SIM/
CP #40                       `        
JP Z,@_#40_                  `+622=+57+575 hop -> /odebrano IMEI oraz dane o telefonie/
CP #63                       `        
JP Z,@SMSd4                  `+615=+64+551 hop -> /odczytano czas z NOKIA/
`   to powyższe oblicza dzień tygodnia dla zdekodowanej już daty
LD HL,#80CD                  `adr. komórki ID przych. ramy poł. w mbus
LD DE,#86A8                  `adr. MakeCall
LD BC,#86C0                  `adr. ID bieżącego połączenia
CP #11                       `                         
JP Z,@_#11_                  `+714=+111+602 hop -> w drugim zaczyna dzwonić
CP #12                       `                         
JP Z,@_#12_                  `+524=+128+396 hop -> rozpoczęto rozmowę
CP #13                       `                  
JP Z,@#1319                  `+377=+145+232 hop -> błąd/odrzucenie/zakończenie rozmowy przez drugi
CP #19                       `                  
JP Z,@#1319                  `+394=+162+232 hop -> odrzucenie/zakończenie rozmowy przez NOKIA
CP #1F                       `                  
JP Z,@_#1F_                  `+244=+179+65 hop -> potwierdzenie otrzymania numeru na mbus
LD HL,#84EE                  `adr. kom managera tworzenia i nadawania SMSów
CP #20                       `                  
JP Z,@_#20_                  `+444=+206+238 hop -> /wysłano SMSa/
CP #21                       `                            
JP Z,@_#21_                  `+336=+223+113 hop -> /nie wysłano SMSa/
LD HL,#802E                  `adr. DKroku  
CP #28                       `                  
JP Z,@_#28_                  `+376=+250+126 +++++++++++++! hop -> /brak SMSa na tej pozycji na SIM/
CP #26                       `                            
JP Z,@_#26_                  `+349=+267+82 hop -> /potwierdzenie skasowania SMSa/
CP #61                       `                  
JP Z,@_#61_                  `+340=+284+56 hop -> /potwierdzenie zapisu czasu do NOKIA/
CP #6C                       `                  
JP Z,@_#6C_                  `+365=+301+64 hop -> /potwierdzenie ustawienia alarmu/
CP #03                       `                  
JP Z,@03030                  `+475=+318+157 hop -> /dla DKroku konfigu profilaktycznie 
`                               zwiększa falstarty gdyby zamiast SMSa konfigu był inny SMS/
`CP #24                      `                    
`JP Z,@_#24_                 `hop -> /nie zapisano SMSa do SIM/
CP #32                      `       
JP Z,@_#32_                 `hop -> /potwierdz. wykon. op. na ks.tel. na SIM zap./skas. poz./
`CP #33                      `       
`JP Z,@_#33_                 `hop -> /potwierdz. wykon. op. na ks.tel. na SIM zap./skas. poz./
`CP #41                      `       
`JP Z,@_#41_                 `hop -> /analiza poziomu GSM?/
`CP #42                      `       
`JP Z,@_#42_                 `hop -> /odebrana ramka sieci GSM/
CP #30                       `czy to brak zapisu w tej pozycji ks.tel =pusta pozycja?
RET NZ                       ` -> długie ramki i inne ;o)
`              tutaj -> /brak zapisu w tej pozycji -pusta pozycja/
SUB A                        `więc na znak tego...
LD (#8080),A                 `...kasuj krotność
LD (#807A),A                 `...kasuj czas oczekiwania na kom ks.tel.
JP @SpdRT                    `
`------------------------
`                        
LD A,(#802E)                @_#32_ `/potwierdz. wykon. op. na ks.tel. na SIM 
`                                                       zapisano/skasowano pozycję)/
` sprawdzamy czy DKrok jest taki, że zapisujemy zapalone 7bity
CP #08                             `
RET NZ                             `ret -> inny DKrok, nic nie rób
LD A,(#804B)                       `zapamiętaj pozycję z tabeli #8502 do wyzerowania 7bitu
`DEC A                              `/bo zakres #01..#08 a ma być #00..#07/
LD HL,#8502                        `\
ADD A,L                            ` |bez przełomu
LD L,A                             `/
LD A,(HL)                          `\
AND #7F                            ` |zeruj 7bit
LD (HL),A                          `/
RET                                `
`------------------------
`                        
`RET                         @_#33_ `/nie zapisano/skasowano pozycji z ks tel)/
`------------------------
`
`druga część otrzymanego IMEI
`trwa: +575tkt
LD A,(#80C8)          @_#40_ `
CP #2E                       `sprawdź długość ramy: CY error, NC gut
CCF                          `CY gut, NC error
LD HL,#80D6                  `
LD DE,#80D2                  `tu przesyłamy, aby w przypadku błędu nie bruździć w istniejącym IMEI
CALL C,@ZIPek                `+17+473tkt pomocnicza kompresująca IMEI
JP NC,@NoZro                 `hop -> tu zła długość ramy lub error w IMEI
`LD HL,#802E                  `adr.DKroku
`LD A,(HL)                    `odczytaj DKrok
`AND A                        `czy =0?
`RET NZ                       `hop bo nie żądałeś IMEI, więc nie cykaj DKroku
LD A,#03                     `\
LD (#802E),A                 `/Dkrok na kolejny
RET                          `
`------------------------
`                                
`potwierdzenie zapisu czasu do NOKIA
`trwa: +56tkt
`LD HL,#802E już jest
LD A,(HL)             @_#61_ `
CP #0C                       `czy DKrok <#0C ?
RET C                        `tak, mniejszy
CP #0E                       `czy DKrok >=#0E ?
RET NC                       `tak, #0E lub większy
LD A,#0E                     `INC(DKrok)
LD (HL),A                    `zapisz
RET                          `
`---------------------------------
`                               
`potwierdzenie ustawienia alarmu
`trwa: +64tkt                   
`LD HL,#802E już jest
LD A,(HL)             @_#6C_ `
CP #0E                       `czy DKrok =#0E ?
RET NZ                       `inny
LD A,#FF                     `DKrok`u koniec ;o)
LD (HL),A                    `
LD A,#C0                     `dwa razy C, krótko z krótką przerwą
LD (#8049),A                 `wciśnij
RET                          `
`----------------------------------------------
`
`trwa: +718tkt 
LD A,(#80C7)          @InAk2 `trzecie wspólne przerwanie dla krótkich i długich 
LD HL,#802E                  `
CP #23                       `                  
JP Z,@#23_5                  `+718=+40+678 hop -> /potwierdzenie zapisu SMSa do SIM/
CP #40                       `       
JR Z,@#40_3                  `+620=+59+561 hop -> /odebrano IMEI oraz dane o telefonie/
CP #63                       `       
`JR Z,@#63_3                 `+481=+73+408 hop -> /odebrano czas z NOKIA/
RET NZ                       `
`...przechodzi...             
`----------------------------------------------
`
`ustawianie czasu z NOKIA     
`trwa: +408tkt                   
LD HL,#8694           `@#63_3 `adr. roku z NOKIA
LD DE,#8009                  `adr. roku systemu
LD A,(HL)                    `
CP #05                       `
JP C,@NoZro                  `hop -> nie ustawiamy -obejdź ustawianie
LD A,(#8001)                 `Status Time
AND A                        `czy StatusTime=0?
RET Z                        `ustawiamy, bo StatusTime=0
CP #02                       `
`   CY =sprawdź czy nie uwcześni
`   NC =nie ustawiaj!          
`  DE= adr. roku aktualnego czasu z systemu
`  HL= adr. roku czasu z telefonu NOKIA
CALL C,@CpTim                `+17+277tkt /sprawdza tylko gdy StatusTime =1/
`  CY gdy (HL) jest bardziej zaawansowany od (DE) lub -> trzeba ustawić
`  NC gdy odwrotnie lub gdy równe -> nie ustawiać!
JP NC,@NoZro                 `hop -> nie ustawiać
RET                          `
`----------------------------------------------
`                               
`kolejny etap pozyskiwania numeru IMEI i opisu
`trwa: +561tkt               
LD HL,#80DE           @#40_3 `przeładuj opis danych telefonu do RAM
LD DE,#8061                  `
LD BC,#0019                  `=&25
LDIR                         `
RET                          `zrobiono
`----------------------------------------------
`                               
`od pocz. przerwania minęło 260tkt
`trwa +260tkt max
LD A,(#80C7)          @InAk3 `czwarte wspólne przerwanie dla krótkich i długich realizacji
CP #63                       `       
JR Z,@#63_4                  `+235=+32+203 hop -> /odebrano czas z NOKIA/
CP #40                       `        
`JR Z,@#40_4                 `+243=+39+231tkt hop -> IMEI
RET NZ                       `
`...przechodzi dla #40...     
`--------------------------------------
`                               
`prześlij 8 bajtów skompresowanego IMEI z zerem na końcu
`trwa: +231tkt +++++++          
LD HL,#80CE           `@#40_4 `
LD DE,#8059                  `
LD BC,#0008                  `
LDIR                         `8*21-5+41=204tkt
DEC DE                       `
LD A,(DE)                    `
OR #F0                       `
LD (DE),A                    `
LD A,#02              @SpdRT `
LD (#801C),A                 `przyspieszenie odczytu po starcie systemu
RET                          `
`--------------------------------------
`                               
`ustawianie zegara systemu z zegara NOKIA
`trwa: +203tkt  +17tkt
LD HL,#868F           @#63_4 `adr. sekund SMSa
LD DE,#8004                  `adr. sekund systemu
LD BC,#0007                  `7 -bo DT też
LDIR                         ` 142tkt=7*21-5
LD A,#02                     `\
LD (#8001),A                 `/zapisz że ustawiony z zegara NOKIA
SUB A                        `+00h poprawki godzin przy ich przeskoku
LD (#86F5),A                 `
RET                          `zrobiono
`-------------------------------
`                               
`procedura wykonuje kroczek w czasie wolnym
`przeznaczonym dla @nokia
`tworzy &16 znaków daty i czasu z zegara systemu
`trwa max: +82tkt + to co w @krASt /oczywiście wcześniej @nokia/
LD HL,#86C1             @freTi `
LD A,(HL)                      `
CP #05                         `ograniczenie czy nie poza zakresem
JR NC,@poINh                   `
INC (HL)                       `incknij kroczek
LD HL,@krASt                   `
ADD A,A                 @jp(hl `+54tkt+...to co wykonuje
LD E,A                         `
LD D,#00                       `
ADD HL,DE                      `
LD A,(HL)                      `
INC HL                         `
LD H,(HL)                      `
LD L,A                         `
JP (HL)                        `
`---                            
LD A,(#8001)            @poINh `minęło +36tkt + to co w @nokia, 
`#8001 -> 1b status TIME:  
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA (może być zły)
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno
`                      #04-ustawiony z delivery niedawno
`                      #05- ...i więcej to pewnie ustawiony
AND A                          `
LD B,#04                       `bit System Statusu dla nieustawionego zegara
JR Z,@bzZeg                    `
CP #03                         `
LD B,#00                       `bit System Statusu dla zegara ustawionego poprawnie
JR NC,@bzZeg                   `
LD B,#02                       `bity System Statusu dla zegara ustawionego ale źle
LD HL,#80AD             @bzZeg `
LD A,(HL)                      `
AND #F9                        `czyli procedura wpłynie tylko na bity 1 i 2
OR B                           `
LD (HL),A                      `
LD B,#04                       `
RLCA                    @QWPOL `znacznik do CY
JR C,@ALSDF                    `hop =1 to aktywny znacznik
RLCA                           `znacznik do CY
JR C,@ALSDF                    `hop =1 to aktywny znacznik
DJNZ @QWPOL                    `
LD A,#04                @ALSDF `na wynik
SUB B                          `
`#00 świeci ciągle             (b.źle)
`#01 b.szybko mruga            (źle) 
`#02 szybko mruga              (kiepsko)
`          #03 średnio mruga             (znośnie)
`#04 wolno mruga               (dobrze)
`#05...i więcej zgaszona       (b.dobrze)
CP #03                         `
LD HL,#80C5                    `
LD (HL),A                      `zapisz StatusSystemu
RET C                          `
INC A                          `
LD (HL),A                      `zapisz StatusGSM 
RET                            `
`-------------------------------
`                               
`kroczki procedurek wykonujących ASCII daty i czasu zegara w czasie @nokia
DEFETYK @krASt `
DEFTABE mASm0  `+387tkt=82+305
DEFTABE mASm1  `+469tkt=82+387
DEFTABE mASm2  `+431tkt=82+349
DEFTABE mASm3  `+291tkt=82+209
DEFTABE mASmL  `+464tkt=82+382
`-------------------------------
`                               
`procedura w kroczku wykonująca ASCII roku
`chyba że StatusTime=0 to wtedy cały napis '-nieznany-'
`trwa: +305tkt
LD HL,#86C2             @mASm0 `adr. roboczy ekran
LD DE,#8001                    `
LD A,(DE)                      `
AND A                          `
JR NZ,@ZnaNy                   `+12+262tkt 
EX DE,HL                       `+260tkt
LD HL,@NoTim                   `
LD BC,#000A                    `
LDIR                           `=205tkt
LD A,#02                       `\
LD (#86C1),A                   `/przeskocz kroczkiem dalsze tworzenie daty
RET                            `
CP #03                  @ZnaNy `+262tkt
LD A,#32                       ` '2'
JR NC,@niePw                   `
LD A,#3F                       ` '?'
LD (HL),A               @niePw `zapisz pierwszy znak roku
INC L                          `
LD A,#30                       ` '0'
LD (HL),A                      `zapisz drugi znak roku
INC L                          `
LD A,(#8009)                   `rok
CP #64                         `
JP C,@ASC99                    `+10+171tkt wywal ASCII roku dwie cyfry z Acc
RET                            `
`-------------------------------
`                               
`procedura tworzy dalszą część daty, tzn miesiąc i dzień i dzień tygodnia
`trwa:+387tkt
LD HL,#86C6             @mASm1 `adr. roboczy ekran+4
LD DE,#8008                    `miesiąc
LD A,(DE)                      `
INC A                          `bo zakres #00-#0B -> 1-&12
CP #0D                         `zabezpieczenie aby nie za długi czas
CALL C,@ASC59                  `+17+85
DEC E                          `
LD A,(DE)                      `dzień miesiąca
INC A                          `bo zakres #00-#1E -> 1-&31
CP #20                         `zabezpieczenie aby nie za długi czas
CALL C,@ASC59                  `+17+125
LD A,(#800A)                   `dzień tygodnia
LD DE,@NaDnT                   `
ADD A,A                        `
ADD A,E                        `
LD E,A                         `
LD A,(DE)                      `
LD (HL),A                      `
INC L                          `
INC E                          `
LD A,(DE)                      `
LD (HL),A                      `
RET                            `
`-------------------------------
`                               
`procedura tworzy ASCII godziny i minuty
`trwa:+349tkt                   
LD HL,#86CC             @mASm2 `adr. roboczy ekran+#0A
LD DE,#8006                    `godziny
LD A,(DE)                      `
CP #18                         `zabezpieczenie aby nie za długi czas
CALL C,@ASC59                  `+17+105
DEC E                          `
LD A,(DE)                      `minuty
CP #3C                         `zabezpieczenie aby nie za długi czas
JP C,@ASC59                    `+10+165
RET                            `
`-------------------------------
`                               
`procedura tworzy ASCII sekund  
`trwa:+209tkt                   
LD HL,#86D0             @mASm3 `adr. roboczy ekran+#0E
LD DE,#8004                    `sekundy
LD A,(DE)                      `sekundy
CP #3C                         `zabezpieczenie aby nie za długi czas
JP C,@ASC59                    `+10+165
RET                            `
`-------------------------------
`                               
`procedura przesyła skomponowaną właśnie
`linijkę &16 znaków daty i czasu do jej właściwego miejsca
`trwa: +382tkt ++++++                 
LD HL,#86C2             @mASmL `
LD DE,#800B                    `
LD BC,#0010                    `
LDIR                           `
LD HL,#8000                    `
RES 0,(HL)                     `
RET                            `
`-------------------------------
`                               
`pomocnicza, zamienia wartość Acc na dwa bajty ASCII
`zapisane do (HL), 
`@ASC99 trwa max dla Acc: 0-&99: +171tkt
`@ASC59              Acc: 0-&59: +165tkt
`@ASC59              Acc: 1-&31: +125tkt
`@ASC59              Acc: 0-&23: +105tkt
`@ASC59              Acc: 1-&12:  +85tkt
` poniżej zakres dla Acc:0-&99  
SUB #32                 @ASC99 `
JR C,@maleA                    `
LD BC,#340A                    `
JR @inc_b                      `
ADD A,#32               @maleA `
` poniżej zakres dla Acc:0-&58  
LD BC,#2F0A             @ASC59 `
INC B                   @inc_b `
SUB C                          `
JR NC,@inc_b                   `
ADD A,#3A                      `
LD (HL),B                      `
INC L                          `
LD (HL),A                      `
INC L                          `
RET                            `
`-------------------------------
`                               
`====================================================
`=          ANALIZA KSIĄŻKI TELEFONICZNEJ           =
`====================================================
`
`sprawdza czy bajt (HL) zawiera dwie cyfry numeru telefonicznego /lub IMEI/
`o poprawnych wartościach      
`wyjście CY =ok, NC =error     
`trwa /poza NMI/
LD A,(HL)              @sprAc `
AND #0F                       `
CP #0A                        `
RET NC                        `
LD A,(HL)                     `
RLCA                          `
RLCA                          `
RLCA                          `
RLCA                          `
AND #0F                       `
CP #0A                        `
RET                           `
`------------------------------
`
`sprawdza numer telefoniczny zaczynający się od adresu HL
` czyli liczba cyfr w (HL) pod względem poprawności dla systemu, tj:
` sprawdza zakres cyfr, ew. uzupełnienie o #F0 i czy pozostałe są =#00
` wyjście CY =ok, NC =error    
`trwa /poza NMI/
LD E,L                 @ChkNT `
LD D,H                        `
LD A,(HL)                     `
CP #04                        `
CCF                           `
RET NC                        `/NC/ ->error
CP #15                        `
RET NC                        `/NC/ ->error
AND A                         ` musi być, aby CY nie wszedł na 7bit Acc!
RRA                           ` div 2
LD B,A                        `\ tyle bajtów zawiera TYLKO PARY cyfr!
LD C,A                        `/
INC HL                        `teraz adr. pierwszej pary cyfr
CALL @sprAc            @nxPAN `sprawdź
RET NC                        `/NC/ ->error
INC HL                        `
DJNZ @nxPAN                   `
LD A,(DE)                     `liczba cyfr
RRA                           ` div 2, jeśli nieparzysta l.cyfr to CY
JR NC,@no#Fx                  `hop -> parzysta, nie sprawdzamy #Fx
`                              nieparzysta, czyli trzeba sprawdzić #F0 i cyfrę
INC C                         `sprawdzonych +1 (bo teraz sprawdzisz jeszcze jeden)
LD A,(HL)                     `to co chcemy sprawdzić 
AND #0F                       `
CP #0A                        `
RET NC                        `/NC/ ->error
LD A,(HL)                     `to co chcemy sprawdzić ->uzupełnienie #F0
AND #F0                       `
CP #F0                        `
SCF                           `
CCF                           `NC
RET NZ                        `/NC/ ->error
INC HL                        ` ->zaczynamy od cyfry
LD A,#0A               @no#Fx `tyle wszystkich bajtów z cyframi
SUB C                         ` odejmij liczbę już sprawdzonych bajtów
SCF                           `
RET Z                         `/C/ -> ok, sprawdzono cały numer =>poprawny!
LD B,A                        `tyle bajtów sprawdź
LD A,(HL)              @nx00b `odczytaj bajt
AND A                         `czy =0?
RET NZ                        `/NC/ ->error
INC HL                        `adr. next bajtu
DJNZ @nx00b                   `
SCF                           `
RET                           `/C/ -> ok, sprawdzono cały numer =>poprawny!
`------------------------------
`  #858B: 1b + #858C-#8595 &10b numer 3 ('1' dla użytkownika) |uzupełniona o #F0
`  #8596: 1b + #8597-#85A0 &10b numer 4 ('2' dla użytkownika) |a po niej same zera!!!
`  #85A1: 1b + #85A2-#85AB &10b numer 5 ('3' dla użytkownika) |
`  #85AC: 1b + #85AD-#85B6 &10b numer 6 ('4' dla użytkownika) |jeśli jakaś pozycja zawiera
`  #85B7: 1b + #85B8-#85C1 &10b numer 7 ('5' dla użytkownika) |długość =0 
`  #85C2: 1b + #85C3-#85CC &10b numer 8 ('6' dla użytkownika) |to traktujemy ją jako pustą
`  #85CD: 1b + #85CE-#85D7 &10b numer 9 ('7' dla użytkownika) |
`
`sprawdza poprawność zapisów numerów tel jawnych 1-8,
` jeśli błąd to kasuje całą książkę telefoniczną jawną
` wyjście NC =error, CY =poprawnie
`trwa /poza NMI/
LD HL,#858B            @TELch `
LD B,#07                      `
PUSH BC                @nxNRc `
PUSH HL                       `
CALL @ChkNT                   `
` wyjście CY =ok, NC =error   `
POP HL                        `
POP BC                        `
JR NC,@resKT                  `/NC/-> error
LD DE,#000B                   `
ADD HL,DE                     `
DJNZ @nxNRc                   `
SCF                           `
RET                           `/CY/->poprawne
`---                           
`trwa +268tkt max              
LD B,#07               @resKT `ile numerów znanych (0 i 1 zaraz stworzę, 2 jest w konfigu)
LD HL,#858B                   `adr. tabeli znanych numerów
LD DE,#000B                   `długość jednego zapisu w tej tabeli
LD (HL),D              @NepKT `zeruj liczbę znaków
ADD HL,DE                     `next adres
DJNZ @NepKT                   `zrób next zapis 212tkt =7*(31)-5
AND A                         `/NC/ ->error
RET                           `
`---------------
DEFETYK @Ikste
`  przebieg rozpoznania przydatności i zapisu numeru z książki telefonicznej
`  wejście -> rama z NOKIA
DEFTABE KTIa1           `#05 +212tkt czy czekamy, czy liczba znaków >0 czy plus,
DEFTABE KTIa2           `#06 +588tkt uzupełnianie numeru zerami
DEFTABE RARB4           `#07 +606tkt kompresuje 8 znaków CHAR$ na 4 bajty
DEFTABE RARB4           `#08 +606tkt kompresuje 8 znaków CHAR$ na 4 bajty
DEFTABE RARB2           `#09 +414tkt kompresuj 4 znaki i uzupełnia ostatni #F0
DEFTABE KTIa3           `#0A +293tkt zamienia 5 pierwszych na wielkie litery
DEFTABE KTIa4           `#0B +514tkt porównuje opis
DEFTABE KTIa5           `#0C +470tkt przepisuje numer do znanych
DEFTABE KTIa6           `#0D +426tkt tylko dla prefixu -przepisz...
DEFTABE KTIa7           `#0E +430tkt tylko dla centrumSMS -przepisz...
DEFTABE KTIa8           `#0F +460tkt sprawdza czy znane są już wszystkie numery znane
DEFTABE KTIaR           `#10 rabowanie numerów
`
`tablica poszukiwanych w książce opisów:
DEFETYK @opisT `
DEFBAJT1 #54 #45 #4C #45 #46 #4F #4E  `TELEFON 
DEFETYK @opisA `
DEFBAJT1 #54 #45 #4C #45 #46  `TELEF `
DEFBAJT1 #43 #45 #4E #54 #52  `CENTR `
DEFBAJT1 #50 #52 #45 #46 #49  `PREFI `
`   poszczególne pozycje MUSZĄ! się różnić pierwszym znakiem!!!
`      opis w tabeli rozpoznawalnych nie może zawierać znaków o kodach 
`      powyżej małych liter ani #20 mniejszych!!!
`----------------------------
`jeśli komunikat z NOKIA że pozycja jest pusta to wykonaj tylko 
`                              
`#1F #1D #00 #03 #00 #26 #01 #08 #00 #02 #00+
`+#08 #33 #4B #4E #4F #57 #4E #4B #49+
`+#15 #2B #34 #38 #31 #32 #33 #34 #35 #36 #37 #38 #39 #30 #31 #32 #33 #34 #35 #36 #37 #38+
`+#00 #00+                    
`+_ID XOR                        
`
`czy czekamy, czy liczba znaków >0 czy plus, 
`trwa +212tkt max
LD A,(#807A)        @KTIa1 `cykający w dół czas oczekiwania na poz. z ks.tel
AND A                      `czy go żądałeś (bo wtedy tylko pamiętamy pozycję SIM)
JP Z,@OkZro                `+10+31tkt -> hop koniec analizy, kasuj komunikat i wyjdź z InAnalizy
LD HL,#80CE                `adres początku opisu
LD E,(HL)                  `\
INC E                      `|odczytaj liczbę znaków opisu i zwiększ ją o 1
LD D,#00                   `/
ADD HL,DE                  `po zsumowaniu mamy adres liczby znaków numeru
LD A,(HL)                  `liczba znaków numeru
AND A                      `czy zero znaków?
JP Z,@InPKT                `+10+71tkt hop -> zerowa długość numeru
LD C,A                     `zapamiętaj liczbę znaków numeru
INC HL                     `adr. początku numeru
LD A,(HL)                  `pierwszy znak
CP #2B                     `sprawdzamy czy to + ?
JR NZ,@KT001               `hop -> nie"+"
DEC C                      `zmiejsz o 1 liczbę znaków bo '+' !
JP Z,@InPKT                `+10+71tkt hop -> zerowa długość numeru
INC HL                     `przeskocz '+'
LD (#80C8),HL       @KT001 `+74tkt i zapisz adres znaków ASCII numeru z książki
LD DE,#80A1                `adres, na który kompresować numer ASCII,
LD (#81C5),DE              `zapamiętaj
DEC DE                     `
LD A,C                     `odtwórz liczbę znaków
LD (DE),A                  `zapamiętaj liczbę znaków
RET                        `
`-------------------------------------------
`                           
`uzupełnianie numeru zerami 
`trwa: +588tkt (max dla 1-cyfrowego numeru)
LD HL,(#80C8)       @KTIa2 `adres znaków numeru
LD A,(#80A0)               `liczba znaków
LD C,A                     `
LD B,#00                   `BC=wartość równa liczbie znaków numeru
LD A,#14                   `= &20 tyle max. może być cyfr
SUB C                      `wynik to liczba zer do dopisania
RET Z                      `ret -> nie dopisuj zer bo to &20 znaków
JP C,@OkZro                `hop -> za długi numer, ERROR
ADD HL,BC                  `obl. adres od którego dopisywać zera #30
LD B,A                     `wartość równa liczbie zer do dopisania /max #13/
LD A,#30                   `kod CHAR$ zera
LD (HL),A           @KTneZ `(7+6+13)*19-5=489
INC HL                     `następny znak
DJNZ @KTneZ                `następny 
RET                        `
`-----------------------------------------
`                           
`kompresuje 8 znaków CHAR$ na 4 bajty
`trwa:+606tkt                
CALL @RARb4         @RARB4 `
RET C                      `
JP @OkZro                  `
`-----------------------------------------
`                           
`kompresuje 4 znaki CHAR$ na 2 bajty i uzupełnia #F0 ostatni
`trwa:+414tkt                
CALL @RARb2         @RARB2 `
RET C                      `
JP @OkZro                  `
`-------------------------------------------
`                            
`kompresuje 8 znaków CHAR$ na 4 bajty
`wyjście NC=error, CY=oki    
`trwa: +578tkt              
LD DE,(#81C5)       @RARb4 `zapamiętany adres, na który kompresować numer ASCII
LD HL,(#80C8)              `zapamiętany adres numeru ASCII w ramie,
CALL @ZIPek                `+17+473tkt kompresuj 2 znaki ASCII cyfr z (HL) do (DE)
RET NC                     `RET -> error w czasie kompresji (np. zła cyfra)
LD (#80C8),HL              `adres przed numerem ASCII w ramie 
`                           (o wartości równej liczbie znaków numeru -już po pominięciu plusa)
LD (#81C5),DE              `adres, na który kompresować numer ASCII,
RET                        `
`------------------------------
`                            
`pomocnicza do kompresji, (też IMEI)
`zamienia 8 bajty z zakresu #30-#39 na 1 bajt dwucyfrowy
`identycznie jak w skompresowanym numerze SMSa
`wejście (HL) wyjście do (DE)
`wyjście CY -> oki i NC -> error
`trwa 473tkt CY(ok) i mniej gdy NC(źle)
LD B,#04          @ZIPek `
`odtąd trwa  =B *(101+13)-5 + 15 /dla B=4: 464tkt+7, B=2: 238tkt/
LD A,(HL)         @RARek `
INC HL                   `
XOR #30                  `
CP #0A                   `
RET NC                   `NC to error
LD C,A                   ` 
LD A,(HL)                `
INC HL                   `
XOR #30                  `
CP #0A                   `
RET NC                   `NC to error
RRCA                     `
RRCA                     `
RRCA                     `
RRCA                     `
OR C                     `          
LD (DE),A                `
INC DE                   `
DJNZ @RARek              `
SCF                      `CY to oki
RET                      `
`-----------------------------------------
`
`kompresuje 4 znaki CHAR$ na 2 bajty i uzupełnia #F0 ostatni
`wyjście NC=error, CY=oki
`trwa: +386tkt
LD HL,(#80C8)       @RARb2 `zapamiętany adres numeru ASCII w ramie 
LD DE,(#81C5)              `zapamiętany adres, na który kompresować numer ASCII,
LD B,#02                   `
CALL @RARek                `+17+238tkt
RET NC                     `RET -> error w czasie kompresji (np. zła cyfra)
`           wyjście stąd spoko, bo nie zapisano jeszcze liczby cyfr -tak więc znana jest pusta!
LD HL,#80A0                `adres stały, na który skompresowaliśmy ASCII,
`        #80A0- 1b -> faktyczna liczba znaków numeru (bez plusa/zera jeśli był/o)
LD A,(HL)                  `tu liczba znaków numeru
INC HL                     `
RRCA                       `bit0 do flagi CY i /div2
CCF                        `
RET C                      `bit0=0 więc parzysta liczba cyfr-bez uzupełnienia
AND #0F                    `skasuj złe bity, wartość z zakresu #02-#0A
ADD A,L                    `nie będzie CY bo bez przełomu!
LD L,A                     `
LD A,(HL)                  `
OR #F0                     `uzupełnij bardziej znaczącą (a pustą) połówkę!
LD (HL),A                  `
SCF                        `
RET                        `
`-------------------------------------------
`                                    
`zamienia małe litery na wielkie (w pierwszych 5 znakach)
`trwa +293tkt max           
LD HL,#80CE         @KTIa3 `adres początku opisu
LD B,#05                   `tylko 5 pierwszych znaków zamieniamy na duże litery
INC HL              @KT031 `kolejny znak
LD A,(HL)                  `odczytaj znak
CP #61                     `kod małej litery `a`
JR C,@KT032                `hop -> to nie mała litera
`                           opis w tabeli rozpoznawalnych nie może zawierać znaków o kodach 
`                           powyżej małych liter ani #20 mniejszych!!!
SUB #20                    `zamień na dużą 
LD (HL),A                  `zapisz
DJNZ @KT031         @KT032 `kolejny 265=5*(41+13)-5
RET
`--------------------------------------------
`                                    
`rozpoznaje opis pozycji z książki telefonicznej
`trwa +514tkt max
LD DE,#80CE         @KTIa4 `adres początku opisu
LD A,(DE)                  `odczytaj liczbę znaków opisu
CP #06                     `6 znaków to minimalna długość akceptowalnego opisu
JR C,@GoRab                `+12+31tkt hop ->za krótki opis -> zrabuj numer
INC DE                     `DE=adr. pierwszego znaku opisu w mbusie
LD A,(DE)                  `odczytaj 1szy znak opisu z ramy
PUSH DE                    `
LD B,#03                   `tyle wyrazów do sprawdzenia
LD HL,@opisA               `adres pierwszego opisu `TELEF`
LD DE,#0005                `tyle liter ma jeden opis
CP (HL)             @N_opi `porównaj pierwszy znak
JR Z,@KT4i_                `hop -> pierwszy znak T,C lub P
ADD HL,DE                  `adr. next wyrazu
DJNZ @N_opi                `=3*(25+13)-5
LD C,B              @KT4i_ `który to wyraz [#03=telefon, #02=centrum, #01=prefix]
POP DE                     `
LD B,#04                   `porównaj pozostałe 4 znaki
INC HL              @_Nopi `\
INC DE                     `/następny znak
LD A,(DE)                  `odczytaj
CP (HL)                    `porównaj
JR NZ,@GoRab               `hop-> różne a więc rabuj i wyjdź
DJNZ @_Nopi                `następny znak 179=4*(33+13)-5 /DJNZ nie zmienia rejestru F!/
`LD A,#FF                   `=NIE rabuj tego numeru
`LD(#80CD),A                `bez modyfikacji w ramie było tu #00 (rabuj) a teraz oznacza NIErabuj!
LD A,C            `#03=telefon, #02=centrum, #01=prefix, #00=nierozpoznany
AND A                      `
JR Z,@GoRab                `hop-> nierozpoznany opis a więc rabuj i wyjdź
ADD A,#0B                  `suma da kroczek dla centrum i dla prefixu
`                 #0E=telefon, #0D=centrum, #0C=prefix
CP #0E                     `
JR C,@_GRab                `przejdź do kroczku+1: #0D dla centrum i #0C dla prefix
`   tutaj telefon           
INC DE                     `
INC DE                     `
INC DE                     `
LD A,(DE)                  `cyferka za telefonem
SUB #31                    `cyfra 1 lub większa
JR C,@GoRab                `+12+31tkt hop-> zła 
INC A                      `cyfra '1' to wartość #01
LD (#80CD),A               `co to jest:
`                    #01 -> TELEFON1 (na poz.2)
`                    #02 -> TELEFON2 (na poz.3)
`                    #03 -> TELEFON3 (na poz.4)
`                    #04 -> TELEFON4 (na poz.5)
`                    #05 -> TELEFON5 (na poz.6)
`                    #06 -> TELEFON6  na poz.7)
`                    #07 -> TELEFON7 (na poz.8)
`                    #08 -> TELEFON8 (na poz.9)
CP #09                     `cyfra '8' to wartość #08
RET C                      `dobry zakres, dalej
LD A,#0F            @GoRab `+31tkt zrabuj numer
LD (#802A),A        @_GRab `+24tkt krok analizy na rabunek
RET                        `
`-------------------------------------------
`                                    
`przepisuje numer do znanych
`trwa +470tkt                
LD A,(#80CD)         @KTIa5 `który to telefon, na którą znaną zapisać?
`pierwsza z ładowanych -telefon1 ma być ładowana na pozycję 2
`czyli na adres #8580, dla niej (#80CD) wynosi #01
LD HL,#8575                `oblicz adres
LD C,A                     `tą pozycję w znanych zapisujemy
ADD A,A                    `
ADD A,A                    `
ADD A,C                    `
ADD A,A                    `
ADD A,C                    `Acc=Acc * &11
LD C,A                     `
LD B,#00                   `
ADD HL,BC                  `oblicz adres
EX DE,HL                   `
LD HL,#80A0                `adres, na który skompresowano numer ASCII,
LD BC,#000B                `10&bajtów numeru+1  to l.znaków
LDIR                       `11*21-5=226tkt
LD HL,#8501                `skończony zapis numeru do znanych, zapamietaj pozycję
`                           adres tablicy 8 bajtów -pozycji z SIM zapisanych w znanych numerach
LD A,(#80CD)               `który to telefon, na którą znaną zapisać?
`   cyfra '1' to wartość #01
`   cyfra '8' to wartość #08
`  #8502 -> 8b oznaczających numer pozycji w książce na SIM z której odczytano nr tel.
ADD A,L                    `obliczenie adresu tej pozycji
LD L,A                     `
JR @PK_po                  `+12+108tkt
`-------------------------------------
`                           
`tutaj tylko dla prefixu    
`trwa +426tkt max  ++++++++++         
LD HL,#80CE         @KTIa6 `adres początku opis `adres numeru ASCII w ramie 
LD E,(HL)                  `\
INC E                      `|odczytaj liczbę znaków opisu i zwiększ ją o 1
LD D,#00                   `/
ADD HL,DE                  `po zsumowaniu mamy adres liczby znaków numeru
LD A,(HL)                  `liczba znaków numeru /ew.plusa nie może być!!!/
INC HL                     `
CP #05                     `czy mniejsza od 5? 
JR NC,@InPKT               `+12+71tkt zbyt duża liczba cyfr numeru
CP #02                     `
JR C,@InPKT                `+12+71tkt zbyt mała liczba cyfr numeru
LD DE,#850A                `adr. liczby zn. prefixu w RAM konfigu
LD (DE),A                  `zapisz liczbę znaków prefixu
LD B,A                     `
INC DE              @KTPrE `przepisz znaki ASCII prefiksu 
LD A,(HL)                  `
INC HL                     `
`jeśli jesteś tutaj to tylko cyfry lub znak `+`
` znak `+` może służyć jako kasowanie prefixu z RAM lub numer zaczynający się na `+`
CP #30                     `
JR C,@KT099                `+12+88tkt hop -> to nie cyfra
`CP #3A                     `
`JR NC,@KT099               `+12+88tkt hop -> to nie cyfra
LD (DE),A                  `zapisz znak
DJNZ @KTPrE                `next znak 207=4*(40+13)-5
LD HL,#8501                `adres pozycji znanego prefiksu na SIM
LD A,(#807E)        @PK_po `+108tkt =#00 - #FE -tą pozycję odczytujemy właśnie
CP (HL)                    `
LD (HL),A                  `zapis pozycji SIM do znanych
JR Z,@KT088                `
`--- to z kradzieżą numerów znanych inaczej robione a pozostałe jeszcze niedopracowane
LD HL,#853B                `bajt w obszarze konfigu pamiętający czy kradliśmy 
LD A,(HL)                  `zgaś 7bit, bo nowe numery (inne pozycje niż były wcześniej)
AND #7F                    `7bit =0 jeszcze nie przesłane kradzione
LD (HL),A                  `     =1 już przesłane kradzione
`---                        
LD A,#0E            @KT088 `za prefixem
JR @_GRab                  `+12+24tkt krok analizy na spr czy już wszystkie
SUB A               @KT099 `+88tkt tu skasuj zapisaną liczbę znaków prefiksu, bo błąd
LD (#850A),A               `adres liczby cyfr prefiksu
SUB A               @InPKT `+71tkt odebrano żądany, więc na znak tego...
LD (#8080),A               `...kasuj krotność
LD (#807A),A               `...kasuj czas oczekiwania na kom ks.tel.
JP @OkSpd                  `+10+31tkt+20
`-------------------------------------
`                           
`tutaj tylko dla centrumSMS 
`trwa +430tkt max  +++++++++++         
LD DE,#80A0         @KTIa7 `adres l.znaków i skompresowanego numeru
LD A,(DE)                  `liczba znaków numeru /ew.plus ominięto/
INC DE                     `teraz adres skompresowanego numeru
`l. cyfr numeru już była sprawdzana
`CP #15                     `
`JR NC,@InPKT               `zbyt duża liczba cyfr numeru
INC A                      `bo nieparzysta też zajmuje bajt 
RRCA                       `div 2
AND #0F                    `wyczyść śmieci
LD HL,#855E                `adr. centrumSMS w RAM konfigu
INC A                      `bo też bajt typu numeru
LD (HL),A                  `zapisz l.bajtów numeru
INC HL                     `
LD (HL),#91                `typ numeru międzynarodowy
INC HL                     `
EX DE,HL                   `
LD BC,#000A                `=&10 bajtów do przesłania samego skompres numeru
LDIR                       `prześlij 205=10*21-5
LD HL,#8500                `adres pozycji znanego centrumSMS
JR @PK_po                  `+12+108tkt
`---------------------------------
`                             
`sprawdza czy znane są już wszystkie numery znane
`trwa +460tkt               
LD A,(#855E)        @KTIa8 `odczytaj l.bajtów centrum SMS
`   jeśli jest tutaj to znaczy że: był prefix (nie interesuje do rabunku)
`                              lub był centrumSMS (nie interesuje do rabunku)
`                              lub był TELEFON (rabowany w inny sposób)
AND A                      `czy =0? czy jest centrum SMS?
JR Z,@I_PK_                `+12+41tkt jr -> nie znamy numeru centrum SMS
LD HL,#8580                `
LD DE,#000B                `=&11
LD B,#08                   `tyle znanych
LD A,(HL)           @alksw `pętla, odczytaj l.znaków
AND A                      `czy =0?
JR Z,@I_PK_                `jr -> nie znamy wszystkich znanych
ADD HL,DE                  `
DJNZ @alksw                `next poz 331=8*(29+13)-5
` gdy jest tutaj to znaczy że mamy all TELEFONy i CENTRUMSMS
LD A,(#850A)               `adres liczby znaków prefixu
AND A                      `czy jest prefix?
JR Z,@I_PK_                `hop-> nie mamy prefixu
LD A,#FF                   `w opisie #80  `blokuj przeszukiwanie książki telefonicznej, 
`                                                                     bo mamy all znane
LD (#807F),A               `skończono szukanie w książce telefonicznej
LD A,#01                   `\przyspiesz zapis konfigów -> za 1 min przejdzie na
LD (#807D),A               `/DKrok =#08 czyli zapis konfigów
JP @InPKT           @I_PK_ `
`---------------------------------
`
`no i rabowanie numerów
`trwa +tkt
NOP                 @KTIaR `
`   tutaj trafia tylko gdy jest to numer inny niż ALARM/PREFIX/CENTRUM
`   numer jest poprawnie skompresowany i wraz z liczbą cyfr czeka na zrabowanie
`   sprawdzamy czy liczba cyfr numeru jest co najmniej równa 9
LD HL,#80A0                `adres stały, na który skompresowaliśmy numer,
`        #80A0- 1b -> faktyczna liczba znaków numeru (bez plusa/zera jeśli był/o)
LD A,(HL)                  `tu liczba znaków tego numeru
CP #09                     `
JR C,@InPKT                `hop -> olej bo liczba cyfr mniejsza niż 9
INC A                      `\
RRCA                       ` |czyli ile to bajtów
AND #0F                    `/
INC A                      `bo też bajt liczby znaków
LD C,A                     `\
LD B,#00                   `/ilość bajtów do przesłania max. &11
`LD DE,miejsce_docelowe     `
`LDIR                       `prześlij tylko użyteczne bajty
`teraz dodaj bajty do adresu
`
`   *** tutaj rabuj numer ***
`
JR @InPKT                  `
`------------------------------
`
DEFETYK @KsTeW   `#07 adres tablicy adresów kroków do tworzenia ramki zapisu książki tel na SIM
` a max to +674tkt !                         
DEFTABE KT_05                `+508tkt `#05 
DEFTABE KT_06                `+573tkt `#06 
DEFTABE KT_07                `+600tkt `#07 <---
DEFTABE KT_08                `+378tkt `#08 
DEFTABE KT_09                `+448tkt `#09 
DEFTABE KT_0A                `+346tkt `#0A 
DEFTABE KT_0B                `+369tkt `#0B 
DEFTABE KT_0B                `+369tkt `#0C 
DEFTABE KT_0B                `+369tkt `#0D 
DEFTABE KT_0B                `+369tkt `#0E 
DEFTABE KT_0B                `+369tkt `#0F 
DEFTABE KT_0B                `+369tkt `#10 
DEFTABE KT_0B                `+369tkt `#11 
DEFTABE KT_0B                `+369tkt `#12 
DEFTABE KT_0B                `+369tkt `#13 
DEFTABE KT_0B                `+369tkt `#14 
`---------------------------------
`tworzona ramka do zapisu numeru nadpisanego do książki tel.
`       #1F #00 #1D –standard,
`#81C8: #03 –rozkaz,
`#81C9: #00 #XX –długość treści ramki,
`#81CB: #00 #01 #00 #04 #03 –stałe dla tej ramki,
`#81D0: #XX –pozycja na SIM?
`#81D1: #06 –ilość znaków ASCII opisu,
`#81D2: #T_ #E_ #L_ #E_ #F_ #O_ #N_ #XX  –opis ASCII,
`#81DA: #XX –ilość znaków ASCII numeru,
`#81DB: #2B #34 #38 #35 #30 #31 #32 #31 #33 #32 #33 #31 –numer ASCII,
`#81??: #00 #FF –stałe dla tej ramki,
`       ID XOR -standard
`----------------------------------------------------------
`
`szuka zapalonego 7bitu, jeśli brak to wyjdź i zmień DKrok, jeśli jest
`to rezerwuj ramkę USERa i przygotuj ją do zapisu numeru na SIM
`trwa +508tkt max +4+12
LD HL,#8502               @KT_05 `
LD B,#08                         `
BIT 7,(HL)                @nx7bi `czy zpalony 7bit?
JR NZ,@mam7b                     `hop -> mamy 7bit zapalony, działamy
INC HL                           `next adres do sprawdzenia
DJNZ @nx7bi                      `
`tutaj nie ma zapalonych 7mych bitów, trzeba wyjść do DKroku =#09
`i wyjść z tego tworzenia ramek    
`
` ********* tego poniższego gdzieś już nie ma?
`
LD A,#09                         `\DKrok zapisu konfigu
LD (#802E),A                     `/
JP @OkZro                        `zakończ
LD (#81DB),HL             @mam7b `/już +307tkt/ tymczasowo zachowaj
LD A,#08 `LD A,#09               `\
SUB B                            `/wynik #00-#07
LD (#804B),A                     `zapamiętaj pozycję z swojej tabeli,
`                                 aby wyzerować 7bit gdy będzie potwierdzenie
ADD A,#31 `ADD A,#30             `\zapisz ASCII do opisu nru tel.
` a nie powinno być #31? bo teraz wychodzi #30...#37 cyfry 0..7 ?!
LD (#81D9),A                     `/
LD A,(HL)                        `znaleziony zapalony 7bit
AND #7F                          `
LD H,A                           `-> na poz SIM /jest lub nie/
LD L,#03                  `@zero1 `
LD (#81CF),HL                    `zapisz pozycję dla numeru tel na SIM w ramce
`                      tworzonej do zapisu nru na SIM
LD A,L                           `#03
LD (#81C8),A                     `zapisz rozkaz
LD HL,#0101                      `
LD (#81C9),HL                    `blokuj USERa
LD L,#00                         `\
LD (#81CB),HL                    ` \stały element ramki
LD H,#04                         ` /
LD (#81CD),HL                    `/
LD A,#08                         `\8 znaków ASCII
LD (#81D1),A                     `/
RET                              `
`---------------------------------
`
`sprawdź czy znaleziony z 7bit-em ma konkretną pozycję, czy nie
`jeśli ma to omiń kroki znajdowania pozycji,
`jeśli nie to poszukaj na jaką poz można by go zapisać
`trwa +573tkt max
LD A,(#81D0)              @KT_06 `adr poz na SIM /mamy lub nie/
AND A                            `pozycja
JR Z,@brkPZ                      `hop -> brak pozycji (#00), trzeba utworzyć ?
` założymy że nie ma pozycji #00 i ędziemy zapisywać ks tel
` od pozycji #01... do max &99 #63 
CP #64                           `
JR NC,@brkPZ                     `hop -> mamy pozycję(w Acc), nie trzeba szukać
` tutaj jest pozycja, omiń kroki wyszukiwania
LD DE,#802A                      `
LD A,#09                         `zwiększ kroczek, aby ominąć następne, 
`      bo znamy już pozycję na którą go nadpiszemy
LD (DE),A                        `zapamiętaj
RET                              `
`           już +46tkt            
LD HL,#82B9               @brkPZ `brak pozycji -trzeba utworzyć 
LD B,#0A                         `
LD (HL),B                 @nxTzA `zapisz wartość że pusta poz.
DEC HL                           `nxt adres
DJNZ @nxTzA                      `pętla
LD B,#02                         `sprawdź jeszcze 2 pozycje
LD HL,#8500                      `znane pozycje ks tel w konfigu (wraz z prefixem i centrumSMS)
LD DE,#82AF               @spBpo `pierwszy z pomocniczych minus 1
` już +345tkt                     
LD A,(HL)                 @nxZnS `odczytaj znaną poz z SIM trwa: +(111tkt * Brej) +6
AND #7F                          `
JR Z,@nxZns                      `hop -> bo =0
CP #0B                           `
JR NC,@nxZns                     `hop -> bo interesują nas tylko pozycje 1..&10
PUSH HL                          `zachowaj
LD H,#00                         `\
LD L,A                           `/na 16 bitów
ADD HL,DE                        `dodaj adres podstawy tabeli pomocniczej
LD (HL),#00                      `zeruj, to znaczy że ta pozycja nie może być użyta
POP HL                           `odtwórz
INC HL                    @nxZns `adr. następny do sprawdzenia w konfigu znanych poz z ks tel
DJNZ @nxZnS                      `pętla (111tkt * Brej -5) +RET
RET                              `
`---------------------------------
`
`sprawdza czy są wykryte znane pozycje 1..10 na książce telefonicznej
`trwa +600tkt max
LD B,#05                  @KT_07 `sprawdź jeszcze 5 pozycji
LD HL,#8502                      `znane pozycje ks tel w konfigu (wraz z prefixem i centrumSMS)
JR @spBpo                        `+12tkt + trwa: +(111tkt * Brej) +16
`---------------------------------
`
`sprawdza czy są wykryte znane pozycje 1..10 na książce telefonicznej
`trwa +378tkt max                    
LD B,#03                  @KT_08 `sprawdź jeszcze 3 pozycje
LD HL,#8507                      `znane pozycje ks tel w konfigu (wraz z prefixem i centrumSMS)
JR @spBpo                        `
`---------------------------------
`
`odszukuje która z pozycji 1..10 na ks tel jest wolna i przydziela
`ten numer pozycji do zapisu nowemu numerowi do ks tel.
`trwa +448tkt max                    
LD HL,#82B9               @KT_09 `
LD B,#0A                         `
LD A,(HL)                 @_kt9a `odczytaj w pomocniczej tabeli pozycję
AND A                            `czy =0 (zajęta to =0!)
JR NZ,@_kt9b                     `hop -> ta pozycja jest wolna na SIM w ks tel
DEC HL                           `
DJNZ @_kt9a                      `pętla
LD B,#0B                         `na wszelkij słuczaj będzie to poz &11
LD A,B                    @_kt9b `do Acc wolna pozycja
LD (#81D0),A                     `zapisz do ramki USERa dla zapisu ks tel
LD HL,(#81DB)                    `zapisz też w pamięci konfigu odnalezioną pozycję
SET 7,A                          `z zapalonym 7 bitem (że jeszcze nie zapisana)
LD (HL),A                        `zapisz
RET                              `
`---------------------------------
`
`sprawdź podany numer tel.          
`utwórz opis np 'TELEFON1'...'TELEFON8'
`trwa: +346tkt max  +42tkt ++++++++++              
LD A,(#81D9)              @KT_0A `\odtwórz  #38
SUB #31                          `/wynik #00..#07
LD HL,#8580                      `tabela fizycznych skompresowanych numerów
LD B,A                           `\     07
ADD A,A                          ` \    0E
ADD A,A                          `  \   1C
ADD A,B                          `   |obl. fizyczny adres tego numeru 23
ADD A,A                          `  /   46
ADD A,B                          ` /    4D
ADD A,L                          `/   85CD
LD L,A                           `
LD A,(HL)                        `liczba cyfr numeru
INC HL                           `    85CE ok adres dla 7 poz (ostatniej)
AND A                            `
`  tutaj akceptujemy nawet numer jednoznakowy,
`  bo to numer z PC lub z SMS przybyłego /czyli sprawdzony wcześniej już!/
JR Z,@tmCYF                      `hop -> brak cyfr
CP #15                           `
JR NC,@tmCYF                     `hop -> zbyt dużo cyfr
LD (#82C9),A                     `zapisz l. znaków do rozkompresowania
INC A                            `bo znak '+' przed prefixem
LD DE,#81DA                      `\
LD (DE),A                        `/zapisz l. znaków numeru do ramki
INC DE                           `
ADD A,#12                        `\dł ramki mbusa
LD (#81CA),A                     `/
LD A,#2B                         ` '+' przed prefixem
LD (DE),A                        `zapisz '+' ASCII do numeru do ramki
INC DE                           `
LD (#82C7),HL                    `\zapisz dla rozkompresowania
LD (#82C5),DE                    `/
LD HL,@opisT                     `
LD DE,#81D2                      `
LD BC,#0007                      `
LDIR                             `przeładuj opis 'TELEFON'
RET                              `
LD HL,(#81DB)             @tmCYF `odtwórz tymczasowo zachowany adres w tabeli #8502
SUB A                            `\zeruj że jest cokolwiek nadpisane
LD (HL),A                        `/
LD A,#80                         `\
LD (#81C9),A                     `/czyść ramkę USERa
JP @OkZro                        `zakończ
`---------------------------------
`
`rozkompresuj na ASCII 2 cyfry numeru
`trwa: +369tkt max                
CALL @nrDkp               @KT_0B `+17+226
RET NZ                           `
EX DE,HL                         `
LD (HL),#00                      `\
INC HL                           ` |ułóż końcówkę ramki
LD (HL),#FF                      `/
LD A,#00                         `\odblokuj kom USERA
LD (#81C9),A                     `/
`powtórki USERa ustawiane są w MKroku #06...
JP @OkZrU                        `+61tkt przyspiesz wysyłanie ramki USERa ;o)
`=========================================================
`=           WSZYSTKO DO POŁĄCZEŃ FONICZNYCH             =
`=========================================================
`
`po RESET zeruj ICF,ICR,MC,RSL !
LD (#9100),A                 @resRD `
LD HL,#0000                         `
LD (#86A6),HL                       `
LD (#86B1),HL                       `
LD H,#0C                            `Głośnik=1 i Mikrofon=1 /oba nieaktywne!/ w RSL
LD (#86A8),HL                       `
LD A,#80                            `\zastopuj zegar połączenia
LD (#86B3),A                        `/
RET                                 `
`-----------------------------
`
`rama #40 (przyjęto numer do wybrania)
`trwa:+65tkt
LD A,(DE)            @_#1F_ `MakeCall
AND #F0                     `
CP #A0                      `czy oczekuje na ramę #40 ?
RET NZ                      `ret =nie oczekuje
LD A,(DE)                   `MakeCall
AND #0C                     `zachowaj GM
OR #C0                      `zaznacz że otrzymano ramę #40...
LD (DE),A                   `zapisz w MakeCall
RET                         `
`-----------------------------
`
`rama #02 (rozpoczęcie dzwonienia wychodzącego)
`i przesyła numer na który dzwonimy
`trwa:+602tkt
LD A,(DE)            @_#11_ `MakeCall 
AND #0C                     `zachowaj GM
OR #E0                      `zaznacz że dzwoni
LD (DE),A                   `zapisz w MakeCall
INC DE                      `adr. RingStatusLED
LD A,#CC                    `RingStatusLED
LD (DE),A                   `zapisz
LD A,(HL)                   `ID bieżącego połączenia
LD (BC),A                   `nadaj ID
LD HL,#8699                 `źródło przesyłanego numeru do którego dzwonimy
CALL @_4cal                 `+17+267tkt prześlij ten numer do bieżącego połączenia
JR @RdMsT                   `zapisz moment i startuj pomiar czasu
`-----------------------------
`
`rama #03 (rozpoczęcie rozmowy)
`trwa:+396tkt
LD A,(BC)            @_#12_ `odczytaj ID bieżące
CP (HL)                     `porównaj z ID z ramy
RET NZ                      `ret -> niezgodne ID
INC DE                      `adr. RSL
LD HL,#86A6                 `adr. IncommingCallResponse
LD A,(DE)                   `odczytaj RingStatusLED
AND #F3                     `zeruj bity GM
OR #02                      `ustaw bit dial
LD C,A                      `zapamiętaj stan
AND #40                     `bit6
JR Z,@#12__                 `hop -> zmień ICF
INC HL                      `tu zmień MC
INC HL                      `tera adr. MC
LD A,(HL)            @#12__ `IncommingCallResponse/MC
AND #0C                     `zostaw tylko bity GM
LD B,A                      `zachowaj GM
OR C                        `to co było wcześniej
LD (DE),A                   `zapisz RingStatusLED
AND #40                     `bit6
JR NZ,@#12_1                `hop -> zmień MC
INC HL                      `adr ICF
LD A,(HL)            @#12_1 `MC/ICF
AND #E3                     `zachowaj wszystko prócz bitów GM
OR B                        `odtwórz bity GM
OR #02                      `zmień z ring na dial (MC lub ICF)
LD (HL),A                   `zapisz MC/ICF
LD HL,#8004          @RdMsT `+203tkt aktualny Time/data
LD DE,#86AA                 `zapisz moment rozpoczęcia
LD BC,#0007                 `5bajtów
LDIR                        `przepisz
SUB A                       `Acc=0
LD L,A                      `\
LD H,A                      `/HL=#0000
LD (#86B1),HL               `\
LD (#86B3),A                `/zeruj - startuj czas 
RET                         `
`-----------------------------
`
`ramy #04 i #0A -> odłożenie/przerwanie 
`trwa:+232tkt
LD A,(HL)            @#1319 `ID przychodzącej
AND A                       `czy =0?
JR Z,@1319_                 `+12+78tkt hop-> to nie ID=0!
`     tutaj dla ID<>0         
LD H,A                      `ID przychodzącej
LD A,(BC)                   `ID bieżącej
CP H                        `spr. ID
RET NZ                      `wyjdź bo niezgodny ID połączenia
LD BC,#86B3                 `adres czasu
LD A,(BC)                   `czas 
OR #80                      `ustaw 7bit godzin =zatrzymaj
LD (BC),A                   `zatrzymaj czas 
INC DE                      `adr. RSL
LD A,(DE)                   `RSL
AND #7E                     `zeruj 7bit, a bit0 zostanie zaraz ustawiony odpowiednio
LD B,A                      `RSL
CALL @zr0bi                 `+17+60tkt zrób RSL i bit0 do Crej
DEC DE                      `adr.MC
AND #40                     `bit in(0)/out(1)
JR NZ,@13_19                `hop ->out bo MC
DEC DE                      `adr.ICF
LD A,(DE)            @13_19 `+36tkt odczytaj MC/ICF
AND #7E                     `zeruj 7bit, a bit0 zostanie zaraz ustawiony
OR C                        `ustaw bit0
LD (DE),A                   `zapisz MC
RET                         `
`     tutaj dla ID=0         
LD A,(DE)            @1319_ `+78tkt MC
`niezależnie od tego czy trwa inne połączenie, czy nie, tutaj zostało
`ono odrzucone a więc trzeba dać temu wyraz w MC /tutaj tylko wychodzące a więc zawsze MC!/
AND #7E                     `zeruj 7bit, a bit0 zostanie zaraz ustawiony
LD B,A                      `MC
`   teraz utworzymy bit0 (zakończone przez...)
LD A,(#80C7)         @zr0bi `+60tkt podkod
SUB #13                     `czy przez NOKIA?
JR Z,@_1319                 `hop-> przez drugi, i bit0 =0
LD A,#01                    `bit0=1 bo przez NOKIA
LD C,A               @_1319 `zapamiętaj bit0
OR B                        `
LD (DE),A                   `zapisz MC
RET                         `
`-----------------------------
`
DEFETYK @Iring         `tablica adresów tablic analizy i wykonania rozpoznania numeru dzwoniącego
DEFTABE 1CALL           `05 ustawia ICF, RSL, moment rozpoczęcia dzwonka i pomiar jego czasu
DEFTABE 2CALL           `06 spr. czy nie zastrzeżony i dopisuje zera za numerem
DEFTABE 3CALL           `07 dopisuje domyślny prefix
DEFTABE RARC4           `08 kompresuje znaki 0-7
DEFTABE RARC4           `09 kompresuje znaki 8-15&
DEFTABE RARC2           `0A kompresuje znaki &16-&19 i uzupełnia ostatni #F0
DEFTABE CPIR_           `0B porówna z 1-szym znanym
DEFTABE CPIR_           `0C porówna z 2-gim znanym
DEFTABE CPIR_           `0D porówna z 3-cim znanym
DEFTABE CPIR_           `0E porówna z 4-tym znanym
DEFTABE CPIR_           `0F porówna z 5-tym znanym
DEFTABE CPIR_           `10 porówna z 6-tym znanym
DEFTABE CPIR_           `11 porówna z 7-tym znanym
DEFTABE CPIR_           `12 porówna z 8-tym znanym
DEFTABE CPIR_           `13 porówna z 9-tym znanym
DEFTABE CPIR_           `14 porówna z 10-tym znanym
DEFTABE 4CALL           `15 analiza wyniku rozpoznania
DEFTABE OkZro           `16 wyjdź z analizy
`-----------------------------
`
`połączenie przychodzące part1
`trwa:+316tkt
LD DE,#86A7          @1CALL `ICF
LD A,#BC                    `1011 1100
`         1011 xx00 => dzwoni, ale czas trwania dzwonka do 3 sekund
`         1010 xx00 => dzwoni, czas trwania dzwonka powyżej 3 sekund
LD (DE),A                   `zapisz ICF
INC DE                      `
INC DE                      `teraz adr. RSL
LD A,#8C                    `1000 1100
LD (DE),A                   `zapisz RSL
LD A,(#80CD)                `ID bieżącego połączenia
LD (#86C0),A                `nadaj ID
JP @RdMsT                   `+12+224tkt zapisz moment i startuj pomiar czasu
`-----------------------------
`
`połączenie przychodzące part2
`trwa:+524tkt
LD A,#FF             @2CALL `=zastrzeżony
LD (#809F),A                `jako numer zastrzeżony (też początek do rozpoznawania)
LD HL,#80CF                 `adr. l.znaków numeru
LD A,(HL)                   `liczba znaków
LD (#80A0),A                `=0 (gdybyśmy tutaj olali)
AND A                       `czy =0?
JR Z,@_2cal                 `hop -> brak numeru =zastrzeżony
CP #16                      `=&21+1 (&21 bo 20 cyfr i znak plusa)
JR NC,@__2ca                `hop -> numer ma za dużo znaków
ADD A,L                     `\
INC A                       ` |obl. adr. pierwszego bajtu za ostatnim znakiem numeru
LD L,A                      `/
LD (HL),#30                 `kod ASCII zera
LD E,L                      `z HL na DE
LD D,H                      `
INC E                       `
LD BC,#0013                 `=&19 znaków
LDIR                        `dopisz &19 zer ASCII za numerem
RET                         `
LD A,#FC             @__2ca `+51tkt =błędny
LD (#809F),A                `jako numer błędny
LD A,#14             @_2cal `kroczek za CPIRami
LD (#802A),A                `zapisz kroczek /next po rozpoznawaniu/
RET                         `
`-----------------------------
`
`trwa:+622tkt
CALL @RARb4          @RARC4
RET C
JR @__2ca
`-----------------------------
`
`trwa:+390tkt
CALL @RARb2          @RARC2
RET C
JR @__2ca
`-----------------------------
`
`połączenie przychodzące part3
`trwa:+325tkt
LD HL,#80CF          @3CALL `adr. l.znaków numeru w ramie
LD B,(HL)                   `l.znaków numeru w ramie
INC HL                      `adr. pierwszego znaku
LD A,(HL)                   `1-szy znak numeru
CP #2B                      `czy to '+' ?
JR Z,@_3cal                 `hop -> nie dopisuj prefixu
`  teraz trzeba spr czy nie zaczyna się od zera (jak to w PlusGSM)
CP #30                      `czy to kod 0 ?
JR NZ,@3cal_                `hop -> nie od zera, normalnie
INC HL                      `adres o 1 znak do przodu
DEC B                       `o 1 znak mniej
`gdyby miało być więcej zer na początku to tutaj skok znów do sprawdzania czy zero...
`  tutaj trzeba dopisać domyślny prefix kraju
LD DE,#850A          @3cal_ `adr. l.znaków domyślnego prefixu kraju w konfigu
LD A,(DE)                   `odczytaj
AND A                       `czy =0 (brak domyślnego prefixu)?
JR Z,@___3c                 `hop -> brak domyślnego prefixu
CP #05                      `dopuszczalna liczba znaków prefixu to 4
JR NC,@___3c                `hop -> za długi
INC DE                      `
LD C,A                      `l.znaków prefixu
ADD A,B                     `suma l.znaków prefixu+numeru
LD (#80A0),A                `liczba znaków 
LD A,L                      `adr. pierwszego znaku numeru
SUB C                       `minus l. znaków prefixu
LD L,A                      `zapamiętaj nowy adres numeru
LD (#80C8),HL               `adr. 1-szego znaku numeru w ramie
EX DE,HL                    `z HL(prefix) na DE(rama przed numerem)
LD B,#00                    `aby BC było liczbą bajtów do przesłania
LDIR                        `przerzuć prefix 79tkt =4*&21-5
JR @__3ca                   `                         `
DEC B                @_3cal `+80tkt tutaj jest '+' więc nie dopisujemy prefixu
LD A,B                      `
LD (#80A0),A                `liczba znaków (bez '+')
INC HL                      `
LD (#80C8),HL        @___3c `+53tkt adr. znaków numeru w ramie
LD HL,#80A1          @__3ca `+37tkt 
LD (#81C5),HL               `DE adres, na który kompresować numer ASCII,
RET                         `
`-----------------------------
`
`analiza wyniku rozpoznania
`trwa:+411tkt
CALL @poCPR         @4CALL `+17+106tkt
`#8049 -> KEY: 1szy bajt bitami: obsługa przycisków OK i C:
`                                            #xx : 7 6 5 4 3 2 1 0
`   wciśnięcie samego OK na krótko:          #84 : 1 0 x 0 x 1 0 0
`   wciśnięcie samego OK na długo :          #94 : 1 0 x 1 x 1 0 0
`i jeszcze                  
`prześlij numer dzwoniącego i wynik jego rozpoznania do bieżącego połączenia
LD HL,#809F                `
LD DE,#86B4         @_4cal `+267tkt
LD BC,#000C                `=&12 bajtów do przepisania, 
`                               czyli wynik rozpoznania, l.bajt+skompr numer
LDIR                       `+247tkt =&12*21-5
`nie może kończyć się na OkZro bo skaczemy tu z krótkiej!
RET                        `
`----------------------------
`
DEFETYK @Scall   `#07 adres tablicy adresów kroków do tworzenia połączenia fonicznego
DEFTABE MCal1        `#05 
DEFTABE MCal2        `#06 2 znaki
DEFTABE MCal2        `#07 4 znaki
DEFTABE MCal2        `#08 6 znaki
DEFTABE MCal2        `#09 8 znaki
DEFTABE MCal2        `#0A 10 znaki
DEFTABE MCal2        `#0B 12 znaki
DEFTABE MCal2        `#0C 14 znaki
DEFTABE MCal2        `#0D 16 znaki
DEFTABE MCal2        `#0E 18 znaki
DEFTABE MCal2        `#0F 20 znaki
DEFTABE MCal3        `
`---------------------------------------
`
`trwa +353tkt
LD HL,#0101             @MCal1 `
LD (#81C8),HL                  ` /równocześnie blokuje ramkę USERa?/
LD H,#00                       `
LD (#81CA),HL                  `
LD (#81CC),HL                  `
LD (#81CE),HL                  `
LD HL,#86A8                    `adr. bajtu sterującego wybieraniem numeru
LD A,(HL)                      `odczytaj bajt sterujący wybieraniem numeru
AND #0F                        `zachowaj ew. bity konfiguracji???
OR #90                         `zaznacz że w trakcie tworzenia
LD (HL),A                      `zapisz bajt sterujący wybieraniem numeru
LD DE,#81CF                    `tu liczba znaków do wybrania a za nią ASCII numer w USERze
LD HL,#8699                    `czy to znany?
LD A,(HL)                      `skąd numer do wybrania???
INC HL                         `gdy numer podany ręcznie
CP #0A                         `
JR NC,@laksj                   `hop -> numer podany 'ręcznie' (NIE znany)
LD HL,#856A                    `pocz. tab. znanych
LD B,A                         `
ADD A,A                        `\
ADD A,A                        ` \ 
ADD A,B                        ` | * &11
ADD A,A                        ` /
ADD A,B                        `/
ADD A,L                        `\bez przełomu!
LD L,A                         `/
LD A,(HL)               @laksj `+145tkt w (HL) mamy numer do wybrania skompresowany
AND A                          `czy liczba znaków =0?
JR Z,@1293b                    `hop -> wychodzimy z tworzenia numeru -error
CP #15                  `@12OPI `liczba cyfr czy <&21
JR NC,@1293b                   `hop -> wychodzimy z tworzenia numeru -error
INC HL                         `
LD (#82C9),A                   `zapamiętaj na zaś liczbę znaków 
INC A                          `bo plus!
LD (DE),A                      `zapisz liczbę znaków do ramy USERa
INC DE                         `
ADD A,#10                      `obl. długość ramki mBus`a ?????????
LD (#81CA),A                   `zapisz
LD A,#2B                       ` '+' plus przed prefixem
LD (DE),A                      `zapisz do ramy USERa
INC DE                         `
LD (#82C7),HL                  `
LD (#82C5),DE                  `
RET                            `
SUB A                   @1293b `+58tkt MakeCall = #00 /wychodzimy z tworzenia numeru/
LD (#86A8),A                   `
JP @OkZro                      `+10+31tkt hop ->wychodzimy z tworzenia numeru -error
`-------------------------------
`
`trwa: +257tkt
CALL @nrDkp             @MCal2 `
RET NZ                         `
LD A,#0F                `@aw;dn `koniec dekompresji (a więc next kroczek to #10 ;o) )
LD (#802A),A                   `przeskocz kroczkiem
RET                            `
`-------------------------------
`
`pomocnicza, dekompresuje numer tel na kody ASCII
`dla wybrania numeru tel przez GSM do ramki,
`     zapisu książki telefonicznej do SIM
`    future: dla wybrania nr tel przez TPSA
`trwa: +226tkt                  
LD HL,(#82C7)           @nrDkp `
LD DE,(#82C5)                  `
LD A,(#82C9)                   `odtwórz liczbę znaków
LD B,A                         `ile znaków
LD A,(HL)                      `odczytaj dwa znaki
INC HL                         `
LD C,A                         `
AND #0F                        `
ADD A,#30                      `
LD (DE),A                      `zapisz znak
INC DE                         `
DEC B                          `
RET Z                          `RET Z -> koniec dekompresji
LD A,C                         `
RRCA                           `
RRCA                           `
RRCA                           `
RRCA                           `
AND #0F                        `
ADD A,#30                      `
LD (DE),A                      `zapisz znak
INC DE                         `
DEC B                          `
RET Z                          `RET Z -> koniec dekompresji
LD (#82C7),HL                  `
LD (#82C5),DE                  `
LD A,B                         `ile znaków
LD (#82C9),A                   `zapamiętaj pozostałą liczbę znaków
RET                            `NZ
`-------------------------------
`
`trwa: +391tkt
LD HL,@RR_E*            @MCal3 `po dekompresji
LD DE,(#82C5)                  `
INC DE                         `
LD BC,#000B                    `
LDIR                           `226=&11*&21-5
LD A,#00                       `\odblokuj kom USERA
LD (#81C9),A                   `/
LD DE,#86A8                    `adr. bajtu sterującego wybieraniem numeru
LD A,(DE)                      `odczytaj bajt sterujący wybieraniem numeru
AND #0F                        `zachowaj ew. bity konfiguracji???
OR #A0                         `zaznacz że jest USER
LD (DE),A                      `zapisz bajt sterujący wybieraniem numeru
LD A,#02                @OkZrU `+61tkt przyspiesz wysyłanie ramki USERa ;o)
LD (#801C),A                   `żyto
JP @OkZro                      `+10+31tkt
`---------------------------------------
`
`poniżej ramka -wybieranie połączenia fonicznego
`         #1F #00 #1D 
`         #01 #00 #dl #00 #01 #00 #01 
`teraz liczba znaków i numer ASCII
DEFETYK @RR_E*
DEFBAJT1 #05 #01 #01 #05 #81 #01 #00 #00 #01 #01 #41`
`i na koniec numerID i XOR
`---------------------------------------
`
`procedury pomocnicze przy wykonywaniu cyny wychodzącej i wykonania reakcji
`na połączenia wychodzące i przychodzące (OK/C)
`realizowane chyba gdzieś pod koniec analizy ramy przychodzącej z NOKIA ???
`   pozostaje problem co ze zbyt szybką reakcją na poł. wychodzące?
`   bo przychodzące czeka 5sekund
`
`trwa: +307tkt
LD DE,#86A8               @OK_C_ `RingStatusLED(RSL) -1
LD A,(DE)                 `@Ocyna `MC
INC DE                           `
AND #FE                          `zlecenie i w czasie ring/dial
CP #EE                           `=wychodzące jako cyna w trakcie rozmowy
JR Z,@go_OK                      `hop -> przerwij natychmiast (drugi odebrał)
CP #EC                           `=wychodzące jako cyna w trakcie dzwonka
JR NZ,@lasnm                     `wyjdź bo to inne
`tutaj wychodzące jako cyna w trakcie dzwonka, sprawdzimy ile czasu już dzwoni...
LD A,(#86B1)                     `sekundy
CP #02                           `
JR C,@lasnm                      `wyjdź bo czas krótszy od 2 sek.
LD A,#84                  @go_OK `+31tkt zlecenie jeden raz krótki przycisk OK
LD (#8049),A              @go_Ke `+24tkt 
RET                              `
LD HL,#86A6               @lasnm `+217tkt ICR
CALL @__OkC                      `+17+169tkt
LD (HL),#00                      `wykonano ICR
RET                              `
`--------------
`
`używa przycisków zgodnie z IncommingCallResponse (ICR) (#86A6)
`trwa: +169tkt
LD A,(DE)                 @__OkC `RSL
AND #C2                          `akt, out/in, ring/dial, 
LD B,A                           `zapamiętaj RSL
LD A,(HL)                        `ICR
BIT 7,A                          `7bit (aktywny=1)
RET Z                            `wyjdź gdy nieaktywne
AND #13                          `
JR Z,@odDzw                      `hop -> zakończ outgoing ring/dial (OK)
DEC A                            `
JR Z,@odbiE                      `hop -> odbierz przychodzące (OK)
DEC A                            `
RET NZ                           `wyjdź bo to nie 
` tutaj odrzuć przychodzące ring (C) lub zakończ przychodzące dial (OK)
LD A,B                           `RSL AND #C3
CP #80                           `=akt, inc, ring
JR Z,@ifZc_                      `hop -> gdy Z to (C)
CP #82                           `=akt, inc, dial
JR @ifZok                        `hop -> gdy Z to (OK)
` poniżej odbierz przychodzące (OK)
LD A,B                    @odbiE `RSL AND #C3
CP #80                           `=akt, inc, ring
JR @ifZok                        `hop -> gdy Z to (OK)
` poniżej zakończ outgoing ring/dial (OK)
LD A,B                    @odDzw `RSL AND #C3
AND #C1                          `wygasza tylko bit ring/dial
CP #C0                           `=akt, out
`...przejdź...                      
LD A,#84                  @ifZok `+60tkt zlecenie jeden raz krótki przycisk OK gdy Z
JR @retNZ                        `hop -> zrób gdy Z
LD A,#80                  @ifZc_ `+48tkt zlecenie jeden raz krótki przycisk C gdy Z
RET NZ                    @retNZ `+41tkt zleć przycisk gdy Z else RET
JR @go_Ke                        `zleć przycisk
`--------------------------------------------------------------------
`
`===========================================
`=           WSZYSTKO DO SMSów             =
`===========================================
`
`po RESET zeruj.........
LD B,#04                  @resSM `
LD HL,#82CA                      `adres versji obszaru zerowego
LD DE,#0089                      `delta
LD (HL),#00               @_resS `zeruj obszar
ADD HL,DE                        `
DJNZ @_resS                      `
`     zeruj tablicę znaczników SMSów do skasowania...
LD HL,#8030                      `adres j.w.
LD E,L                           `\
LD D,H                           `/przepisz do DE
INC DE                           `następny
LD BC,#0016                      `długość obszaru o 1 mniejsza
LD (HL),#00                      `nic
LDIR                             `
LD A,#01                         `=1
LD (#802F),A                     `nr kolejnego SMSa sprawdzanego cyklicznie
`     zeruj tablicę oczekujących na delivery - a właściwie po co?
`LD HL,#8082                      `tab. znanych oczekuj na delivery
`LD (HL),#00                      `zeruj
`LD D,H                           `
`LD E,L                           `
`INC DE                           `
`LD BC,#0015                      `
`LDIR                             `
RET                              `
`----------------------------------------------
`                                 
DEFETYK @ISMrx   `adres tablicy adresów kroków do analizy SMSów odebranych
`---                                 
DEFTABE _#02_           `#05 +509tkt +++++++++
DEFTABE #02_3           `#06 +422tkt czy dobra pozycja i ew incknij cykliczne przeszuk.
`                                    szukaj w tabeli 3 nr umownych wysłanych SMSów
DEFTABE #02_4           `#07 +221tkt szukaj w tabeli 2 nr umownych wysłanych SMSów
`--- poniżej będzie kilka wywołań dla delivery (#02)
DEFTABE SMdxf           `#08 +459tkt szukaj w tabeli 6 nr umownych wysłanych SMSów
DEFTABE SMde1           `#09 +430tkt \
DEFTABE SMSd2           `#0A +408tkt  \
DEFTABE SMSd3           `#0B +459tkt   \analiza czasu i jeśli poprawny
DEFTABE SMSd4           `#0C +551tkt   /to odpowiednie poprawienie (ustawieie) zegara systemu
DEFTABE SMSd5           `#0D +470tkt  /
DEFTABE SMSd6           `#0E +263tkt /
DEFTABE SMSd7           `#0F +219tkt skasuj tego delivra 
`----------------------------
DEFTABE SMm1_           `#10 \
DEFTABE SMm2_           `#11 |realizacja majstra
DEFTABE SMm3_           `#12 /
DEFTABE SMk1_           `#13 \
DEFTABE SMk2_           `#14 |dekodowanie
DEFTABE SMk3_           `#15 |fragmentów 
DEFTABE SMk4_           `#16 |konfigu
DEFTABE SMk5_           `#17 /
DEFTABE OkZ__      `OkZro           `#18
`--- poniżej dla SMSa bajtowego konfigu/obszaru
DEFTABE chAsB           `#19 +591tkt sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1A         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1B         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1C         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1D         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1E         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE chAsB           `#1F         sprawdzanie autosumy treści SMSa bajtowego
DEFTABE SMb5_           `#20 +510tkt analizuje typ SMSa bajtowego i wstęp dla przeładowania
`                              tutaj majster wyskakuje na kroczek #10
DEFTABE _LDIR           `#21 +198tkt \
DEFTABE LDIR_           `#22 +655tkt  \
DEFTABE LDIR_           `#23           \przeładowuje treść SMSa w
DEFTABE LDIR_           `#24           /założone miejsce RAM
DEFTABE LDIR_           `#25          /
DEFTABE LDIR_           `#26         /
DEFTABE SMb6_           `#27 +368tkt \
DEFTABE SMb7_           `#28 +557tkt |po przeładowaniu, zabawa dla konfigu, obszaru i bajtowego
DEFTABE SMb8_           `#29 +632tkt /
DEFTABE SMm4_           `#2A         \
DEFTABE SMm5_           `#2B          \ zabawa dla majstra
DEFTABE SMm6_           `#2C           \
DEFTABE SMm7_           `#2D           /
DEFTABE SMm8_           `#2E          /
DEFTABE SMm9_           `#2F         /
`DEFTABE SMma_           `#30         
`DEFTABE SMmb_           `#31         
`DEFTABE SMmc_           `#32         
`DEFTABE SMmd_           `#33         
`DEFTABE SMme_           `#34         
`DEFTABE SMmf_           `#35         
`DEFTABE SMmg_           `#36         
`DEFTABE SMmh_           `#37         
`DEFTABE SMmi_           `#38         
`DEFTABE SMmj_           `#39         
`DEFTABE SMmk_           `#3A         
`--------------
DEFETYK @ISMrd   `adres tablicy adresów kroków do analizy SMSów odczytanych
`---                       
DEFTABE _#03_           `#05 +521tkt +++++++++
DEFTABE #03_3           `#06 +422tkt 
DEFTABE #03_4           `#07 +532tkt
`--- poniżej będzie kilka wywołań dla tekstowego/bajtowego (#03)
DEFTABE CPIR_           `#08 +619tkt porównaj z 1-szym znanym \
DEFTABE CPIR_           `#09         porównaj z 2-gim znanym  |
DEFTABE CPIR_           `#0A         porównaj z 3-cim znanym  |
DEFTABE CPIR_           `#0B         porównaj z 4-tym znanym  |
DEFTABE CPIR_           `#0C         porównaj z 5-tym znanym  |
DEFTABE CPIR_           `#0D         porównaj z 6-tym znanym  |
DEFTABE CPIR_           `#0E         porównaj z 7-tym znanym  |
DEFTABE CPIR_           `#0F         porównaj z 8-tym znanym  |
DEFTABE CPIR_           `#10         porównaj z 9-tym znanym  |
DEFTABE CPIR_           `#11         porównaj z 10-tym znanym /
DEFTABE SMSd1           `#12 +322tkt \
DEFTABE SMSd2           `#13 +408tkt  \przelicza rok, miesiąc, dzień, 
DEFTABE SMSd3           `#14 +459tkt  /godz min i sek oraz dzień tyg z SMSa
DEFTABE SMSd4           `#15 +551tkt /
DEFTABE SMSd5           `#16 +470tkt \analizuje możliwość ustawienia zegara systemu i ew.
DEFTABE SMSd6           `#17 +263tkt /ustawia go
DEFTABE SMtb?           `#18 +645tkt decyduj jakiego rodzaju to SMS (tekst/bajty) i co dalej
`--- a tutaj już tylko dla tekstowego
DEFTABE ENIGI           `#19 +597tkt  8   znaków \SMS tekstowy (#02)
DEFTABE ENIGI           `#1A         16  znaków |rozkodowano znaków ASCII
DEFTABE ENIGI           `#1B         24  znaki  |
DEFTABE ENIGI           `#1C         32  znaki  |
DEFTABE ENIGI           `#1D         40  znaków |
DEFTABE ENIGI           `#1E         48  znaków |
DEFTABE ENIGI           `#1F         56  znaków |
DEFTABE ENIGI           `#20         64  znaki  |
DEFTABE ENIGI           `#21         72  znaki  |
DEFTABE ENIGI           `#22         80  znaków |
DEFTABE ENIGI           `#23         88  znaków |
DEFTABE ENIGI           `#24         96  znaków |
DEFTABE ENIGI           `#25         104 znaki  |
DEFTABE ENIGI           `#26         112 znaków |
DEFTABE ENIGI           `#27         120 znaków |
DEFTABE ENIGI           `#28         128 znaków |
DEFTABE ENIGI           `#29         136 znaków |
DEFTABE ENIGI           `#2A         144 znaki  |
DEFTABE ENIGI           `#2B         152 znaków |
DEFTABE ENIGI           `#2C         160 znaków /
DEFTABE SMtpo           `#2D +372tkt /odblokowuje bufor SMSów -zapisuje l.znaków
`-----------------------------------------
`
`wspólna dla wszystkich SMSów odebranych i odczytanych, ustala typ SMSa, podstawowe
`adresy i zmienne, sprawdza czy nie jest zaznaczony do skasowania, rozgałęzia dalczy
`ciąg algorytmu na SMSy delivery oraz SMSy tekstowe/bajtowe
`trwa +509tkt ++++++++         
LD HL,#80DC            @_#02_ `SMS odebrany -adres liczby liter odebranego SMSa -3
` pozycja jest w #80CE -nie zmieniam tego bajtu bo tu JEST pozycja w odebranym i tu ma być!
LD C,(HL)                     `[#80DC] określa typ SMSa pierwszy bajt
INC L                         `
LD A,(HL)                     `[#80DD] nr umowny odebranego delivery
LD (#80CF),A                  `nr umowny dla delivery
INC L                         `
LD A,C                        `określa typ SMSa pierwszy bajt
LD C,(HL)                     `[#80DE] określa typ SMSa drugi bajt
INC L                         `#80DF adr. na future
LD B,#00                      `7bit =0 a więc odebrany!
` bajt =#06 i 2gi bajt =#00 -> delivery #00
` 2gi bajt =#00             -> tekstowy #01
` 2gi bajt =#F5             -> bajtowy  #02
JR @_1SMa                     `+12+548 działaj dalej z tym SMSem
`---                           
`trwa +521tkt ++++++++         
LD HL,#80DD            @_#03_ `adres liczby liter odczytanego SMSa -3
LD DE,#80CF                   `adres pomocniczy 
LD A,(DE)                     `pozycja na SIM SMS odczytany
LD (#80CE),A                  `zapisz pozycję
LD C,(HL)                     `[#80DD] określa typ SMSa pierwszy bajt
INC L                         `#80DE 
LD A,(HL)                     `[#80DE] nr umowny delivera
LD (DE),A                     `
INC L                         `#80DF
LD A,C                        `określa typ SMSa pierwszy bajt
LD C,(HL)                     `[#80DF] określa typ SMSa drugi bajt
INC L                         `#80E0 adr. na future
LD B,#80                      `7bit =1 a więc odczytany!
` bajt =#06 i 2gi bajt =#00 -> delivery #80
` 2gi bajt =#00             -> tekstowy #81
` 2gi bajt =#F5             -> bajtowy  #82
AND #0F                @_1SMa `+441tkt rodzaj otrzymanego SMSa
CP #06                        `
`CP #C6                        `
`CP #46                        `
LD A,C                        `określa typ SMSa drugi bajt
JR NZ,@NOdel                   `hop -> inny niż delivery, analizuj dalej
AND A                         `
JR Z,@_1Szn                   `hop -> delivery
` tutaj gdy delivery o NIEDOSTARCZENIU wiadomości SMS
INC B                  @NOdel `
`LD A,C                       `określa typ SMSa drugi bajt
AND A                         `
JR Z,@_1Szn                   `hop -> tekstowy
INC B                         `
CP #F5                        `
JR Z,@_1Szn                   `hop -> bajtowy
`   tutaj nieznany typ SMSa... 
LD D,#02               @doEsk `+173tkt czyli ma 'chińskie'
JR @do_??                     `+12+154tkt
LD D,#01               @do_sk `+161tkt czyli ma być do skasowania
LD HL,#8030            @do_?? `+154tkt 
`#8030 -> 23& (#17)bajtów [bez przełomu!] odpowiada poszczególnym pozycjom SMSów na SIM 
`         i określa co zrobić z tą pozycją w czasie analizy (czy ignorować) i w czasie
`         cyklicznego odczytu. W czasie cyklicznego nie sprawdza &09 i &0A
`          #01 -SMS do skasowania, skasować ten SMS,
`          #02 -zaznaczony do skasowania pierwszy raz -'chińskie'
`          #00, #03-#7F -bez znaczenia dla przeszukiwania cyklicznego
`          #80 -#FF -zablokowany -cykliczna nie żąda tego SMSa
LD A,(#80CE)                  `pozycja SMSa
DEC A                         `gdy =1 to delta ma być=0 bo poz. 1 jest pierwsza (->+0)
CP #19                        `spr czy <&25 czyli dozwolone (0 - &24 czyli poz. 1-&25
JR NC,@_O_Zr                  `+12+41 hop -> nieokreślony error -> zła wartość pozycji SMSa
ADD A,L                       `
LD L,A                        `
LD A,D                        `
CP #02                        `czy to wielokrotna kwalifikacja do skasowania?
JR NZ,@LA.;A                  `+12+48
LD A,(HL)                     `
CP #01                        `czy już zakwalifikowany do skasowania?
JR Z,@_O_Zr                   `+12+41tkt tak, przejdź do SecondInAnalizy
CP #02                        `
JR NZ,@LA.;A                  `+12+48
DEC D                         `D=#01 czyli do skasowania
LD (HL),D              @LA.;A `+48
JP @OkZro              @_O_Zr `+10+31tkt zrobione, przejdź do SecondInAnalizy
`---                            
LD A,B                 @_1Szn `+365tkt znamy typ (w Brej)
`         #80CB- 1b -> typ SMSa odebranego :#00-delivery, #01-tekstowy, #02-bajtowy
`                               odczytanego:#80-delivery, #81-tekstowy, #82-bajtowy
LD DE,#80CB                   `D nie zawsze tutaj =#80!
LD (DE),A                     `typ SMSa
INC DE                        `
LD A,(HL)                     `liczba liter (dla tekstowego)
LD (DE),A                     `zapamiętaj l.liter
INC HL                        `
LD (#80C9),HL                 `zapamiętaj adres pierwszego bajtu nr-u nadawcy
LD BC,#000C                   `
ADD HL,BC                     `po tym adres HL to rok otrzymania SMSa
LD (#80DD),HL                 `obl. adres roku otrzymania (później data i czas...)
LD C,#07 `LD BC,#0007         `
ADD HL,BC                     `adres HL to treść tekstu
LD (#80D1),HL                 `dynamiczny adres treści SMSa (text/bajt)
LD (#80D5),HL                 `adres treści SMSa (text/bajt) też dymaniczny
LD (#8183),HL                 `adres treści SMSa bajtowego dla majstra
LD HL,#85EC                   `adres w buforze rozkodowanych SMSów
LD (#80D3),HL                 `zapisz adres tutaj
LD A,(#80CE)                  `pozycja SMSa
DEC A                         `(bo poz. SMSów zaczynają się od #00)
CP #19                        `spr czy 1...25& (wartość 0-&24 [#00-#18])
JP NC,@OkZro                  `hop wartość błędna bo z poza zakresu
CP #08                        ` =poz. #09
JR Z,@__1Sz                   `hop -> pozycja konfigu
CP #09                        ` =poz. #0A
JR Z,@__1Sz                   `hop -> pozycja konfigu
`       sprawdzimy czy nie jest zaznaczony do skasowania
LD HL,#8030                   `adr. tabeli RAM SMSów na SIM
`#8030 -> 25& (#19) [bez przełomu!] odpowiada poszczególnym pozycjom SMSów na SIM i określa 
`          #01 -SMS do skasowania, skasować ten SMS,
ADD A,L                       `\
LD L,A                        `/oblicz adres w RAMtabeli SMSów z SIM
LD A,(HL)                     `czy i ew. do czego zaznaczony ten SMS
CP #01                        `czy do skasowania?
`JR NZ,@__1Sz                 `
`
`poniższe CALL @_#28_, ani CALL @incSM niepotrzebne, bo cyklicznie nie będzie wywoływał
`zaznaczonych do skasowania, tylko kasował, a dla pozycji konfigu tu nie wchodzi...
`tak więc można poniższe CALL spokojnie wywalić
`CALL @incSM   `CALL @_#28_   `zostaw tego SMSa w spokoju, bo jest zazn. do skasow.
`                 czyli zachowaj się tak jakby odpowiedź brzmiała: 'brak SMSa na tej poz'
JP Z,@OkZro                   `+10+31tkt i zachowaj się tak jakby 'brak SMS na tej. poz.'
DEC DE                 @__1Sz `+85tkt znamy typ (w Brej)
LD A,(DE)                     `
`         typ SMSa odebranego :#00-delivery, #01-tekstowy, #02-bajtowy
`                  odczytanego:#80-delivery, #81-tekstowy, #82-bajtowy
AND #03                       `
LD A,#03                      `co oznacza tekstowy/bajtowy
JR NZ,@_noDe                  `hop -> nie delivery
LD A,#02                      `#02 co oznacza delivery
LD (#80C7),A           @_noDe `+44tkt zapisz odpowiedni podkod 
` dla delivery: przygotuj się do przeszukiwania wysłanych nrów umownych
LD A,#FF                      `znacznik gdy nie znaleziono w tabeli oczekujących del.
LD (#80D0),A                  `
RET                           `
`-----------------------------------------------
`
`pomocnicza przy analizie SMSów
` wynik: w Brej pozycja SMSa   
`trwa: 126tkt ---                 
LD A,(#80CE)           @#23_3 `poz. SMSa
LD B,A                        `zach pozycję
LD A,(#802E)                  `DKrok
INC A `CP #FF                 `czy wolny?
RET NZ `JR NZ,@noCyC          `to nie cykliczne bo DKrok zajęty
LD A,(#80CB)                  `typ SMSa
LD C,A                        `zach typ SMSa
AND #F0                       `zostaw odczytany/odebrany
RET Z  `JR Z,@noCyC           `hop -> odebrany
LD HL,#802F                   `
LD A,(HL)                     `przy poszukiwaniu cyklicznym trza by cyknąć następny
CP B                          `czy ta sama co cyklicznie poszukiwana?
RET NZ `JR NZ,@noCyC          `inna pozycja niż żądana
INC A                         `cyknij bo to odczytany cykliczny
LD (HL),A                     `zapamiętaj cykliczną
`SCF                   `@noCyC `nie cykliczny, ale bezbłędnie
RET                           `C=oki
`-----------------------------------------------
`
`dla delivery, szuka znaczników SMSów oczekujących na dostarczenie
`trwa: +422tkt 
CALL @#23_3            @#02_3 `+17+126tkt ew incknij cykliczne przeszuk.
LD HL,#8082                   `adr tabeli delivery
`LD (#80D7),HL                 `adres w przeszukiwanej tabeli umownych numerów wysłanych SMSów
LD B,#03                      `ile numerów do sprawdzenia
JR @nxDv_                     `+12+250 hop -> sprawdź umowne numery w tej tabeli
`-----------------------------------------------
`
`dla delivery, szuka znaczników SMSów oczekujących na dostarczenie
`trwa: +221tkt 
LD B,#02               @#02_4 `ile numerów do sprawdzenia
JP @_nxDv                     `+10+204tkt hop -> sprawdź umowne numery w tej tabeli
`---------------------------------------
`
`pomocnicza przeszukiwania tabeli numerów umownych oczekujących na delivery
`trwa max. +459tkt
`                                /dla odczytanego i odebranego!/
LD B,#06               @SMdxf `sprawdzaj Brej numerów umownych
`       poniżej trwa MAX dla B=2:+204tkt dla B=3:+266tkt dla B=6:+452tkt 
LD HL,(#80D7)          @_nxDv `adres w przeszukiwanej tabeli umownych numerów wysłanych SMSów
LD A,(#80CF)           @nxDv_ `umowny nr SMSa którego dotyczy delivery
CP (HL)                @nxDvS `trwa max: [(B-1)*62+97]tkt pętla -sprawdzaj kolejny
INC HL                        `nie zmienia rejF
JR NZ,@nieTo                  `hop -> inny numer umowny
LD A,(HL)                     `odczytaj czas
AND A                         `czy =0?
JR Z,@nieTo                   `+12+19tkt ;o) hop -> wartość nieistotna bo czas=0
LD C,A                        `tutaj mamy go!, czas w sekundach od wysłania
SUB A                         `\
LD (HL),A                     `/zeruj czas, co jest równoznaczne z wykasowaniem
`DEC HL                        `
`LD (HL),A                     `zeruj numer umowny, co jest równoznaczne z wykasowaniem
JR @jużpo                     `+12+48tkt hop -> znaleziony, zatopiony
INC HL                @nieTo  `
DJNZ @nxDvS                   `zapętl na następny SMS 
JR @;LSJA                     `
`nie trzeba przerzucać przerwań, ilość przerwań nie ma znaczenia a drugiego takiego nru
`nie znajdzie przecież!         
LD A,C                 @jużpo `+48tkt
DEC A                         `bo rozpoczynał liczenie od 1 a nie 0
LD (#80D0),A                  `zapamiętaj ile sekund czekaliśmy na delivery (#00-#FE)
LD (#80D7),HL          @;LSJA `adres w przeszukiwanej tabeli umownych numerów wysłanych SMSów
RET                           `czyli ew.ustaw czas
`----------------------------------------------------------
`
`dla delivery sprawdzaj czasy
`trwa: +430tkt
LD HL,#80F3            @SMde1 `adres roku delivery odczytanego +1 /momentu doręczenia/
LD A,(#80CB)                  `typ SMSa
`         typ SMSa odebranego :#00-delivery, #01-tekstowy, #02-bajtowy,
`                  odczytanego:#80-delivery, #81-tekstowy, #82-bajtowy, (#83-config...),
AND A                         `
JR NZ,@_Sd11                  `hop -> to nie odebrany deliver (tylko odczytany)
DEC HL                        `LD HL,#80EB adres roku delivery odebranego
LD A,(#80D0)                  `czas czekania na tego delivera
CP #3C                        `=&60 sekund
JR C,@_Sd11                   `hop -> dobry czas, mniej niż minuta
`tutaj za długi czas -> zamień typ SMSa na delivery odczytany, co 
`uniemożliwi ustawienie StatusTime =#03... ale umożliwi poprawienie zegara systemu.
`LD A,#80                      `delivery odczytany
LD (#80CB),A                  `wart. inna niż #00 (teraz i tak już bez znaczenia)
LD (#80DD),HL          @_Sd11 `adr. roku do analizy daty z SMSa i ew. ust zegara systemu
JR @SMSd1                     `+12+322tkt
`----------------------------------------------------------
`
`analiza po rozkodowaniu tekstu, no i data/czas otrzymania
`trwa +372tkt
LD D,#00               @SMtpo `starszy bajt =0
LD A,(#80CC)                  `liczba liter tekstu SMSa
LD E,A                        `liczba liter =długość rozkodowanego w bajtach
LD HL,#85EC                   `początek tekstu
ADD HL,DE                     `oblicz adres za tekstem
LD (HL),D                     `zapisz znak końca tekstu #00
LD A,(#80CC)                  `liczba liter tekstowego SMSa
`  wartość tego bajtu różna od #00 i od #FF i od #FE oznacza
`  że to SMS bajtowy a ta właśnie wartość jest liczbą znaków ASCII rozkodowanego SMSa
`  #FE oznacza że to SMS bajtowy o stałej długości treści =#008A bajtów
LD (#85D8),A           @_SMpo `+307tkt bufor rozkodowanych SMSów tekstowych 
`                                 (odblokuj i zapisz liczbę znaków)
LD A,(#80CE)                  `pozycja rozkodowanego SMSa
LD (#868D),A                  `zapisz w buforze rozkodowanych SMSów
LD HL,#868F                   `adr. sekund rozkodowanego momentu z SMSa
LD DE,#85E5                   `adr. sekund wynikowego rozkodowania SMSa text/bajt w buforze
LD BC,#0007                   `bo DT też
LDIR                          ` 142tkt=7*21-5
LD C,#83                      `znacznik ignoruj_bo_w_buforze
JP @_SMb8                     `+10+79tkt 
`----------------------------------------------------------
`   komplet procedur do analizy 6 bajtów daty i czasu      
`   umieszczonych od (#80DD) i dalej                       
`   jeśli analiza jest błędna to wynikowa wartość roku =#00`   wynik to:                                              
`  [@SMSd3]   (#868F) <- sekundy (#00-#3B)                 
`  [@SMSd3]   (#8690) <- minuty  (#00-#3B)                 
`  [@SMSd3]   (#8691) <- godziny (#00-#17)                 
`  [@SMSd2]   (#8692) <- dni miesiąca (#00 - #1E)          
`  [@SMSd1]   (#8693) <- miesiące nasze:[#00 - #0B]        
`                         /#00 to styczeń, #0B to grudzień/
`  [@SMSd1]   (#8694) <- lata           (#05 = 2005r)      
`  [@SMSd4]   (#8695) <- dni tygodnia (#00-#06)            
`                           (#00 to poniedziałek)          
`
`analiza roku i miesiąca SMSów (wszystkie rodzaje SMSów)
`wejście to adres roku w (#80DD)
`trwa +322tkt
LD DE,(#80DD)       @SMSd1 `adr. roku do przetworzenia z SMSa
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
`                  dla &09 (&24?) wartość roku i miesiąca przed wywołaniem jest zerowana, 
`                  tak więc jeśli olewamy to =0
LD H,A                     `(#8694) zapisujemy znów w miejsce tmp. już przeliczony
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
DEC A                      `
LD L,A                     `(#8693) miesiąc
LD (#8693),HL              `miesiąc i rok zapisz
`L(#8693) <- miesiące nasze:[#00 - #0B] /#00 to styczeń, #0B to grudzień/
`H(#8694) <- lata           (#05 = 2005r)
CP #0C                     `=&12 a grudzień to #0B
`             gdy #00-#0B to CY=oki
`                       else NC =error
LD (#80DD),DE              `adr. dnia m-ca
RET C                      `gdy ok
SUB A               @SmErB `+28tkt
LD (#8694),A               `w miejsce roku 2000 a więc zły rok...
RET                        `
`----------------------------------------------------------
`
`analiza dnia miesiąca SMSów (wszystkie rodzaje SMSów)
`wejście to adres dnia miesiąca w (#80DD)
`trwa +408tkt
LD DE,(#80DD)       @SMSd2 `adr. dnia miesiąca do przetworzenia z SMSa
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
LD (#80DD),DE              `adr. godziny
DEC A                      `dzień miesiąca (#00-#1E)
LD (#8692),A               `dzień miesiąca
`(#8692)<-dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
LD D,A                     `dzień miesiąca (#00-#1E)
LD HL,#8694                `adres roku (#8694)
LD E,(HL)                  `rok
DEC HL                     `adres miesiąca (#8693)
LD A,(HL)                  `miesiąc
CALL @DmArE                `+17+149tkt w Acc wychodzi liczba dni (np &31 to #1E) w mies. A rok.E
`D sprawdzana liczba dni (np &31 to #1E)
`A maksymalna liczba dni (np &31 to #1E)
CP D                       `maksymalna (np &31 to #1E) minus sprawdzana (np &31 to #1E)
`  CY =error            -> gdy sprawdzana > maksymalna
`  NC=oki                  `
JR C,@SmErB                `+12+28hop -> error
RET                        `
`----------------------------------------------------------
`
`analiza godziny, minuty i sekundy SMSów (wszystkie rodzaje SMSów)
`wejście to adres godziny w (#80DD)
`trwa +459tkt
LD DE,(#80DD)       @SMSd3 `adr. godziny do przetworzenia z SMSa
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
`(#868F)sekundy,            
`(#8690)minuty,             
`(#8691)godziny,            
LD HL,#8691                `adr. godziny
LD (HL),A                  `
CP #18                     `bo &23 to #17
JR NC,@SmErB               `+12+28hop -> error
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
DEC HL                     `adr. minuty
LD (HL),A                  `minuta
CP #3C                     `bo &59 to #3B
JR NC,@SmErB               `+12+28hop -> error
CALL @BCD>>                `+17+90 zamień dwa oktety na liczbę
DEC HL                     `adr. sekundy
LD (HL),A                  `sekunda
CP #3C                     `bo &59 to #3B
JR NC,@SmErB               `+12+28hop -> error
RET                        `
`----------------------------------------------------------
`
`obliczenie dnia tygodnia SMSów (wszystkie rodzaje SMSów)
`wejście to odczytane rok, miesiąc i dzień mca
`trwa +551tkt
LD HL,#8692         @SMSd4 `adres dni miesiąca
LD D,(HL)                  `dni
INC HL                     `
LD A,(HL)                  `miesiące
INC HL                     `
LD L,(HL)                  `lata
LD H,A                     `miesiące

`(#8692)dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`(#8693)miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`(#8694)lata           (#05 = 2005r)
`   w Acc wyjdzie dzień tygodnia roku L (#05 to 2005r),
`   miesiąca H (#00=styczeń) i dnia D (#00 to 1 'pierwszy') trwa max. 463tkt
CALL @jakDT                `+17+463 oblicz DT
LD (#8695),A               `dzień tygodnia (#00 to poniedziałek)
RET
`----------------------------------------------------------
`
`zamienia Acc na liczbę
`wejście Acc w formie dwóch 4 bitowych cyfr starsza to jednostki, młodsza -dziesiątki
`wyjście Acc liczba 
`zmienia AFBC
`trwa 90tkt
LD A,(DE)          @BCD>> `to samo tylko pobiera z (DE) I INC DE
INC DE                    `
LD B,A                    `całość
RRCA                      `
RRCA                      `
RRCA                      `
RRCA                      `
AND #0F                   `jednostki 
LD C,A                    `jednostki 
LD A,B                    `
AND #0F                   `ile dziesiątek
LD B,A                    ` 
ADD A,A                   `\
ADD A,A                   ` |tutaj *10
ADD A,B                   ` |
ADD A,A                   `/
ADD A,C                   `dodaj jedności
RET
`----------------------------------------------------------
`
`analizuje możliwości ustawienia zegara systemu z daty i godziny SMSa
`   wynik decyzji w czy ustawiać, czy nie jest w #8696
`   #00 -nie ustawia,       
`   gdy >#00 (czyli #01 lub #04) to ustawia i robi taki time status...
`trwa +470tkt
LD C,#04            @SMSd5 `StatusTime po ustawieniu gdy otrzymany delivery
`LD B,C                     `
LD HL,#8694                `adr. roku w SMSie
LD DE,#8009                `adr. roku systemu
SUB A                      `=tzn. nie ustawiaj czasu
LD (#8696),A               `zapisz domyślne =nie ustawiaj czasu z SMSa
LD A,(HL)                  `odczytaj rok
CP #05                     `czy rok <2005?
RET C                      `wyjście gdy błędna data/godzina
LD A,(#80CB)               `#00 to odebrany delivery
AND A                      `
JR Z,@InDel                `hop -> to odebrany delivery
LD C,#01                   `StatusTime po ustawieniu gdy zwykły SMS
LD A,(#8001)        @InDel `odczytaj StatusTime
`              #00-nieustawiony
`                    -------
`                      #01-ustawiony z configu lub SMSa (czyli też zły)
`                      #02-ustawiony z zegara NOKIA (może być zły)
`                    -------
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno
`                    -------
`              #04-ustawiony z delivery niedawno
`              #05-...          
JR NZ,@c<>04               `+12+347tkt
`CP B                       `
CP C                       `=#04   Obecny - #04
RET NC                     `
JR @AlSet                  `
CP #03              @c<>04 `+347tkt
RET NC                     `
AND A                      `czy StatusTime=0?
SCF                        `
`  DE= adr. roku aktualnego czasu z systemu
`  HL= adr. roku czasu z SMSa 
CALL NZ,@CpTim      `@ifSet `+17+277tkt /tylko gdy StatusTime >0/
`  CY gdy (HL) jest bardziej zaawansowany od (DE) lub
`  NC gdy odwrotnie lub gdy równe
RET NC                     `
LD A,C              @AlSet `+28tkt jaki ma być StatusTime po ustawieniu
LD (#8696),A               `zapisz
RET                        `
`-----------------------------------------------------------
`
` procedurę [@CpTim] wykorzystujemy do porównania czasów (HL) i (DE):
` zmienia rejestry: AF, HL, DE, B
`  CY gdy (HL) jest bardziej zaawansowany od (DE) lub
`  NC gdy odwrotnie lub gdy równe
`trwa +277tkt max
LD B,#06            @CpTim `sprawdzamy 6 bajtów
LD A,(DE)           @ptl63 `rok systemowy, potem miesiąc ...i aż do sekundy
CP (HL)                    `systemowy minus z SMSa
RET NZ                     `
` C  -> (HL) bardziej zaawansowana od (DE)
` NC -> (DE) bardziej zaawansowana od (HL)
`  równe to porównuj dalej  
DEC HL                     `\kolejna wielkość
DEC DE                     `/
DJNZ @ptl63                `nie zmienia rejF pętla [przy UStaW: 43+ 256tkt =5*(33+13)+26
RET `(NC)                  `RET -> (DE) ma b.zaawansowany czas lub równe
`----------------------------------------------------------
`
`jeśli trzeba to ustawia czas systemowy i zmienia SystemTime i ew. DKrok do zapisu konf i zegara
`trwa +263tkt +17tkt  ++++++++  
LD A,(#8696)        @SMSd6 `odczytaj decyzję do zmiany i StatusTime po niej
AND A                      `czy =0?
RET Z                      `wyjście gdy decyzja =nie ustawiaj
LD (#8001),A               `
CP #04                     `czy to z delivery?
JR NZ,@__SM6
LD A,#18                   `=&24 godziny uznajemy że jest ustawiony (delivery)
LD (#809E),A               `a później tylko orientacyjnie ustawiony
LD HL,#868F         @__SM6 `adr.sekund SMSa
LD DE,#8004                `adr. sekund systemu
LD BC,#0007                `bo DT też
LDIR                       ` 142tkt=7*21-5
CP #03                     `czy StatusTime < #03 ?
LD HL,#807D                `adr. minutnika zapisu konfigów

LD A,#01                   `konieczność zapisu konfigów do SIM
JR NC,@_SMS6               `tak, zapisz teraz
LD A,#03                   `\konieczność wkrótce zapisu konfigów do SIM
LD (HL),A           @_SMS6 `/

SUB A                      `+00h poprawki godzin przy ich przeskoku
LD (#86F5),A               `
LD HL,#8000                `\ustaw, że nieaktualne ASCIIdatyczasu
SET 0,(HL)                 `/
RET                        `
`----------------------------------------------------------
`
`dla bajtowych/tekstowych, ocenia czy to numer konfigu, czy bajtowy to obszar/majster
`trwa: +442tkt              
CALL @#23_3         @#03_3 `+17+126tkt ew incknij cykliczne przeszuk.
` w Brej jest pozycja tego SMSa
LD A,#FF                   `kod nierozpoznany
LD (#809F),A               `zapisz nierozpoznany
LD DE,#80CB                `pomocniczy adres (szybciej i taniej!)
LD A,(DE)                  `typ SMSa
CP #82                     `
JR NZ,@toNiK               `hop -> to nie konfig (nie odczytany bajtowy)
LD A,B                     `
CP #09                     `\
JR Z,@PoZkO                `|czy poz. konfigów?
CP #0A                     `/
JR NZ,@toNiK               `hop -> to nie konfig (pozycja inna niż 9/#0A)
LD HL,(#80C9)       @PoZkO `+450tkt adr. nru nadawcy
LD A,(HL)                  `liczba znaków
CP #14                     `=&20
JR NZ,@toNiK               `hop -> to nie konfig -inna liczba znaków niż &20
INC HL                     `
INC HL                     `
LD A,(HL)                  `cyfry 1 i 2
CP #21                     `
JR NZ,@toNiK               `+12+141tkt hop -> to nie konfig -cyfry inne niż 12...
`        tutaj numer nadawcy konfigowy
LD A,#83                   `
LD (DE),A                  `typ =konfig
`LD A,#8A                   `numer konfigowy [właściwie cokolwiek z poza zakresu CPIRów]
LD (#809F),A               `wynik rozpoznania przez CPIR (które wtedy nie porównują)
` nie musi przeskakiwać CPIRów bo i tak nie będą porównywały...
RET                        `ret -> dalej 
LD A,(DE)           @toNiK `+141tkt to nie konfig, ale może bajtowy jakowyś
AND #03                    `ignoruj odczyt/odbiór zostaw tylko rodzaj SMSa
CP #02                     `czy to bajtowy
RET NZ                     `ret -> to tekstowy
LD HL,(#80D1)              `adr. treści
LD C,(HL)                  `\
INC HL                     ` |odczytaj bajty ID SMSa bajtowego
LD A,(HL)                  `/
CP #27                     `czy to majster?
JR Z,@majsT                `+12+41tkt hop -> chyba majster
CP #5A                     `czy to obszar?
RET NZ                     `hop -> bo nie majster i nie obszar
LD A,C                     `pierwszy bajt ID
CP #A5                     `czy to napewno obszar?
RET NZ                     `hop -> bo nie obszar
LD A,#84                   `kod obszaru
JR @ObMaT                  `+12+18tkt zapisz kod SMSa typu obszaru
LD A,C              @majsT `+41tkt pierwszy bajt ID
CP #72                     `czy to napewno majster?
RET NZ                     `hop -> bo nie majster
LD A,#85                   `kod majstra
LD (DE),A           @ObMaT `+18tkt zapisz typ SMSa
RET                        `
`---------------------------
`
`przygotowanie do rozpoznawania numeru nadawcy SMSa bajt/text
`trwa: +532tkt +++++44tkt     
LD HL,#80A1           @#03_4 `wyzeruj numer do porównań
LD E,L                       `^ z #80A1
LD D,H                       `
INC DE                       `na #80A2
LD BC,#0009                  ` 9 bajtów
LD (HL),B                    ` załaduj wartością #00
LDIR                         `+tkt= 9*21-5
LD HL,(#80C9)                `odczytaj adres nru nadawcy SMSa
LD A,(HL)                    `odczytaj liczbę cyfr
LD DE,#80A0                  `tu przepisz numer nadawcy
INC HL                       `
` tu sprawdzimy typ numeru nadawcy
`                                   
`normalny numer: #91
`SMS Tak tak: ? SMS kto tam: ?
`było też tak: #08 #91 #84 #06 #92 #90 #F3 #70 #11 #81 #10 #61 "+48602909 SMS z Erakodem"
`było też tak: #03 #81 #11 #F1 #07 #91 #04 #00 #00 #A0 #08 #91 "111"
`było też tak: #04 #BD #89 #89 #92 #90 #00 #00 #70 #11 #81 #22 "9898" SMS o doładowaniu"
`było też tak: #05 #BD #17 #88 #F0 #34 #00 #00 #00 #22 #93 #94 "71880 odbiór SMSa z tego numeru"
`                                   
`czyli sprawdzamy bity 6-4 i jeśli równe (po AND #70) #50 to alfanumeryczny
`                             
LD C,A                       `zachowaj liczbę cyfr
LD A,(HL)                    `
AND #70                      `
CP #50                       `
LD A,C                       `
JR NZ,@WKNPO                 `
SET 7,A                      `oznacza że to tekstowo numer
`                             
LD (DE),A             @WKNPO `zapamiętaj liczbę cyfr nadawcy
INC DE                       `=#80A1
INC HL                       `adr 1szy bajt numeru
`  HL=adres pierwszego bajtu cyfr nadawcy SMSa
INC A                        `liczba cyfr numeru +1
RRCA                         `\
AND #0F                      `/czyli A=A/2
CP #0B                       `dla &20 cyfr #0A bajtów max.!
`LD B,#00                     `już jest #00 (chyba)
LD C,A                       `BC=liczba bajtów do przesłania
JR NC,@nxBaj                 `+12+31tkt hop -> zła długość numeru 
LDIR                         `max +205tkt=10*21-5
RET                          `
LD A,#FC              @nxBaj `+31tkt kod rozpoznania numeru =error
LD (#809F),A                 `zapisz
RET                          `
`-------------------------------------------------
`
`porównuj do kolejnych 10& numerów znanych (trzeba to po prostu wywołać &10 razy pod rząd)
`sama sobie zmienia indeks do kolejnych porównań
`wejście: w bajcie (#809F) znajduje się wartość z zakresu #FF-#08, 
`czyli pomniejszony o 1 (bo INC A) numer, który będzie sprawdzany
`wyjście: a bajcie (#809F) jest wartość zwiększona o 1 gdy różne,
`                          lub z 7bit=1 numer jeśli identyczne
`trwa: 619tkt max.
LD DE,#809F          @CPIR_ `adres pomocniczy (szybciej i taniej!)
LD A,(DE)                   `wejściowe -nimer minus 1 do porównania,
INC A                       `tu numer znanych do którego mamy porównać 
CP #0A                      `
RET NC                      `
LD (DE),A                   `
LD HL,#856A                 `pocz. tabeli znanych !!! bez przełomu!!!
LD C,A                      `
ADD A,A                     `*2
ADD A,A                     `*4
ADD A,C                     `*5
ADD A,A                     `*10 
ADD A,C                     `*11 bo &11 bajtów ma 1 rekord tablicy znanych
ADD A,L                     `
LD L,A                      `tu obliczony adres przed początkiem numeru w tabeli znanych
JR NC,@AWLEJ                `
INC H                       `
INC DE               @AWLEJ 
LD A,(DE)                   `liczba cyfr numeru
CP (HL)                     `porównaj ze znanym
RET NZ                      `RET gdy różne wtedy (#809F) tylko zwiększona o 1,
LD A,(HL)                   `odczytaj liczbę cyfr znanego
AND A                       `czy =0? (wtedy znany jest pusty)
RET Z                       `wyjdź i nie porównuj bo tu nie ma znanego
INC DE                      `
LD B,#0A                    `&10 bajtów ma jeden numer
LD A,(DE)            @nXzNA `
INC HL                      `
CP (HL)                     `
RET NZ                      `RET gdy różne wtedy (#809F) tylko zwiększona o 1,
INC DE                      `
DJNZ @nXzNA                 `następny znak
LD HL,#809F                 `ten znaleziony
SET 7,(HL)                  `
RET                         `
`-------------------------------------------------
`
` po CPIR w (#809F) jest jedna z wartości:
` #FD -gdy błędny numer, #09 gdy nierozpoznany, #80-#89 gdy rozpoznany
` trwa:+106tkt
LD DE,#809F            @poCPR `szybciej i taniej!
LD A,(DE)                     `tu wynik porównania
CP #FC                        `kod błędnego numeru nadawcy
RET Z                         `RET -> błędny
XOR #80                       `odwróć 7 bit Acc
CP #0A                        `do tej wartości znaczy że rozpoznany
JR C,@roz__                   `hop -> znany
LD A,(#807F)                  `czy przeczytana cała książka telefoniczna?
CP #FF                        `(czyli czy mamy all znane)
LD A,#FD                      `kod= nierozpoznany, ale nieodczytana cała ks.tel jeszcze
JR NZ,@roz__                  `NZ ret -> nie znamy całej ks tel, więc do odczytania później
INC A `LD A,#FE               `=nieznany, odczytana cała ks tel.
LD (DE),A              @roz__ `wynik rozpoznania
RET                           `
`       po 10 wywołaniach CPIR procedurka poCPR robi tak:
`                        #FF-zastrzeżony
`                        #FE-nieznany /przeszuk cała ks.tel/
`                        #FD-nieznany /NIE przeszuk cała ks.tel/
`                        #FC-błędny /ustalany przed rozpoznawaniem CPIR/
`                         lub że rozpoznany (#00-#09) 
`                         umownie  #0A -jako numer konfigu (20znakowy...)
`------------------------------------------
`
`pom. sprawdza bufor, czy rozpoznany numer przepisuje nr i wyn rozpoznania
`do bufora SMSów, rezeruje bufor
`wyjście Z =ok, NZ =albo zajęty bufor albo nie cała ks.tel...
`trwa: +334tkt
LD A,(#85D8)           @SpBkD `bufor rozkodowanych SMSów tekstowych
AND A                         `czy wolny?
RET NZ                        `NZ -> zajęty bufor, więc do odczytania później
`LD A,(#802E)                  `DKrok
`CP #FF                        `czy =#FF ?
`RET NZ                        `NZ ret -> DKrok inny niż #FF, więc do odczytania później
`
`  dlaczego DKrok miałby blokować analizę SMSów? 
`  spróbujemy bez blokady, wszak do tych kroków wejście jest już chyba 
`  wcześniej blokowane przez Dkrok
`
LD HL,#809F                   `adres numeru nadawcy z CPIRu (oczyszczony)
LD DE,#85D9                   `miejsce docelowe numeru nadawcy
LD BC,#000C                   `&11 bajtów = 20& cyfr +bajt liczby cyfr
LDIR                          `przepisz 20 cyfr numeru nadawcy
LD A,#FF                      `rezerwacja bufora, wartość oznacza, że rozkodowujemy SMSa
LD (#85D8),A                  `bufor rozkodowanych SMSów tekstowych
SUB A                         `aby wskaźnik Z
RET                           `RET Z
`------------------------------------------
`
`sprawdzamy czy to SMS tekstowy czy bajtowy
`trwa +645tkt(dla bajtowego) i +549tkt(dla tekstowego)
CALL @poCPR            @SMtb? `+17+106tkt normalizuj wyniki działania CPIR
LD A,(#80CB)                  `typ SMSa
AND #07                       `nie sprawdzamy czy odebrany/odczytany, tylko czy tekstowy/bajtowy
CP #01                        `czy tekstowy?
JR NZ,@Stb?B                  `+12+490tkt hop -> nie tekstowy SMS...
CALL @SpBkD                   `+17+334tkt sprawdza czy wolny bufor rozkodowanych SMSów...
JP NZ,@OkZro                  `niepowodzenie (zajęty bufor lub DKrok<>#FF)
RET                           `następne przerwanie to dekodowanie tekstu
LD A,#02               @Stb?B `+483tkt podkod dla bajtowego
LD (#80C7),A                  `zapisz
SUB A                         `
LD (#80CF),A                  `inicjuj wartość początkową autosumy
LD A,(#80CB)                  `rozpoznanie wstępne tego bajtowego SMSa
CP #84                        `czy obszar?
JR Z,@SMobs                   `+12+414tkt hop -> obszar
CP #83                        `czy konfig?
JR Z,@SMkon                   `+12+69tkt hop -> konfig
LD HL,(#80D1)                 `przydasię
CP #85                        `czy majster?
JR Z,@SMajs                   `+12+156tkt hop -> majster
`   tu inny a więc bajtowy zwykły...
LD A,#82               @bajte `+51tkt kod bajtowego
LD (#80CB),A                  `zapisz (bo może być też #02)
LD A,#04               @apoza `+31tkt ile bajtów dla wyrównania LDIR
LD (#80D9),A                  `zapisz ile bajtów dla wyrównania LDIR
RET                           `
LD BC,#0082            @SMajs `+156tkt tu majster, delta w treści SMSa
ADD HL,BC                     `adres rozpoznawania majstra
LD A,(HL)                     `(1)
INC HL                        `
ADD A,(HL)                    `(2)
INC HL                        `
OR (HL)                       `(3)
INC HL                        `
SUB (HL)                      `(4)
INC HL                        `
XOR (HL)                      `(5)
LD (#8182),A                  `bajt wykorzystywany później
`                              w celu ustalenia /zdekodowania/ czy są do zapisania nr tel.
INC HL                        `
ADD A,(HL)                    `(6)
JR NZ,@bajte                  `+12+51tkt hop -> nie spełnia, traktuj jak bajtowy
RET                           `
LD HL,#8500            @SMkon `+69tkt tu konfig, adres dla zapisu konfigu
LD (#80D3),HL                 `zapisz adres tutaj
JR @apoza                     `+12+31tkt
LD A,(#809F)           @SMobs `+414tkt tu obszar                  
CP #02                        `czy rozpoznany jako poz. 0-2?
JP NC,@OkZro                  `hop -> nieuprawniony
LD A,#01                      `dodatkowo 1 bajt do LDIR
LD (#80D9),A                  `zapisz ile bajtów dla wyrówniania LDIR
INC HL                        `
INC HL                        `adr. trzeciego bajtu treści SMSa...
LD A,(HL)                     `versja i który obszar
LD D,A                        `zachowaj Acc
INC HL                        `
LD (#80D1),HL                 `zapisz adres stąd =4ty bajt treści SMSa
LD HL,#82CA                   `adr zerowego obszaru
LD BC,#0089                   `delta dla jednego obszaru
RLCA                          `starszy bit nru obszaru do CY
JR NC,@ASOIj                  `
ADD HL,BC                     `\dodaj za 2 /starszy bit w CY/
ADD HL,BC                     `/
RLCA                   @ASOIj `+266tkt młodszy bit nru obszaru do CY
JR NC,@ASOIJ                  `
ADD HL,BC                     `dodaj za 1
LD A,D                 @ASOIJ `+244tkt odtwórz Acc
AND #3F                       `zostaje tylko versja
CP (HL)                       `porównaj z istniejącą wersją
JR NC,@QHBSA                  `nie mamy nowszej`
`tutaj do skasowania bo mamy nowszą wersję
CALL @do_sk            @SMSd7 `+219tkt ...+17+161 zaznacz go do skasowania
JP @OkZro                     `+10+31 wyjdź
JR NZ,@lknba           @QHBSA `+103tkt hop-> realizuj ten obszar
`zaznacz do ignorowania przy cyklicznym czytaniu
LD C,#81                      `znacznik ignoruj_obszar
JP @_SMb8                     `+10+79tkt zaznacz tą pozycję do Crej o @OkZro
LD (#80CD),A           @lknba `+46tkt zachowaj wersję do późniejszego odblokowania obszaru
`dalej cyklicznie będzie sprawdzany (chyba że trzeba incknąć cykliczny numer?)
`obszaru jeszcze nie blokujemy bo będziemy dopiero sprawdzać autosumę...
INC HL                        `
LD (#80D3),HL                 `zapisz tutaj (tutaj przeładować LDIR)
RET                           `
`------------------------------------------
`
`obliczanie autosumy treści SMSa bajtowego
`trwa +591tkt (&140) #8C = (#14 * 7)
`   [76+(Brej*26)-5=591tkt]
LD HL,(#80D5)       @chAsB `dynamiczny adres sprawdzanej treści bajtowej SMSa bajtowego
LD A,(#80CF)               `wstępna wartość liczonej autosumy
LD B,#14                   `&20 bajtów za każdym razem
ADD A,(HL)          @_chAs `zsumuj wartość bajtu
INC HL                     `adres kolejnego bajtu /tu nie ma przełomu/
DJNZ @_chAs                `next
LD (#80CF),A               `zapamiętaj wartość autosumy
LD (#80D5),HL              `zapamiętaj dynamiczny adres
RET                        `
`--------------------------------------
`
`analiza SMSa bajtowego po sprawdzeniu autosumy i zdekodowaniu daty/czasu
`trwa +510tkt (dla konfigu) ++++++++++
`     ...mniej dla innych...     
LD A,(#80CF)            @SMb5_ `wynik autosumy
CP #27                         `czy właściwa?
JP NZ,@doEsk   `@LSAFK         `+10+180 hop -> różna od właściwej `chińskie`
LD A,(#80CB)                   `rozpoznanie wstępnie tego bajtowego SMSa
SUB #83                        `czy konfig?
JR Z,@SWkon                    `+12+448 hop -> konfig
DEC A    `CP #84               `czy obszar?
JR Z,@SWobs                    `+12+43 hop -> obszar więc zablokuj i prześlij
DEC A    `CP #85               `czy majster?
JR Z,@SWajs                    `+12+31 hop -> majster     
`   tu bajtowy                  
CALL @SpBkD                    `+17+334 spr czy wolny bufor i DKrok i ks tel, przepisuje 
`                               numer do bufora SMS rozkodowanych
JP NZ,@OkZro                   `+10+31tkt (DKrok zajęty lub zła pozycja tego SMSa)
RET                            `w next zaczynaj nierówne _LDIR a później równe
`   obszar                       
LD HL,(#80D3)           @SWobs `+43tkt adres 1szego bajtu danego obszaru
DEC HL                         `adres bajtu versji danego obszaru
LD (HL),#00                    `=#00 tzn. zablokuj obszar
`po przesłaniu trzeba odblokować...
RET                            `w next zaczynaj nierówne _LDIR a później równe
`   tu majster                  
LD A,#0F                @SWajs `+31tkt kroczek realizacji majstra /czyli następny to #10/
LD (#802A),A                   `
LD HL,(#8183)                  `adres treści SMSa bajtowego
LD DE,#0082                    `
ADD HL,DE                      `
EX DE,HL                       `
`tutaj musi być adres względny! 
`LD DE,#8176  `RD              `\  zdekoduj 5 bajtów
LD HL,@kode1                   ` | maskujących datę przydatności
LD B,#05                       `/
JP @dkdNX                      `czyli następny kroczek robi #10 ;o)
`   konfig                      
LD A,(#87F2)            @SWkon `+++++448 pozycja na SIM [#80CE: pozycja SMSa na SIM]
`#87F2 -1b licznik odczytanych konfigów, decyduje o odczycie książki telefonicznej
INC A                          `gdy jest tylko jeden konfig
LD (#87F2),A                   `
LD A,(#80CE)                   `+448 pozycja na SIM [#80CE: pozycja SMSa na SIM]
CP #09                         `czy #09 ?
LD BC,#802E                    `szybciej i taniej!
JR Z,@_p09_                    `+12+224 hop -> konfig pozycja #09
`        tutaj mamy konfig, z pozycji &0A
LD A,(BC)                      `czy DKrok =4
CP #04                         `
JP NZ,@OkZro                   `wyjście z InAnalizy
LD DE,#809D                    `adres roku pomocniczego SMSa z poz #09
LD HL,#8694                    `adres roku SMSa z poz #0A
PUSH BC                        `
CALL @CpTim                    `+17+277 porównaj czasy [(DE)-(HL)]
POP BC                         `
`wynik w rej. F: CY data/czas (&0A?) nowsza
`                NC data/czas (&0A?) starsza lub równe
JR C,@nowsa                    `+12+60 CY nowszy z HL, 
` NC takie same lub nowszy z DE 
` tu nie nowsza -> zmień DKrok na 5
LD A,#05                       `zwiększ DKrok na 5
LD (BC),A                      `zapamiętak DKrok
JP @OkSpd                      `+10+31 wyjście z InAnalizy bo nowsza jest #09, przyspiesz
LD DE,#809D             @nowsa `+60tkt adres roku pomocniczego SMSa z poz #09
LD A,(DE)                      `rok pomocniczego SMSa z poz #09
AND A                          `jeśli =#00 to nie było SMSa z poz #09
LD A,#0C                       `+31 jeśli nowsza to zmień DKrok na #0C =ustaw zegar i alarm
JR NZ,@byl09                   `
LD A,#09                       `jeśli nie było na poz#09 to zapisz SMSy
LD (BC),A               @byl09 `i użyj treści tego SMSa jako konfiguracji
RET                            `ret czyli następny kroczek robi przeładowanie
LD A,(BC)               @_p09_ `+224 czy DKrok =3
CP #03                         `
JR NZ,@if3DK                   `+12+48 hop, sprawdź czy to krok 5
INC A                          `+203 zwiększ DKrok na 4
LD (BC),A                      `zapamiętak DKrok
LD HL,#868F                    `DKrok=1, tu adres z którego wrzucamy przeliczoną datę z SMSa
LD DE,#8098                    `tu prześlij datę pomocniczą
LD BC,#0006                    `6 bajtów: rok,miesiąc,dzień,godz,min,sek
LDIR                           `prześlij datę 21*6-5=121
JP @OkSpd                      `+10+31+++ wyjście z InAnalizy i przyspieszenie odczytu po RESET
CP #05                  @if3DK `+48 mamy SMS konf z poz #09 i sprawdzamy DKrok
JP NZ,@OkZro                   `+10+31 hop -> wyjdź z InAnalizy
LD A,#0A                       `zwiększ DKrok na A (zapis konfiguracji do SMSa #0A)
LD (BC),A                      `zapamiętaj DKrok
RET                            `przeładowanie w kolejnym przerwaniu 
`--------------------------------------
`
`pomocnicza, zapoczątkowanie przeładowania 
LD A,(#80D9)            @_LDIR `\ dla A=4 trwa +198tkt, A=1 -> +135tkt
LD B,#00                       ` |tyle bajtów
LD C,A                         `/
JR @_LDI_                      `+12+162tkt [78+21*BC] przeładuj
`--------------------------------------
`
`przeładowuje fragm. treści SMSa konfigu/bajtowego/obszaru
`trwa  +655tkt 
LD BC,#001B             @LDIR_ `długość &27 bajtów
LD HL,(#80D1)           @_LDI_ `+78+21*BC tu pozostały adres źródła   
LD DE,(#80D3)                  `tu pozostały adres miejsca docelowego 
LDIR                           `przeładuj
LD (#80D1),HL                  `tu pozostały adres źródła             
LD (#80D3),DE                  `tu pozostały adres miejsca docelowego 
RET                            `
`--------------------------------------------------------------------
`
`dalsza analiza -już po LDIR
`trwa +368tkt                 
LD A,(#80CB)           @SMb6_ `rozpoznanie wstępne tego bajtowego SMSa
SUB #83                       `czy konfig?
JR Z,@prOkZ                   `hop -> konfig
DEC A                         `czy obszar?
JR Z,@willy                   `+12+98 hop -> obszar, odblokuj...
`  tutaj bajtowy, więc odblokuj bufor SMSów
LD A,#FE                      `tyle bajtów ma SMS bajtowy
`  wartość tego bajtu różna od #00 i od #FF oznacza
`  że to SMS bajtowy a ta właśnie wartość jest liczbą znaków ASCII rozkodowanego SMSa
`  #FE oznacza że to SMS bajtowy o stałej długości treści =#008A bajtów
JP @_SMpo                     `+10+307tkt
LD HL,(#80D3)          @willy `+68tkt adr bajtu za obszarem
LD BC,#FF77                   `= -#0089 co da po zsumowaniu adr bajtu versji
ADD HL,BC                     `teraz adres bajtu versji tego obszaru,
LD A,(#80CD)                  `przechowana versja obszaru z SMSa
LD (HL),A                     `zapisz czyli odblokuj obszar
RET                           `wyjdź bo jeszcze blokowanie i odblokowanie SMSów obszaru
LD HL,#80B3            @prOkZ `\jeśli =0 tzn że nie było jeszcze 
`#80B3 - 1b sekundy od pierwszego wczytania konfigu po RESET,
`        stoi gdy 7bit=1 lub gdy =#00, else idzie co sekundę do góry
LD A,(HL)                     ` |
AND A                         `/odczytanego konfigu
JR NZ,@prOKz                  `hop -> był już odczytany konfig
LD (HL),#01                   `startuj ten czas
LD HL,#80AD                   `\redLED ->mamy konfig
RES 3,(HL)                    `/
LD A,#12               @prOKz `\przejdź do kroku #13 czyli rozkodowanie konfigu
LD (#802A),A                  `/
RET                           `
`---------------------------------------
`
`przeszukuje wszystkie znaczniki SMSów, szuka znacznika obszar_ignoruj
`po znalezieni odznacza jako do analizy cyklicznej /czyli przy następnej
`cyklicznej analizie tego SMSa określi go je jako starsze i do skasowania/
`a tego obecnie załadowanego SMSa obszaru oznacza jako obszar_ignoruj 
`trwa: +632tkt 
CALL @obsz1            @SMb8_ `
LD C,#81                      `znacznik obszar_ignoruj
LD HL,#802F            @_SMb8 `+79tkt #8030 -1
LD A,(#80CE)                  `POZycja tego SMSa
ADD A,L                       `\
LD L,A                        `/bez przełomu!
LD (HL),C                     `czyli zaznacz tego SMSa jako znacznik Crej
JP @OkZro                     `+10+31tkt
`---------------------------------------
`
`realizacja majstra w 7 ramkach
`trwa: +729tkt ++++ -------           
LD HL,(#8183)          @SMm1_ `adres treści SMSa bajtowego
LD DE,#0020                   `
ADD HL,DE                     `
EX DE,HL                      `
LD HL,@kode3                  `
JP @dkdN_                     `
`---------------------------------
`
`realizacja majstra w 7 ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm2_ `adres treści SMSa bajtowego
LD DE,#0011                   `
ADD HL,DE                     `
EX DE,HL                      `
LD HL,@kode4                  `
JP @dkdN_                     `
`---------------------------------
`
`realizacja majstra w 7 ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm3_ `adres treści SMSa bajtowego
LD DE,#0040                   `
ADD HL,DE                     `
EX DE,HL                      `
LD HL,@kode5                  `
CALL @dkdN_                   `
LD A,#29                      `kroczek dalszej realizacji majstra 
LD (#802A),A                  `                  /czyli następny to #2A/
RET                           `
`---------------------------------
`
`realizacja majstra w kolejnych ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm4_ `adres treści SMSa bajtowego
LD DE,#0040                   `
ADD HL,DE                     `
LD A,(#8182)                  `
ADD A,(HL)                    `
RET NZ                        `ret -> brak treści ASCIIZ dla SMSa paynego
INC HL                        `
LD DE,#8549                   `
`!`#8549 -> &11b treść SMSa paynego /treść ASCIIZ lub ASCII gdy &11 znaków/
LD BC,#000B                   `
LDIR                          `
RET                           `
`---------------------------------
`
`pomocnicza dla sprawdzenia przed zapisaniem
` numerów tajnego i pajnego    
`trwa +tkt max                  
ADD HL,DE              @chbLD `
LD A,(HL)                     `
AND A                         `
SCF                           `
RET NZ                        `/C/
INC HL                        `
LD A,(#8182)                  `
ADD A,(HL)                    `
SCF                           `
RET NZ                        `/C/
INC HL                        `
LD A,(HL)                     `
CP #15                        `
CCF                           `
RET C                         `/C/ hop -> zbyt dużo cyfr
CP #04                        `
RET C                         `/C/ hop -> zbyt mało cyfr
LD BC,#000B                   `
RET                           `/NC/
`-------------------------------
`
`realizacja majstra w 7 ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm5_ `adres treści SMSa bajtowego
LD DE,#0021                   `
CALL @chbLD                   `
RET C                         `error
LD DE,#856A                   `
`!`#856A: 1b + #856B-#8574 &10b numer 0 ('0' poufnych)        |po &11 bajtów
LDIR                          `
RET
`---------------------------------
`
`realizacja majstra w kolejnych ramkach /to właśnie #2A/
`trwa: +tkt
LD HL,(#8183)          @SMm6_ `adres treści SMSa bajtowego
LD DE,#0012                   `
CALL @chbLD                   `
RET C                         `error
LD DE,#8575                   `
`!`#8575: 1b + #8576-#857F &10b numer 1 ('1' poufnych)        |skompresowanych cyfr 
LDIR                          `
RET                           `
`---------------------------------
`
`realizacja majstra w kolejnych ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm7_ `adres treści SMSa bajtowego
LD DE,#0082                   `
ADD HL,DE                     `
LD A,(HL)                     `
AND A                         `
RET NZ                        `ret -> nie zawiera ważnej daty
INC HL                        `
LD DE,#8554                   `
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7 -> ?
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
LD BC,#0003                   `
LDIR                          `
RET                           `
`---------------------------------
`
`realizacja majstra w kolejnych ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm8_ `adres treści SMSa bajtowego
LD DE,#0030                   `
ADD HL,DE                     `
EX DE,HL                      `
LD HL,@kode2                  `
JP @dkdN_                     `
`---------------------------------
`
`realizacja majstra w kolejnych ramkach
`trwa: +tkt
LD HL,(#8183)          @SMm9_ `adres treści SMSa bajtowego
LD DE,#0030                   `
ADD HL,DE                     `
LD A,(HL)                     `
AND A                         `
JR NZ,@sm_9f                  `hop -> nie zawiera ważnej danej
INC HL                        `
LD DE,#8530                   `
`!`#8530 -> &11 bajtów numeru własnego: 1b + &10b /normalnie jak standard/
`!`         l.znaków +&20 połówek bajtu=cyfr, uzup #F0 i reszta #00
`!`         jeśli l.cyfr=#00 to brak numeru
LD BC,#000B                   `
LDIR                          `
LD A,#01               @sm_9f `\konieczność zapisu konfigów do SIM
LD (#807D),A                  `/
LD C,#82                      `znacznik ignoruj_majster
JP @_SMb8                     `+12+79tkt zaznacz tego SMSa Crej i @OkZro
`---------------------------------
`
`dekodowanie odczytanego z SIM konfigu +326tkt minęło, mamy 674tkt
`trwa +491tkt                   
`obszar I    : #8530..#853A [#8226..#8230] &11 -> #0B
LD DE,#8530             @SMk1_ `
LD HL,@kode1                   `aby nie na przełomie!
LD B,#0B                       `
JR @dkdNX                      `
`obszar II   : #8549..#8556 [#823F..#824C] &15 -> #0F
`trwa +675tkt                   
LD DE,#8549             @SMk2_ `
LD HL,@kode2                   `aby nie na przełomie!
LD B,#0E                       `
JR @dkdNX                      `
`obszar IIIa : #855E..#856C [#8254..#8262] &15 -> #0F
`trwa +675tkt                   
LD DE,#855E             @SMk3_ `
LD HL,@kode3                   `aby nie na przełomie!
JR @dkdN_                      `
`obszar IIIb : #856D..#858B [#8263..#8271] &15 -> #0F
`trwa +675tkt                   -> +1001tkt !!!!!
LD DE,#856D             @SMk4_ `
LD HL,@kode4                   `aby nie na przełomie!
JR @dkdN_                      `
`obszar IIIc : #857C..#858A [#8272..#8280] &15 -> #0F
`trwa +663tkt                   
LD DE,#857C             @SMk5_ `
LD HL,@kode5                   `aby nie na przełomie!
LD B,#0F                @dkdN_ `
LD A,(DE)               @dkdNX `7
SUB (HL)                       `7
LD (DE),A                      `7
INC L                          `4
INC E                          `4
DJNZ @dkdNX                    `(13+29)*15-5 = 
RET                            `11
`---------------------------------
`
`kończy rozkodowanie konfigu    
LD A,(#87F2)            @OkZ__ `
`#87F2 -1b licznik odczytów konfigu z SIM, gdy jest jeden to zeruje książkę tel. w RAM
` sprawdź ile odczytano konfigów, jeśli mniej niż 2 to kasuj książkę telefoniczną
CP #02                         `
JR C,@zrKST
`!`#853C -> 2b ID konfigu służący do sprawdzenia, czy nie wymieniono kart SIM
`#8DF7 -> 2b ID konfigu służący do sprawdzenia, czy nie wymieniono kart SIM
LD HL,(#853C)                  `
LD DE,(#8DF7)                  `
AND A                          `
SBC HL,DE                      `porównaj IDy
JP Z,@OkSpd                    `hop -> identyczne, więc nie kasuj ks.telef
`
` tutaj można się zastanowić, czy utworzyć nowe ID, czy nie
` utworzenie to jakby przypisanie tej SIM do tej RAM i odwrotnie
` NIE utworzenie to zawsze będzie odczyt all książki telefonicznej
`
CALL @resKT             @zrKST `+17+341=358tkt--- zeruj książkę telefoniczną
JP @OkSpd                      `
`---------------------------------
`
`dwie procedury zamieniające znacznik ignoruj_obszar na nieznany
LD A,#81                @SMb7_ `+557tkt znacznik ignorowanych SMSów obszaru
LD C,#00                       `zamień do odczytania
JR @&13SM                      `+12+543
LD A,#81                @obsz1 `+529tkt znacznik ignorowanych SMSów obszaru
LD C,#00                       `zamień do odczytania
`...przejdzie... JR @&12SM     `
`---
`
`pomocnicze procedury przeszukujące w dwu ratach
`znaczniki SMSów i zamieniające znaczniki np. SMSy oznaczone ignoruj_bo_obszar na Crej
LD HL,#8030             @&12SM `+515tkt adres od 1-szego SMSa
LD B,#0C                       `&12 SMSów
JR @AWLSF                      `   
LD HL,#803C             @&13SM `+543tkt adres od 14&ego SMSa
LD B,#0D                       `&13 SMSów
CP (HL)                 @AWLSF `porównaj 
JR NZ,@_AWLS                   `hop -> to inny, nie zamieniaj
LD (HL),C                      `zamień na żądany znacznik
INC HL                  @_AWLS `
DJNZ @AWLSF                    `pętla
RET                            `
`-----------------------------------
`                                
`potwierdzenie wysłania SMSa i nadania mu numeru umownego...
`trwa: +238tkt max ++++38tkt +++++
`LD HL,#84EE    już jest      
LD A,(HL)             @_#20_ `odczytaj status wysłanego SMSa
AND #F0                      `tylko status, bez ustawień SMSa
CP #B0                       `czy wysłany SMS ma status jestUSER? 
`                    (czyli nadano USERa i czekamy na potwierdzenie wysłania)
RET NZ                       `ret -> nie oczekuje po nadaniu, jakiś nieznany error
SUB A                        `\zatrzymaj TimeGuarda wysyłania SMSa
LD (#84FF),A                 `/
LD A,(HL)                    `odczytaj status wysłanego SMSa
AND #0F                      `zostaw ustawienia SMSa
OR #40                       `zmień status na wysłany
LD (HL),A                    `zapisz
` sprawdzimy czy oczekuje potwierdzenia delivery
RRCA                         `CY=1 to bez delivery
JR C,@20__5                  `hop -> nie oczekuje delivery
` tak, więc trzeba zapisać do tablicy delivery
LD HL,(#84EF)                `tu już jest adres time'u delivery (dla znanych i nieznanych)
LD A,#01                     `startuj czas oczekiwania na delivery
LD (HL),A                    `startuj
DEC HL                       `teraz adres numeru umownego delivery
LD A,(#80CE)                 `w potwierdzeniu tu jest numer umowny
LD (HL),A                    `zapisz numer umowny
LD HL,(#8511)         @20__5 `+138tkt licznik wszystkich wysłanych SMSów
INC HL                       `wysłano kolejny
LD (#8511),HL                `zapisz
LD A,H                       `\
OR L                         ` |czy przeskok na zero?
JR NZ,@20__7                 `/hop -> jeszcze nie przeskoczył
LD HL,(#8513)                `
INC HL                       `
LD (#8513),HL                `
LD HL,(#8516)         @20__7 `+100tkt licznik 'mały-zerowalny' wysłanych SMSów
INC HL                       `wysłano kolejny
LD (#8516),HL                `zapisz
LD HL,#80AD                  `sygnalizacja LED StatusSystemu
RES 5,(HL)                   `zrób NIEaktywny(=0) 5bit braku możliwości wysyłania SMSów
`LD A,(HL)                    `
`AND #DF                      `zrób NIEaktywny(=0) 5bit braku możliwości wysyłania SMSów
`LD (HL),A                    `zapisz
LD A,#01                     `minutnik konieczności zapisu konfigów
LD (#807D),A                 `zmienił się konfig SMS i trza zapisać na SIM...
`LD A,(#84F3)                `pozycja numeru odbiorcy SMSa
`AND A                       `czy to poz #00 (tajna?)
`RET NZ                      `ret -> NIE, to inna pozycja niż tajny
`LD HL,#8EF9                 `\
`INC (HL)                    `/zwiększ liczbę skradzionych dziś SMSów
RET                          `
`-----------------------------
`                              
`nie wysłano SMSa             
`trwa: +113tkt     ++++++++++ 
`LD HL,#84EE    już jest      
LD A,(HL)             @_#21_ `status wytworzonego SMSa
AND #F0                      `tylko status, bez ustawień SMSa
CP #B0                       `czy wysłany SMS ma status jestUSER?
RET NZ                       `hop -> nie oczekuje, po nadaniu, jakiś nieznany error
SUB A `LD A,#00              `\zatrzymaj TimeGuarda wysyłania SMSa
LD (#84FF),A                 `/
LD A,(HL)                    `
AND #0F                      `zostaw ustawienia SMSa
OR #50                       `zaznacz że nie wysłano
LD (HL),A                    `zapisz
LD HL,#80AD                  `sygnalizacja LED StatusSystemu
SET 5,(HL)                   `zrób aktywny(=1) 5bit braku możliwości wysyłania SMSów
`LD A,(HL)                    `
`OR #20                       `
`LD (HL),A                    `zapisz
`LD A,(#84F3)                 `pozycja numeru odbiorcy SMSa
`CP #02                       `czy to poz #00 lub #01 (tajna lub pajna?)
`RET NC                       `ret -> NIE, to inna pozycja
`LD HL,#A8C0                  `=12godzin wyrażone w sekundach
`LD (#8ACC),HL                `stoper czasowej blokady wysyłania SMSów tajnych/pajnych
` czyli blokuj czasowo możliwość wysyłania SMSów na numer tajny lub opłat
`  -> przeniosełm to poza NMI, tam gdzie wysyła tajny lub pajny
RET                          `
`------------------------      
`                             
`pomocnicza do zapisano SMSa na SIM, sprawdza czy
`dotyczy to konfigu
`trwa: +72tkt                
`LD HL,#802E już jest
LD A,(HL)             @pom23 `odczytaj jaki DKrok      
LD DE,#80CE                  `adr. pozycji potwierdzonego zapisu SMSa
CP #09                       `
JR Z,@DKr09                  `+12+25tkt hop -> DKrok=#09
CP #0A                       `
RET NZ                       `ret -> DKrok inny niż #0A
`   tutaj DKrok=#0A, a więc przejdź do kroku #0C
LD A,(DE)                    `pozycja potwierdzonego zapisu SMSa
CP #0A                       `czy poz #0A ?
SCF                          `
RET                          `
`NZ=error                     
`Z=ok, C=poz #0A              
LD A,(DE)             @DKr09 `+25tkt tu krok #04, pozycja potwierdzonego zapisu SMSa
SUB #09                      `czy poz #09 ?
RET                          `
`NZ=error
`Z=ok, NC=poz #09
`---------------------------------
`
`zapisano SMSa do SIM (?na pozycji)
`trwa: +663tkt 
CALL @pom23             @_#23_ `+17+72tkt 
`   NZ=error /nie dotyczy konfigu/
RET NZ                         `wyjdź bo to nie konfig (pozycjaSIM, DKrok)
`   Z=ok, NC=poz #09              
`   Z=ok, C=poz #0A             
`                               
`  nie musi być, bo przeskoczy z #00 na #FF samoistnie w @time+ / @stp++
`                               
`dwie procedury zamieniające znacznik majstra na do skasowania
LD A,#82                `@2___3 `+tkt znacznik SMSa majstra
LD C,#01                       `zamień na do_skasowania
JP @&13SM                      `+12+543tkt
`---------------------------------
`
`zapisano SMSa do SIM (?na pozycji)
`trwa: +678tkt
CALL @pom23             @#23_5 `+17+72tkt 
`   NZ=error /nie dotyczy konfigu/
RET NZ                         `wyjdź bo to nie konfig (pozycjaSIM, DKrok)
`   Z=ok, NC=poz #09 po Dkroku #09
`   Z=ok, C=poz #0A po Dkroku #0A
LD A,#0C                     `DKrok= #0C /po #0A/
JR C,@23___                  `
LD A,#0A                     `DKrok= #0A /po #09/
LD (HL),A             @23___ `+461tkt zapisz DKrok
SUB A                        `
LD (#8081),A                 `licznik kolejnych prób odczytu SMSa konf. &09/0A
`procedura zamieniająca znacznik majstra na 'do_skasowania'
LD A,#82                     `+tkt znacznik SMSa majstra
LD C,#01                     `zamień na do_skasowania
JP @&12SM                    `+10+515tkt
`---------------------------------
`                              
`potwierdzenie skasowania SMSa  
`trwa: +82tkt                 
LD HL,#802F            @_#26_ `adr. SMSa cyklicznie przeglądanego/kasowanego
LD A,(HL)                     `numer kolejnego SMSa sprawdzanego cyklicznie
ADD A,L                       `\obl. adres znacznika SMSa z tej pozycji
LD L,A                        `/
LD A,(HL)                     `odczytaj jak był zaznaczony
DEC A                         `czy był =#01 (czyli zaznaczony do skasowania)?
JR NZ,@incSM                  `+12+32tkt nie był zazn do skasowania, więc nie zmieniaj znacznika
LD (HL),A                     `=#00 zapisz że już nie jest do skasowania
LD HL,#802F            @incSM `+32tkt
INC (HL)                      `zwiększ numer kolejnego SMSa do cyklicznego odczytu
RET                           `
`------------------------------
`                             
`trwa: +157tkt =+31tkt+[@_#28_]
`LD HL,#802E                 `adr. DKrok /już jest/
LD A,(HL)             @03030 `DKrok
CP #03                       `
RET C                        `wyjdź bo Dkrok <3
CP #05                       `
RET NC                       `wyjdź bo Dkrok >4
` ...przejdź do @_#28_...
`      Dkrok 3 lub 4 -przejdź profilaktycznie do @_#28_ czyli dla tych 
`      zwiększa ilość falstartów i ew. zmienia DKrok gdyby nie był to poprawny
`      konfig...
`------
`
`brak SMSa na tej pozycji na SIM
`trwa: +126tkt max  +++ 300         
`                             
`ta proc jest też wywoływana z analizy SMSów
`i nie można w niej korzystać z nru SMSa z ramy bo może tu być już coś innego zapisane
`                             
LD DE,#8081           @_#28_ `adr. licznika krotności żądania SMSa konf z poz #09
`LD HL,#802E                  `adr. DKrok /już jest/
LD A,(HL)                    `DKrok
SUB #03                      `czy = #03?
JR NZ,@WOPH1                 `+12+90tkt hop -> DKrok inny niż #03
`  tutaj żądano SMSa konfig z poz.#09 w DKroku #03 i go nie było...
LD A,(DE)                    `licznik krotności żądania SMSa konf z poz #09
INC A                        `zlicz kolejny falstart
LD (DE),A                    `
CP #06                       `do 5 razy sztuka
RET C                        `mniej niż 5 razy
INC (HL)              @NxDKr `+22tkt zwiększ DKrok
RET                          `hop -> OkZro
DEC A                 @WOPH1 `+90tkt czy to DKrok #04?
JR NZ,@WOPH2                 `+12+53 hop -> DKrok inny niż #04
`  tutaj żądano SMSa konfig z poz.#0A w DKroku #04 i oczywiścnie nie ma go...
LD A,(DE)                    `licznik krotności żądania SMSa konf z poz #09
INC A                        `zlicz kolejny falstart
LD (DE),A                    `
CP #09                       `do trzech razy sztuka (po 5 wcześniej)
RET C                        `mniej niż 4 razy
LD A,(#809D)                 `czy był SMS na poz. #09? (gdy rok <>#00 to był...)
AND A                        `
JR NZ,@NxDKr                 `+12+22 hop -> była konfiguracja na #09 ale nie na #0A
`   tutaj gdy nie było SMSa na poz. #09 -> czyli brak konfiguracji
LD A,#09                     `+25tkt DKrok =#09
LD (HL),A                    `zapisz DKrok =#09 czyli zapisanie konfiguracji na SIM
LD HL,#80AD                  `\zaznacz że mamy konfig
RES 3,(HL)                   `/
LD A,#01                     `\startuj stoper od momentu posiąścia
LD (#80B3),A                 `/SMSa konfigu (tutaj go brak, ale to właśnie ten moment!
` chyba tutaj trzeba skasować numery tel. w RAM
CALL @resKT                  `+268tkt max 
` utwórz ID konfigu /2bajty/ i zapisz go do konfigu i do RAM
LD HL,(#8002)                `czyli 2b licznik NMI i uł. sekund
LD (#853C),HL                `zapisz go do utworzonego już konfigu i
LD (#8DF7),HL                `zapisz go do RAM w miejsce niekasowalne
`!`#853C -> 2b ID konfigu służący do sprawdzenia, czy nie wymieniono kart SIM
`#8DF7 -> 2b ID konfigu służący do sprawdzenia, czy nie wymieniono kart SIM
RET                          `hop -> OkZro
DEC A                 @WOPH2 `+53tkt czy to DKrok #05?
RET Z                        `ret -> DKrok #05 i brak tam SMSa, mimo iż powinien być
`                             tak więc czekaj na niego do bólu
`  tutaj gdy komunikat o braku SMSa a nie chodzi o DKroki #03-#05 czyli o konfigi
JR @incSM                    `+12+32 hop -> inc nr cyklicznego SMSa...
`--------------------------------------
` TWORZENIE SMSa KONFIGU
DEFETYK @SsmsK   `#05 adres tablicy adresów kroków do tworzenia SMSa konfigu
DEFTABE TSmk1      `561 `prześlij pierwszą część stałą do bufora USERa
DEFTABE TSmk2      `659 `prześlij drugą część stałą do bufora USERa, ustal poz &09/0A,koduj rok
DEFTABE TSmk3      `477 `koduj miesiąc/dzień/godzinę
DEFTABE TSmk4      `613 `koduj minutę/sekundę, obl. autosumę treści i prześlij 2b treści
DEFTABE LDiIR           `  \
DEFTABE LDiIR           `   \
DEFTABE LDiIR           `    \
DEFTABE LDiIR           `     \
DEFTABE LDiIR           `      \
DEFTABE LDiIR           `       \prześlij &12 * &11 bajtów (wcześniej 2 bajty, później 5 bajtów)
DEFTABE LDiIR      `628 `       / razem = &139 = #8B
DEFTABE LDiIR           `      /
DEFTABE LDiIR           `     /
DEFTABE LDiIR           `    /
DEFTABE LDiIR           `   /
DEFTABE LDiIR           `  /
DEFTABE TSmk5           `prześlij 5 bajtów i obl. autosumę mbus`a, koryguj ją
DEFTABE TSmk6           `\
DEFTABE TSmk7           ` \  kodowanie tego co jest w buforze
DEFTABE TSmk8           `  | jako kodowanie konfigu
DEFTABE TSmk9           ` /  
DEFTABE TSmkA           `/
DEFTABE TSmkB           `odblokuj USER`a
`---
`
`trwa +561tkt
`nie sprawdza czy wolny bufor USERa bo DKrok =4 lub 5 więc w takim razie
`wszystko jest podporządkowane tworzeniu komunikatu USERa.
LD HL,@smsk1             @TSmk1 `tworzenie SMSa konfigu, stała 1 część 
LD DE,#81C8                     `miejsce docelowe
LD BC,#0019                     `
LDIR                            `
RET                             `
`--------------------------------
`
`trwa +659tkt
LD HL,@smsk2             @TSmk2 `tworzenie SMSa konfigu, stała 2 część 
LD DE,#81E1                     `miejsce docelowe
LD BC,#000E                     `next adres to #81EF
LDIR                            `
LD A,(#8009)                    `#8009 -> lata (#00 = 2000r) 
CP #64                          `
CALL C,@->BCD                   `+17+245 zamień na postać dla SMSa
LD (DE),A                       `rok
LD A,(#802E)                    `DKrok
CP #0A                          `czy DKrok =A?
RET NZ                          `ret -> krok inny niż #0A
LD A,#0A                        `#0A
LD (#81D1),A                    `zmień na pozycję SMSa &0A
RET                             `
`--------------------------------
`
`trwa: +477tkt
LD HL,#8008             @TSmk3 `#8008 -> miesiące [#00 - #0B] /#00 to styczeń/
LD DE,#81F0                    `
LD A,(HL)                      `miesiąc [#00 - #0B] /#00 to styczeń/
INC A                          `[#01 - #0C] /#01 to styczeń/
CP #0D                         `skróci maksymalny czas w procedurze
CALL C,@->BCD                  `+17+80 zamień na postać dla SMSa
LD (DE),A                      `#81F0 miesiąc
DEC HL                         `\
INC DE                         `/next -> dzień miesiąca
LD A,(HL)                      `#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
INC A                          `[#01 - #1F] /#01 to 1/
CP #20                         `skróci maksymalny czas w procedurze
CALL C,@->BCD                  `+17+120 zamień na postać dla SMSa
LD (DE),A                      `#81F1 dzień
DEC HL                         `\
INC DE                         `/next -> godzina
LD A,(HL)                      `#8006 -> godziny,        /czas rzeczywisty...
CP #18                         `skróci maksymalny czas w procedurze
CALL C,@->BCD                  `+17+100 zamień na postać dla SMSa
LD (DE),A                      `#81F2 godzina
RET
`----------------------------
`
`trwa +613tkt
LD A,(#8005)            @TSmk4 `#8005 -> minuty
CALL @->BCD                    `+17+160 zamień na postać dla SMSa /bo max wart to #3B/
LD (#81F3),A                   `#81F3 minuty
LD A,(#8004)                   `#8004 -> sekundy
CALL @->BCD                    `+17+160 zamień na postać dla SMSa /bo max wart to #3B/
LD (#81F4),A                   `#81F4 sekundy
LD A,#40                       `= #40 strefa czasowa?
LD (#81F5),A                   `1bajt za czasem
` teraz treść i liczenie autosumy a potem jej korekta
LD HL,#8500                    `#8500-... obszar konfigu #8B bajtów
LD DE,#81F6                    `miejsce docelowe
LD BC,#0200                    `B(dwa bajty), C(zeruj autosumę)
JR @_dhk2                      `licz autosumkę i prześlij
`-----------------------------
`
`trwa:+628tkt 
LD B,#0B                @LDiIR `liczy autosumę i przesyła &11bajtów
LD HL,(#80AE)           @dhaki `dynam. adres źródła bajtów
`                               trwa (Brej * 47) +100
`                                    dla B=#05 to 339tkt
LD DE,(#80B0)                  `dynam. adres w SMSie
LD A,(#8281)                   `#81F6 + #8B = #8281
LD C,A                  @_dhki `next bajt
LD A,(HL)               @_dhk2 `trwa (Brej * 47) +51
LD (DE),A                      `     dla B=#02 to +145tkt
ADD A,C                        `
INC HL                         `
INC DE                         `
DJNZ @_dhki                    `
LD (#8281),A                   `
LD (#80AE),HL                 `dynam. adres źródła bajtów
LD (#80B0),DE                  `dynam. adres w SMSie
RET                            `
`przesyłanie od #8500           na #81F6
`         #02 + (#0B * &12) +#05 = &139 = #8B
`             +0=#8B             +1bajt autosumy wewnętrznej =#8C (w #81F6 + #8B = #8281)
`next free:     #8282
`------------------------------
`
`trwa: +482tkt ---                  
LD B,#05                @TSmk5 `5 bajtów
CALL @dhaki                    `+17+335tkt oblicz jeszcze dla 5 bajtów
LD C,A                         `obliczona czysta autosuma
LD A,#83                       `autosuma ma wynosić #27, ale kodowana jest 
`                               więc tyle trzeba dodać
SUB C                          `a więc różnicę trzeba 
LD (#8281),A                   `zapisać w bajcie korygującym
RET                            `
`------------------------------
`
`kodowanie konfigu 326tkt minęło, mamy 674tkt
`trwa +491tkt                   
`obszar I    : #8530..#853A [#8226..#8230] &11 -> #0B
LD HL,#8226             @TSmk6 `
LD DE,@kode1                   `aby nie na przełomie!
LD B,#0B                       `
JR @kodNX                      `
`obszar II   : #8549..#8556 [#823F..#824C] &14 -> #0E
`trwa +629tkt                  `
LD HL,#823F             @TSmk7 `
LD DE,@kode2                   `aby nie na przełomie!
LD B,#0E                       `
JR @kodNX                      `
`obszar IIIa : #855E..#856C [#8254..#8262] &15 -> #0F
`trwa +675tkt                  `
LD HL,#8254             @TSmk8 `
LD DE,@kode3                   `aby nie na przełomie!
JR @kodN_                      `
`obszar IIIb : #856D..#858B [#8263..#8271] &15 -> #0F
`trwa +675tkt                   -> +1001tkt !!!!!
LD HL,#8263             @TSmk9 `
LD DE,@kode4                   `aby nie na przełomie!
JR @kodN_                      `
`obszar IIIc : #857C..#858A [#8272..#8280] &15 -> #0F
`trwa +663tkt                  `
LD HL,#8272             @TSmkA `
LD DE,@kode5                   `aby nie na przełomie!
LD B,#0F                @kodN_ `
LD A,(DE)               @kodNX `7
ADD A,(HL)                     `7
LD (HL),A                      `7
INC L                          `4
INC E                          `4
DJNZ @kodNX                    `(13+29)*15-5 = 
RET                            `11
`------------------------------
`
`trwa: +tkt                   
LD A,#00                @TSmkB `odblokuj robienie, zaznacz że gotowy
LD (#81C9),A                   `USER gotowy
JP @OkZrU                      `+10+61tkt
`--------------------------
`
`trwa: max. 240tkt (dla &99)
`     80tkt dla &12
`    100tkt dla &23
`    160tkt dla &59
LD BC,#FF0A               @->BCD `zamienia wartość z zakresu #00-#63 (0..99&)
`                  na dwie cyfry w dwóch połówkach Acc odwrotnie położone (jak w dacie SMSa)
INC B                     @_->BC `
SUB C                            `
JR NC,@_->BC                     `
ADD A,C                          `
RLCA                             `
RLCA                             `
RLCA                             `
RLCA                             `
OR B                             `
RET                              `
`--------------
`
DEFETYK @smsk1  `1 część stała komunikatu do zapisu SMSa konfigu
DEFBAJT1 #02 #01 #B7  `bajt #01 to blokowanie bufora ramki USERa
DEFBAJT1 #00 #01 #00 #04 #01 #02 #09 #00 `w #81D1 jest #09 to pozycja (dla #0A trza zmienić)
DEFBAJT1 #06 #91 #21 #43 #65 #87 #09 #00 #00 #00 #00 #00 `numer centrum SMS /dowolny?/
DEFBAJT1 #70 #00 
`
DEFETYK @smsk2  `2 część stała komunikatu do zapisu SMSa konfigu
DEFBAJT1 #F5 #8C #14 #91 
DEFBAJT1 #21 #43 #65 #87 #09 #21 #43 #65 #87 #09 `numer nadawcy
`
`===========================================
`wygląd ramki zapisu SMSa konfigu:
`#1F #.. #.. <-to tworzy łopata
`#02 #00 #B7 <-przesyłamy na adres #81C8 /bajt #00 ma pierw inną wartość =blokada USERA/
`#00 #01 #00 #04 #01 #02 #09 #00 <-bajt #01 to przeczytany a #09 to pozycja SMSa
`#06 #91 #21 #43 #65 #87 #09 #00 #00 #00 #00 #00 <-przesyłamy
`#70 #00 #F5 #8C <-przesyłamy
`#14 #91 #21 #43 #65 #87 #09 #21 #43 #65 #87 #09 <-przesyłamy
`#60 #21 #13 #32 #95 #95 #00 <- data i godzina i strefa czasowa /tworzymy z zegara/
`... treść #8C bajtów, czyli #8B przesłanych z konfigu i 1b autosumy do #27
`#ID #a$ <-to tworzy łopata
`===========================================
`
`---------------------------------------
`
DEFETYK @SsmsN   `#06 adres tablicy adresów kroków do tworzenia SMSa text/bajt
DEFTABE MkSm1                `372 `#05 dla bajtowego i tekstowego
DEFTABE MkSm2                `523 `#06 
DEFTABE MkSm3                `469 `#07 
DEFTABE IGIEN                `645 `#08 dla textowego 8
DEFTABE IGIEN                     `#09 dla textowego 16
DEFTABE IGIEN                     `#0A dla textowego 24
DEFTABE IGIEN                     `#0B dla textowego 32
DEFTABE IGIEN                     `#0C dla textowego 40
DEFTABE IGIEN                     `#0D dla textowego 48
DEFTABE IGIEN                     `#0E dla textowego 56
DEFTABE IGIEN                     `#0F dla textowego 64
DEFTABE IGIEN                     `#10 dla textowego 72
DEFTABE IGIEN                     `#11 dla textowego 80
DEFTABE IGIEN                     `#12 dla textowego 88
DEFTABE IGIEN                     `#13 dla textowego 96
DEFTABE IGIEN                     `#14 dla textowego 104
DEFTABE IGIEN                     `#15 dla textowego 112
DEFTABE IGIEN                     `#16 dla textowego 120
DEFTABE IGIEN                     `#17 dla textowego 128
DEFTABE IGIEN                     `#18 dla textowego 136
DEFTABE IGIEN                     `#19 dla textowego 144
DEFTABE IGIEN                     `#1A dla textowego 152
DEFTABE IGIEN                     `#1B dla textowego 160
DEFTABE MkSm4                `223 `#1C dla textowego odblokuj USERa i finisz
DEFTABE LDiIR                `628 `#1D \
DEFTABE LDiIR                     `#1E  \
DEFTABE LDiIR                     `#1F   \
DEFTABE LDiIR                     `#20    \
DEFTABE LDiIR                     `#21     \
DEFTABE LDiIR                     `#22      \ prześlij &12 * &11 bajtów 
DEFTABE LDiIR                     `#23      / (wcześniej 2 bajty, później 5 bajtów)
DEFTABE LDiIR                     `#24     /  razem = &139 = #8B
DEFTABE LDiIR                     `#25    /
DEFTABE LDiIR                     `#26   /
DEFTABE LDiIR                     `#27  /
DEFTABE LDiIR                     `#28 /
DEFTABE MkSm5                `604 `#29  dla bajtowego 130+ 9=139bajtów, odblokuj USERa i finisz
`----------------------------------------------------------------------
`       #1F #00 #1D 
`komunikat tworzony do USERA w celu wysłania SMSa text/bajt
`------
`#81C8: #02 #00 #x1 
`#81CB: #00 #01 #00 #01 #02 #01 
`#81D1: #07 #91 #84 #06 #92 #15 #11 #F1 #00 #00 #00 #00 
`#81DD: #x2 #00 #00 #x3 #x4 
`#81E2: #0B #91 #84 #06 #32 #37 #70 #F2 #00 #00 #00 #00 
`#81EE: #AD #00 #00 #00 #00 #00 #00 
`#81F5: #F7 #FB #DD #F5 #86 #B7 #5B #32 #D7 #F8 #DD #D6 #81 #82 #CC #A0 
`       #B4 #19 #0A #85 #00 #00 #00 #01 #42 
`------
`       #05 #70 
` gdzie: #x1 -długość treści komunikatu mbusa (USERa)
`        #x2 - = #35 gdy z potwierdzeniem delivery
`              = #11 gdy bez potwierdzenia
` dla tekstowego:
`        #x3 - = #00 normalny SMS 
`              = #10 flash SMS 
`        #x4 - =liczba liter
` dla bajtowego:
`        #x3 - = #F5
`        #x4 - = #8C
`----------------------------------------------------------------------
`
`sprawdzimy czy na tym numerze nie oczekujemy na delivery
`można by tu spekulować, jeśli nie chcemy TERAZ potwierdzenia to po co sprawdzać,
`ale skoro delivery nie dotarło tzn. że ten tel poza zasięgiem więc i tak nie ma 
`sensu wysyłać nań SMSów
`trwa: +372tkt                     
LD A,(#84F3)            @MkSm1 `numer odbiorcy #00-#09 to znany, większa wartość =inny
CP #0A                         `
LD BC,#84EE                    `adr. status i parametry SMSa do utworzenia
JR NC,@_MS11                   `hop -> to numer inny, nie da się sprawdzić...
LD HL,#8083                    `adr tabeli znanych oczekując. na delivery +1 /tylko dla zn./
ADD A,A                        `*2 do obl. delty adresu 
ADD A,L                        `obl. adres dla tego SMSa
LD L,A                         `
LD A,(HL)                      `czas oczekiwania gdy #01-#FE, #00-nie czeka a #FF >254 sekundy
INC A                          `
CP #02                         `
JR C,@_MS1_                    `+12+258tkt hop -> nie czeka lub czeka powyżej 254 sekund
` tutaj gdy dla tego numeru czekamy na delivery
`LD BC,#84EE                   `
LD A,(BC)                      `
BIT 3,A                        `bit=1 to wysyłaj niezależnie od poprzedniego delivery
JR NZ,@_MS1_                   `hop -> wyślij, mimo iż nie otrzymał poprzedniego delivery
OR #10                         `status ='poprzedni oczekuje na delivery'
LD (BC),A                      `
JP @OkZro               @_MS33 `+10+31tkt ukończ SecondInAnalizę
LD HL,#8097             @_MS11 `+268tkt adr. czasu oczek. na delivery dla nieznanego
LD (#84EF),HL           @_MS1_ `+258tkt zapamiętaj adres czasu dla nieznanego
LD HL,#84F3                    `nr odbiorcy
LD A,(HL)                      `odczytaj
INC HL                         `nie zmienia Frej!
CP #0A                         `czy zakres znanych numerów?
JR NC,@_SKJ1                   `hop -> podany numer
` tu numer znany                
LD E,A                         `obl. deltę adresu
ADD A,A                        `*2
ADD A,A                        `*4
ADD A,E                        `*5
ADD A,A                        `*10&
ADD A,E                        `*11& bajtów bo tyle jeden rekord tabeli znanych numerów
LD HL,#856A                    `tabela znanych numerów
LD D,#00                       `\
LD E,A                         `/delta
ADD HL,DE                      `obl. adres źródła numeru
LD A,(HL)               @_SKJ1 `+159tkt bajt liczby cyfr numeru 
AND A                          `
JR NZ,@_MS44                   `hop -> l.cyfr>0 ->analizuj dalej
`  wyjdź bo nie znasz tego numeru!
`LD BC,#84EE                    `adr. statusu wysyłania SMS
LD A,(BC)                      `
AND #0F                        `zostaw ustawienia SMSa
OR #50                         `zaznacz że nie wysłano /brak numeru odbiorcy 0cyfr!/
LD (BC),A                      `zapisz
JR @_MS33                      `
LD (#81E2),A            @_MS44 `+136tkt zapisz liczbę cyfr w USERze
CP #08                         `
LD A,#91                       `dla numeru normalnego międzynarodowego
JR NC,@nrnum                   `
LD A,#BD  `#B0 `#81            `dla numeru płatnego (mniejsza liczba cyfr)
LD (#81E3),A            @nrnum `typ numeru nadawcy =międzynarod. cyfrowy...
INC HL                         `1szy bajt samych cyfr
LD (#81E4),HL                  `zapisz adres źródła dla numeru nadawcy
`LD BC,#84EE                    `już jest
LD A,(BC)                      `odczytaj status i parametry SMSa do utworzenia
AND #0F                        `parametry SMSa zachowaj
OR #A0                         `status ='robimy SMSa'
LD (BC),A                      `zapamiętaj
LD HL,#0102                    `
LD (#81C8),HL                  `
LD (#81CF),HL                  `
RET                            `
`-------------------------------
`                               
`trwa: +523tkt                  
LD HL,(#81E4)           @MkSm2 `prześlij numer nadawcy
LD DE,#81E4                    `miejsce docelowe w ramie USERa
LD BC,#000A                    `10& bajtów samych cyfr
LDIR                           `przeładuj numer odbiorcy
LD HL,#855E                    `adres centrum SMS z configu
LD DE,#81D1                    `miejsce docelowe w ramie USERa
LD BC,#000C                    `l.bajtów
LDIR                           `przeładuj numer centrumSMS
RET                            `
`-------------------------------
`                               
`trwa:+469tkt                   
LD HL,#0100             @MkSm3 `
LD (#81CB),HL                  `
LD (#81CD),HL                  `
LD H,L                         `
LD (#81DE),HL                  `
LD (#81EF),HL                  `
LD (#81F1),HL                  `
LD (#81F3),HL                  `
LD A,(#84EE)                   `odczytaj rodzaj SMSa i ułóż do USERa
RRCA                           `CY=bit potw.
LD C,A                         `
`
`można się pobawić w wymuszanie żądania delivery gdy nie mamy ustawionego zegara
`
LD A,#11                       `
JR C,@_skj3                    `hop -> =1 bez potwierdzenia
LD A,#35                       `
LD (#81DD),A            @_skj3 `+317tkt
LD A,C                         `
RRCA                           `CY=bit flash
LD C,A                         `
LD A,#10                       `kod flash SMSa
JR C,@_skj4                    `hop -> =1 flash
SUB A `LD A,#00                `kod normalnego SMSa (nie flash)
LD (#81E0),A            @_skj4 `+273tkt
LD A,C                         `
RRCA                           `CY=bit bajtowego
LD HL,#81F5                    `dynam. adres w USERze skompresowanego tekstu
LD (#80B0),HL                  `inicjuj dynam. adres skompr tekstu
EX DE,HL                       `
`         po EX miejsce docelowe jest już w DE
LD HL,(#84F1)                  `adres tekstu/bajtów
LD (#80AE),HL                  `dynam. adres źródła bajtów/tekstu
RET NC                         `ret bo tekstowy SMS
LD A,#1C                       `następny będzie więc #1D /już minęło +520tkt/
LD (#802A),A                   `hop kroczek
` teraz treść i liczenie autosumy a potem jej korekta
`LD DE,#81F5        /już jest/ `dynam. adres w USERze dla bajtów
LD BC,#0200                    `B(dwa bajty), C(zeruj autosumę)
JP @_dhk2                      `+10+145tkt licz autosumkę i prześlij
`-------------------------------
`                               
`tylko dla tekstowego           
`trwa:+223tkt                      
LD A,(#81E1)            @MkSm4 `oblicza z liczby liter /8 * 7
` w (#81E1) jest wartość równa liczbe liter określona przez @IGIEN 
LD E,A                         `zachowaj l.liter w E
RRCA                           `
RRCA                           `
RRCA                           `
AND #1F                        `=l.liter/8
LD C,A                         `zachowaj w C
LD A,E                         `=odtwórz l.liter z E
SUB C                          `=7/8 * l/liter
ADD A,#2A                      `dodaj początkową liczbę bajtów przed textem
LD L,#00                       `bajt odblokowania USERa
LD H,A                         `długość komunikatu mbusa
LD A,#AD                @_MS31 `+165tkt \okres ważności SMSa
LD (#81EE),A                   `        /
LD (#81C9),HL                  `finisz tworzenia USERa SMSa
LD DE,#84EE                    `odczytaj status i parametry SMSa do utworzenia
LD A,(DE)                      `
AND #0F                        `parametry SMSa zachowaj
OR #B0                         `status ='gotowy USER SMSa, czekamy na reakcję NOKIA'
LD (DE),A                      `zapamiętaj
LD A,#01                       `\startuj TimeGuarda wysyłania SMSa
LD (#84FF),A                   `/
JP @OkZrU                      `+10+61tkt czyli @OkZro i przyspiesz wysłanie ramki
`------------------------------
`                              
`trwa: +604tkt                 
LD HL,#8CF5             @MkSm5 `bajtowy SMS /już minęło +520tkt/
LD (#81E0),HL                  `twórz specyfikę bajtowego
LD B,#05                       `4 bajty bo o 1 krótszy od konfiga?
CALL @dhaki                    `+17+339tkt oblicz jeszcze dla 5 bajtów
LD C,A                         `obliczona czysta autosuma
LD A,#27                       `tyle ma wynosić autosuma wewnętrzna
SUB C                          `a więc różnicę trzeba 
LD (#8280),A                   `zapisać w bajcie korygującym
LD HL,#B600                    `długość i odblokuj USERa do wysłania
JR @_MS31                      `+12+165tkt
`------------------------------
`                              
`kodowanie 8 znaków tekstu do 7 bajtów dla tworzenia SMSa tekstowego
`trwa: 645tkt                  
LD DE,(#80AE)           @IGIEN `dynam. adres textu
LD HL,(#80B0)                  `dynam. adres skompr tekstu
`---
LD A,(DE)                      `odczytaj 1szy znak
AND #7F                        `7 bitów
LD B,A                         `zapamiętaj w Brej
JR Z,@_igi2                    `czy znak końca textu?
INC DE                         `adres 2-giego znaku
LD A,(DE)                      `odczytaj 2-gi znak
AND A                          `czy to znak końca textu?
JR Z,@_igi2                    `czy znak końca textu?
RRCA                           `o 1 bit w prawo
LD C,A                         `2gi znak przesunięty o 1 bit w prawo
AND #80                        `bit0 2giego znaku na pozycji 7bitu
OR B                           `połącz z 1szym znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 2giego bajtu wyniku
`---
LD A,C                         `2gi znak przesunięty o 1 bit w prawo
AND #3F                        `6 bitów tylko (1bit już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 3-ciego znaku
LD A,(DE)                      `odczytaj 3-ci znak
AND A                          `czy to znak końca textu?
JR Z,@_igi2                    `czy znak końca textu?
RRCA                           `\o 2 bity w prawo
RRCA                           `/
LD C,A                         `3ci znak przesunięty o 2 bity w prawo
AND #C0                        `bity0i1 3giego znaku na pozycji 7i6bitu
OR B                           `połącz z 2gim znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 3ciego bajtu wyniku
`---
LD A,C                         `3gi znak przesunięty o 2 bity w prawo
AND #1F                        `5 bitów tylko (2bity już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 4-ciego znaku
LD A,(DE)                      `odczytaj 4-ci znak
AND A                          `czy to znak końca textu?
JR Z,@_igi1             @_igi2 `czy znak końca textu?
RRCA                           `\
RRCA                           `|o 3 bity w prawo
RRCA                           `/
LD C,A                         `4ty znak przesunięty o 3 bity w prawo
AND #E0                        `bity0-2 4ego znaku na pozycji 5-7bitu
OR B                           `połącz z 3cim znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 4ciego bajtu wyniku
`---
LD A,C                         `4gi znak przesunięty o 3 bity w prawo
AND #0F                        `4 bity tylko (3bity już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 5ego znaku
LD A,(DE)                      `odczytaj 5ty znak
AND A                          `czy to znak końca textu?
JR Z,@_igi1                    `czy znak końca textu?
RRCA                           `\
RRCA                           `|o 4 bity w prawo
RRCA                           `|
RRCA                           `/
LD C,A                         `5ty znak przesunięty o 4 bity w prawo
AND #F0                        `bity0-3 5ego znaku na pozycji 4-7bitu
OR B                           `połącz z 4-tym znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 5ciego bajtu wyniku
`---
LD A,C                         `5-ty znak przesunięty o 4 bity w prawo
AND #07                        `3 bity tylko (4bity już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 6ego znaku
LD A,(DE)                      `odczytaj 6ty znak
AND A                          `czy to znak końca textu?
JR Z,@_igi1                    `czy znak końca textu?
RLCA                           `\
RLCA                           `|o 5 bitów w prawo
RLCA                           `/
LD C,A                         `6ty znak przesunięty o 5 bitów w prawo
AND #F8                        `bity0-4 6ego znaku na pozycji 3-7bitu
OR B                           `połącz z 5-tym znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 6ego bajtu wyniku
`---
LD A,C                         `6-ty znak przesunięty o 5 bitów w prawo
AND #03                        `2 bity tylko (5bitów już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 7ego znaku
LD A,(DE)                      `odczytaj 7ty znak
AND A                          `czy to znak końca textu?
JR Z,@_igi1                    `czy znak końca textu?
RLCA                           `\o 6 bitów w prawo
RLCA                           `/
LD C,A                         `7my znak przesunięty o 6 bitów w prawo
AND #FC                        `bity0-5 7ego znaku na pozycji 2-7bitu
OR B                           `połącz z 6-tym znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 7mego bajtu wyniku
`---
LD A,C                         `7-ty znak przesunięty o 6 bitów w prawo
AND #01                        `1 bit tylko (6bitów już wcześniej)
LD B,A                         `zapamiętaj w Brej
INC DE                         `adres 8ego znaku
LD A,(DE)                      `odczytaj 8my znak
AND A                          `czy to znak końca textu?
JR Z,@_igi1                    `czy znak końca textu?
RLCA                           `o 7 bitów w prawo
LD C,A                         `8my znak przesunięty o 7 bitów w prawo
AND #FE                        `bit0-6 8ego znaku na pozycji 1-7bitu
OR B                           `połącz z 7-mym znakiem
LD (HL),A                      `zapisz
INC HL                         `adr. 8mego bajtu wyniku
`---
INC DE                         `adres 9-ego znaku /odtąd trwa: 71tkt/
LD (#80AE),DE                  `dynam. adres textu
LD (#80B0),HL                  `dynam. adres skompr. tekstu
LD A,#A0                       `=160 znaków
LD (#81E1),A                   `zapisz liczbę znaków /ostatni istotny/
RET
`---
OR B                    @_igi1 `+76tkt połącz z poprzednim znakiem
LD (HL),A                      `zapisz
LD HL,#84F1                    `adr. młodszego b.adresu początku textu 
LD A,E                         `E to młodszy bajt delty adresu od wartości (#84F1)
SUB (HL)                       `różnica to liczba znaków tekstu niezakodowanego
LD (#81E1),A                   `zapisz liczbę znaków
LD A,#1B                       `następny krok -#1C to po kodowaniu textu
LD (#802A),A                   `przeskocz kroczkiem
RET
`---------------------------------------------------------
`
`dla zewnętrznej procedury, aby określić czy otrzymano delivery
`na wysłanego SMSa do którego był żądany
`wynik: Z, NC =był deliver, niewiadomo po jakim czasie
`       Z, CY =upłynęło ponad 253 sekundy oczekiwania, 
`              nie było delivera i nie mierzymy już czasu
`       NZ    =oczekujemy na deliver czas w Acc +1 w sekundach
`trwa: +60tkt                   
`LD HL,(#83EF)           @SMSdl `
`LD A,(HL)                      `
`AND A                          `
`RET Z                          `
`INC A                          `
`SCF                            `
`RET Z                          `
`DEC A                          `
`RET                            `
`----------------------------------------------------------
`
`dla zewnętrznej procedury, aby zdecydować co dalej z tym SMSem zrobić w Crej:
` #00 -pozostawić do dalszego cyklicznego czytania,
` #01 -skasować z SIM,
` #80 -pozostawić na SIM, ale ignorować -nie czytać cyklicznie,
`wynik: CY -oki, NC -zła wartość pozycji SMSa w bajcie #868D
`trwa: +69tkt
LD A,(#868D)            @SMSpo `
`#868D -1b -pozycja SMSa na SIM /do zaznaczania do usunięcia albo ignorowania/text/bajt/
LD HL,#8030                    `
DEC A                          `
CP #19                         `
RET NC                         `
ADD A,L                        `
LD L,A                         `
LD (HL),C                      `
SCF                            `
RET                            `
`---------------------- poniżej procedury do wysyłania SMSów spoza NMI ----------------------
`
`wysyła SMSa na znaną pozycję Acc, /jeśli otrzymano wcześniejszy delivery/
`jeśli nie było delivery to nie nadaje na mBusa, a rezultat taki jakby NIEnadano
`w innym wypadku oczywiście czeka na odpowiedź NOKIA czy wysłano, czy nie
`wynik: CY= wysłano, NC=nie wysłano
`trwa /poza NMI/                  
LD (#84F3),A              @SMdAc `numer odbiorcy SMSa z kolejnych
LD HL,#8744                      `tekst dla SMSa
LD (#84F1),HL                    `adres tekstu do SMSkompresowania
CP #02                           `czy numer tajny czy jawny?
LD A,#80                         `normalny tekstowy z potwierdzeniem, 
`                                 nie wysyłaj gdy nie dostarczono wcześniejszej
CALL @blSMS                      `ew. blokadę wywołuje tylko dla jawnych numerów
`zmienia: L,AF                   `
CALL @bijTI               @_xS__ `
`nic nie zmienia                 `
LD A,(#84EE)                     `
AND #F0                          `
CP #50                           `czyli NIE wysłano
RET Z                            `(NC) nie wysłano SMSa z przyczyn sieci
CP #40                           `czyli wysłano
JR Z,@sndSM                      `wysłano SMSa
CP #90                           `czyli nie dotarł poprzedni delivery
JR NZ,@_xS__                     `hop -> SMS jeszcze w trakcie wysyłania
` tutaj NIE wysłano SMSa          
AND A                            `(NC) NIEwyslano bo poprzedni deliver nie dotarł
RET                              `
`---------------------------------
`
`wyślij SMSa niezależnie czy poprzedni dostarczył delivery
`wynik: CY= wysłano, NC=nie wysłano
`trwa /poza NMI/
LD (#84F3),A              @SMbAc `numer odbiorcy SMSa z kolejnych
LD HL,#8744                      `tekst dla SMSa
LD (#84F1),HL                    `adres tekstu do SMSkompresowania
CP #02                           `czy numer tajny czy jawny?
LD A,#88                         `normalny tekstowy z potwierdzeniem, 
`                                 wysyłaj, nawet jeśli nie dostarczono wcześniejszej
CALL @blSMS                      `ew. blokadę wywołuje tylko dla jawnych numerów (NC)
CALL @bijTI               @_xS_2 `
LD A,(#84EE)                     `
AND #F0                          `
CP #50                           `
RET Z                            `(NC) nie wysłano SMSa z przyczyn sieci
CP #40                           `
JR NZ,@_xS_2                     `hop -> SMS jeszcze w trakcie wysyłania
` tutaj wysłano SMSa, zaznacz w matrycy odpowiedzi
LD A,(#84F3)              @sndSM `
SUB #02                          `
CP #08                           `czy zakres #00..#07 ? /tylko jawne/
CCF                              `
RET C                            `(C) wysłano /jakiś dziwny numer odbiorcy/
`#8DF1..#8DF8 -8b liczniki wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów o zdarzeniach i specjalnych
`              do celu wysyłania reklam na te numery
LD HL,#8DF1                      `
ADD A,L                          `
LD L,A                           `
LD A,(HL)                        `
CP #FF                           `
JR Z,@fnAdS                      `hop -> dograniczyło się!
INC (HL)                         `cyknij licznik wysłanych na dany numer SMSów
LD HL,#8DF8               @fnAdS `
LD B,#07                         `
LD A,(HL)                        `startuj autosumę
DEC HL                    @nxLSr `kolejny adres
ADD A,(HL)                       `dodaj wartość
DJNZ @nxLSr                      `pętla
DEC HL                           `adres bajtu autosumy
LD (HL),A                        `zapisz wynik -> suma wszystkich SMS do #8DF0 ->autosuma RAM ;o)
SCF                              `(C) wysłano
RET                              `
`---------------------------------
`
`procedura wysyła SMSy tekstowe normalne z potwierdzeniem 
` o ułożonej treści w #8744 na numery jawne, które są zaznaczone w Acc
` bit0 to poz. jawna nr 0(2), bit7 -jawna nr 7(9)
` wysyła SMSy tylko w przypadku gdy numer nie oczekuje na delivera
` po poprzednim SMSie, gdy oczekuje to NIE wysyła na mBusa, a odpowiedź
` (bit wynikowy) jest taka, jakby NIE wysłał
`wejście: Acc bitowo bit=1 to wysłanie, bit=0 nie wysyła
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
`trwa poza NMI                    
LD B,#08                  @SMd8N `sprawdzamy dla 8 numerów
LD D,#FF                         `tutaj będzie wynik procedury wysyłania SMS
RRC D                     @_xSMZ `wynik wysłania SMSów
RRCA                             `na które numery wysłać SMSy ->CY wysłać, NC-> nie wysłać
JR NC,@_oWyS                     `hop -> nie wysyłaj SMSa bo nie ma go w matrycy
PUSH BC                          `
PUSH AF                          `
LD A,#0A                         `
SUB B                            `zakres #02-#09
CALL @SMdAc                      `wyślij SMSa na poz Acc znanych /jeśli poprzedni delivery/
`     wynik: CY= wysłano, NC=nie wysłano
JR NC,@_OWys                     `hop -> nie wysłano
RES 7,D                          `zaznacz że wysłano
POP AF                    @_OWys `nie wysłano SMSa
POP BC                           `
DJNZ @_xSMZ               @_oWyS `pętla ->następna pozycja z matrycy
LD B,A                           `
` w Brej i Acc mamy bity =1 tam, gdzie powinniśmy wysłać SMSa
` w Drej       mamy bity =0 tam, gdzie wysłaliśmy SMSa
AND D                            `
LD E,A                           `
` w Brej mamy bity =1 tam, gdzie powinniśmy wysłać SMSa
` w Erej mamy bity =1 tam, gdzie powinniśmy wysłać SMSa, ale nie wysłaliśmy
` w Drej mamy bity =0 tam, gdzie wysłaliśmy SMSa
LD A,D                           `\sprawdzamy czy Crej =#FF /nie wysłano na żaden/
INC A                            `/
` teraz jeśli Z to znaczy że NIE wysłaliśmy na żaden!
RET Z                            `ret -> Acc=#00 =nie wysłano na żaden
LD A,#40                         `co oznacza wysłano na jakieś lub na wszystkie
RET                              `
`---------------------------------
`
`procedura wysyła SMSy tekstowe normalne z potwierdzeniem 
` o ułożonej treści w #8744 na numery jawne, które są zaznaczone w Acc
` bit0 to poz. jawna nr 0(2), bit7 -jawna nr 7(9)
` wysyła SMSy nie bacząc na fakt, czy poprzedni deliver dotarł
`wejście: Acc bitowo bit=1 to wysłanie, bit=0 nie wysyła
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
`trwa poza NMI                    
LD B,#08                  @SMb8N `sprawdzamy dla 8 numerów
LD D,#FF                         `tutaj będzie wynik procedury wysyłania SMS
RRC D                     @2xSMZ `wynik wysłania SMSów
RRCA                             `na które numery wysłać SMSy ->CY wysłać, NC-> nie wysłać
JR NC,@2oWyS                     `hop -> nie wysyłaj SMSa bo nie ma go w matrycy
PUSH BC                          `
PUSH AF                          `
LD A,#0A                         `
SUB B                            `zakres #02-#09
CALL @SMbAc                      `wyślij SMSa na poz Acc znanych /bez poprzedniego delivery/
`      wynik: CY= wysłano, NC=nie wysłano
JR NC,@2OWys                     `hop -> nie wysłano
RES 7,D                          `zaznacz że wysłano
POP AF                    @2OWys `nie wysłano SMSa
POP BC                           `
DJNZ @2xSMZ               @2oWyS `pętla ->następna pozycja z matrycy
LD B,A                           `
` w Brej i Acc mamy bity =1 tam, gdzie powinniśmy wysłać SMSa
` w Drej       mamy bity =0 tam, gdzie wysłaliśmy SMSa
AND D                            `
LD E,A                           `
` w Brej mamy bity =1 tam, gdzie powinniśmy wysłać SMSa
` w Erej mamy bity =1 tam, gdzie powinniśmy wysłać SMSa, ale nie wysłaliśmy
` w Drej mamy bity =0 tam, gdzie wysłaliśmy SMSa
LD A,D                           `\sprawdzamy czy Crej =#FF /nie wysłano na żaden/
INC A                            `/
` teraz jeśli Z to znaczy że NIE wysłaliśmy na żaden!
RET Z                            `ret -> Acc=#00 =nie wysłano na żaden
LD A,#40                         `co oznacza wysłano na jakieś lub na wszystkie
RET                              `
`-----------------------------------
`
`procedura zapisuje Acc jako polecenie wysłania SMSa
` chyba że jest blokada wysyłania SMSów, to wtedy zapisuje
`wartość którą można zrozumieć jako 'NIE WYSŁANO SMSa'
`zmienia: L,AF
`trwa /poza NMI/
`
`właściwie dla CY należało by sprawdzić czy nie wysłano już zbyt wiele...
`
JR C,@_xSG_               @blSMS `hop bo CY oznacza numer tajny
LD L,A                           `
LD A,(#80AD)                     `
AND #50                          `bit6 i bit4 blokują możliwość wysyłania SMSów użytkownika
LD A,L                           `odtwórz
JR Z,@_xSG_                      `hop -> wyślij SMSa
LD A,#50                         `(czyli nie można wysłać SMSa)
LD (#84EE),A              @_xSG_ `wyślij SMSa
RET                              `
`---------------------- poniżej -poza NMI, analiza SMSów tekstowych przychodzących ----------
`
`prodedurka sprawdzająca przybycie nowych SMSów 
`i interpretująca PROFIL          
`  też dołóż zmianę numerów telefonów z pozycji: 2-8
`trwa /poza NMI/                  
LD A,(#85D8)              @InSMS `
AND A                            `czy =0? (gdy =0 to wolny bufor SMS odczytanych)
RET Z                            `wyjdź, bo brak SMSa
CP #FE                           ` 
RET NC                           `wyjdź, bo w trakcie przetwarzania (#FF) lub bajtowy (#FE)
LD B,A                           `liczba znaków
`#85D8 -> rozkodowany odebrany/odczytany SMS tekstowy/bajtowy:
`   #85D8 -> 1b =#00 to pusty bufor, =#FF to w trakcie rozkodowywania,
`               wartość tego bajtu różna od #00 i od #FF i od #FE oznacza, że to SMS tekstowy 
`               a ta właśnie wartość jest liczbą znaków ASCII rozkodowanego SMSa,
`               #FE oznacza że to SMS bajtowy o stałej długości treści =#008A bajtów
`   #85D9 -> 1b nr rozpoznany:
`                       #00-#09 pozycja w znanych numerach
`                       #FC-błędny
`                       #FD-nieznany (ale nie cała ks.tel jeszcze przeszukana)
`                       #FE-nieznany
`                       #FF-zastrzeżony
`   #85DA -> &11b numeru: /gdy rozpoznany to też tu jest numer/
`        #85DA -> 1b liczba cyfr numeru skompresowanego
`        #85DB -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0
`   #85E5 -> 7b sek/min/godz/dnmca/mce/rok/dz_tyg- czas z SMSa (otrzymano)
`                                      [gdy rok =#00 to błąd w dacie/czasie]
`   #85EC -> (do#868C)&161b /=#A1/ kodów ASCIIZ rozkodowanej treści SMSa/ 
`                                         /lub #89 bajtów z bajtowego
`#868D -1b -pozycja SMSa na SIM /do zaznaczania do usunięcia albo ignorowania/text/bajt/
LD HL,#85EC                      `adr. 1szego znaku
LD A,(#85D9)                     `nadawca SMSa
SUB #02                          `
JR C,@TajPa                      `hop -> tajny lub pajny
CP #08                           `
JR NC,@___BU                     `hop -> nieznany nadawca SMSa
` poniżej interpretuj SMSa i reaguj na niego
PUSH HL                   @reSZS `
CALL @rdROZ                      `rozpoznaj słowo rozkazu
` wynik w Acc i #8AD9, (Z) =nierozpoznane, (NZ) =rozpoznane
JR Z,@ROZer                      `hop -> error
CALL @rozKA                      `wykonaj rozkaz po doczytaniu danych
JR C,@ROZer                      `hop -> error
POP DE                           `
CALL @minSP                      `omiń spacje
LD A,(HL)                        `
AND A                            `czy to koniec SMSa?
` sprawdź czy każdego (też 160znakowego) SMSa kończy #00 -> TAK!
JR NZ,@reSZS                     `reszta tego SMSa do interpretacji
JR @clrBU                        `skasuj SMSa i czyść bufor SMSów
`tutaj niezrozumiały ten SMS:       
LD DE,#8744               @ROZer `
LD HL,@_???_                     `
CALL @PexA_                      `prześlij treść SMSa
POP HL                           `
LD B,#9A                         `=&160 - 5 -1 =154&
LD A,(HL)                 @nxASD `
AND A                            `
JR Z,@fnASD                      `hop ->znak końca
LD (DE),A                        `
INC HL                           `
INC DE                           `
DJNZ @nxASD                      `
SUB A                     @fnASD `\zapisz znak końca SMSa wychodzącego
LD (DE),A                        `/

`nadaj zwrotny SMS o nierozpoznanym rozkazie
LD A,(#85D9)                     `numer odbiorcy SMSa
` tekst od #8744                  
` numer Acc z kolejnych           
CALL @SMbAc          `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
` NC= nie wysłano SMSa, CY= wysłano SMSa
JR @clrBU                        `skasuj SMSa
`---                              
LD A,(#8558)              @___BU `tutaj nierozpoznany SMS
`!`#8558 -1b &8 kluczy zdarzeń specjalnych nie zapisywanych do LOGu na które wysyła SMS
`!`       bit 5 - 0=nic, 1=redirect nierozpoznane SMSy
BIT 5,A                          `
JR Z,@clrBU                      `skasuj SMSa i czyść bufor SMSów
`   #85DA -> &11b numeru: /gdy rozpoznany to też tu jest numer/
`        #85DA -> 1b liczba cyfr numeru skompresowanego
`        #85DB -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0

LD HL,#85DA                      `
LD DE,#8744                      `
`#8744 -&161 (#A1) bajtów ASCII z których można zakodować treść SMSa wychodzącego
CALL @NrTDe                      `zamień nr tel (HL..) na ASCII do (DE..)
`wyjście Crej= liczba znaków ASCII cyfr (lub 1 gdy wydrukował '?')
`(((((((((((((((((((((((((((((((((( to można zastąpić chyba LD HL,@': '_ i CALL PexA_ i DEFBAJT1...
LD A,#3A                  `@poZNR `dwukropek
LD (DE),A                        `
INC DE                           `i
LD A,#20                         `spacja
LD (DE),A                        `
INC DE                           `
`((((((((((((((((((((((((((((((((((
LD A,#9E                         `\ wynik to &160 -2znaki (dwukr i spacja) i
`                                                    minus już zajętych znaków 
SUB C                            `/
LD C,A                           `
LD B,#00                         `
` treść do &160 znaków dopisz     
LD HL,#85EC                      `
`   #85EC -> (do#868C)&161b /=#A1/ kodów ASCIIZ rozkodowanej treści SMSa/ 
LDIR                             `
SUB A                            `\
LD (DE),A                        `/znak końca tekstu
`wyślij na specjalne numery       
LD A,(#855B)                     `
`!`#855B -1b numery na które wysyłamy SMSspecjalny 
`wejście: Acc bitowo bit=1 to wysłanie, bit=0 nie wysyła
CALL @SMd8N                      `
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
JR Z,@skaSU                      `hop -> nie wysłano na żaden
`                                    |->skasuj SMSa ale zostaw go w buforze
SUB A                     @clrBU `\czyść bufor SMSów odebranych
LD (#85D8),A                     `/
`   #85EC -> (do#868C)&161b /=#A1/ kodów ASCIIZ rozkodowanej treści SMSa/ 
`                                         /lub #89 bajtów z bajtowego
LD C,#01                  @skaSU `skasuj tego SMSa   
`dla zewnętrznej procedury, aby zdecydować co dalej z tym SMSem zrobić w Crej:
` #00 -pozostawić do dalszego cyklicznego czytania,
` #01 -skasować z SIM,             
` #80 -pozostawić na SIM, ale ignorować -nie czytać cyklicznie,
`wynik: CY -oki, NC -zła wartość pozycji SMSa w bajcie #868D
CALL @SMSpo                      `kasuj SMSa
RET                              `
`---------------------------------
`
`analizuj SMSa odebranego z tajnego lub pajnego numeru
`trwa /poza NMI/
ADD A,#02                  @TajPa `
JR Z,@tajNy                       `hop -> SMS tekstowy z tajnego
DEC A
JR NZ,@clrBU                      `hop -> SMS do skasowania
` nadawcą jest numer payny, jest to SMS tekstowy
`
`
` tutaj w treści SMSa trzeba odnaleźć tekst 'Kod abonamentowy:' i dalszą część
`  sprawdzić i zinterpretować         
`
`
JR @clrBU                         `hop -> SMS do skasowania
` nadawcą jest numer tajny, jest to SMS tekstowy
CALL @rdROZ                @tajNy `rozpoznaj słowo
`porównaj tekst z SMSa (HL) ze znanymi wzorami rozkazów
` wynik w Acc i #8AD9, (Z) =nierozpoznane, (NZ) =rozpoznane
` HL=adr.za tekstem
JR Z,@clrBU                       `hop -> SMS do skasowania
CP #09                            `czyli 'REKLAMA'
JR NZ,@clrBU                      `hop -> SMS do skasowania
` 
` 
` tutaj należy przesłać SMSa ze statystyką poprzedniej raklamy...
` 
` 
PUSH HL                           `
LD DE,#0098                       `\
ADD HL,DE                         ` |profilaktycznie postaw znak końca w SMSie
LD (HL),#00                       `/
POP HL                            `
LD DE,#8E08                       `spr. autosumę reklamy w RAM
PUSH DE                           `
CALL @PexAS                       `przesyła text z (HL) do (DE) włącznie z #00
SUB A                             `\
LD (#8EA7),A                      `/na wszelki wypadek postaw zero za ASCII'Z' reklamy w RAM
DEC A                             `\stoper reklamy na maxa
LD (#87F6),A                      `/
POP HL                            `
LD B,#9F                          `max tyle znaków sprawdza
CALL @nxASZ                       `
`sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak lub niepoprawne)
JR C,@clrBU                       `hop -> SMS do skasowania
DEC HL                            `
XOR (HL)                          `
LD (HL),A                         `zapisz autosumę, bo była zła
JR @clrBU                         `hop -> SMS do skasowania
`---------------------------------
`
`wykonuje szczegółowo dalszą część rozkazu /doczytuje i wykonuje/
` wyjście C=error, NC=ok
`trwa poza NMI
DEC A                     @rozKA `wykonaj rozkaz po doczytaniu danych
CP #08                           `bezpiecznik zakresu
CCF                              `
RET C                            `CY =rozkaz niezrozumiały
PUSH HL                          `
ADD A,A                          `delta razy 2 bo 1 adres to dwa bajty
LD B,#00                         `\
LD C,A                           `/delta do adresu
LD HL,@tbROZ                     `adres tabeli zawierającej adresy procedur do wykonania
ADD HL,BC                        `dodaj do adresu
LD A,(HL)                        `\
INC HL                           ` \odczytaj adres z tabeli
LD H,(HL)                        ` /do doczytania i wykonania
LD L,A                           `/
POP DE                           `adr. w tekście analizowanego SMSa
EX DE,HL                         `adres do HL, w DE adres na który ma skoczyć
PUSH DE                          `wyślij na stos, aby po RET zrobić skok
RET                              `
` z procedury powraca RET i wchodzi za miejsce z którego wywołano @rozKA
`---------------------------------
`
DEFETYK @tbROZ                    
DEFTABE FAN__ `#01 doczytaj i wykonaj FONICZNY_ALARM_NA 
DEFTABE FAN__ `#02 doczytaj i wykonaj SMS_SPECJALNY_NA 
DEFTABE FAN__ `#03 doczytaj i wykonaj SMS_ALARM_NA 
DEFTABE FAN__ `#04 doczytaj i wykonaj SMS_INFORMACJA_NA 
DEFTABE TEL__ `#05 doczytaj i wykonaj TELEFON
DEFTABE PRO__ `#06 doczytaj i wykonaj PROFIL
DEFTABE TES__ `#07 wykonaj TEST
DEFTABE ALA__ `#08 wykonaj ALARM
`DEFTABE SAT__ `#09 doczytaj i wykonaj SMS_SPECJALNY_TO 
`---------------------------------------
`
`realizuje rozkaz z SMSa typo numery na alarm itd...
`trwa /poza NMI/
LD A,(HL)                  @FAN__ `doczytaj i wykonaj FONICZNY_ALARM_NA
PUSH AF                           `zachowaj czy jest pytajnik
PUSH HL                           `
LD A,(#8AD9)                      `
`#8AD9 -1b kod rozkazu zinterpretowanego z SMSa przychodzącego
LD HL,@sms_1                      `
DEC A                             `
JR Z,@juSMS                       `
LD HL,@sms_2                      `
DEC A                             `
JR Z,@juSMS                       `
LD HL,@sms_3                      `
DEC A                             `
JR Z,@juSMS                       `
LD HL,@sms_4                      `
LD (#8ACF),HL              @juSMS `#8ACF 2b pomocnicze do przechowania adresu
POP HL                            `
POP AF                            `odtwórz czy jest pytajnik
CP #3F                            `
JR NZ,@FAN_-                      `hop -> ustalanie numerów a nie pytanie o nie
INC HL                            `
PUSH HL                           `
CALL @BiqSi                       `
LD HL,(#8ACF)                     `#8ACF 2b pomocnicze do przechowania adresu
CALL @PexA_                       `
LD A,(#8AD9)                      `
LD HL,#855A                       `
DEC L                             `
ADD A,L                           `
LD L,A                            `
`#01 doczytaj i wykonaj FONICZNY_ALARM_NA 
`#02 doczytaj i wykonaj SMS_SPECJALNY_NA 
`#03 doczytaj i wykonaj SMS_ALARM_NA 
`#04 doczytaj i wykonaj SMS_INFORMACJA_NA 
`!`#855A -1b numery na które dzwonimy TPSA gdy ALARM i bez SMSa (jak w niżej)
`!`#855B -1b numery na które wysyłamy SMSspecjalny (jak w niżej)
`!`#855C -1b numery na które wysyłamy ALARM SMSem bit0 to 0 użytkownika, =1 to wysyłamy
`!`#855D -1b numery na które wysyłamy INFORMACJĘ SMSem j.w.    
LD A,(HL)                         `
CALL @BneTE                       `
JP @MkFtx                         `
`#8ADA -1b bity zamienione z 8 liczba z SMSa przychodzącego
CALL @rd8CY                @FAN_- `
` wynik w Acc i #8ADA              
AND A                             `
SCF                               `
RET Z                             `(C)=NIEpoprawnie
LD E,A                            `to co ma być teraz -po zmianie
LD A,(#85D9)                      `nadawca 0..9 rozkazu
SUB #02                           `\
CP #04                            `/spr. uprawnień nadawcy uprawnieni 02..05
CCF                               `
RET C                             `(C)=NIEpoprawnie /nieuprawniony/
PUSH HL                           `adr. w treści analizowanego SMSa za odczytanym
LD A,(#8AD9)                      `kod rozkazu
`#8AD9 -1b kod rozkazu zinterpretowanego z SMSa przychodzącego
LD HL,#855A                       `
DEC L                             `
ADD A,L                           `
LD L,A                            `
`#01 doczytaj i wykonaj FONICZNY_ALARM_NA 
`#02 doczytaj i wykonaj SMS_SPECJALNY_NA 
`#03 doczytaj i wykonaj SMS_ALARM_NA 
`#04 doczytaj i wykonaj SMS_INFORMACJA_NA 
`!`#855A -1b numery na które dzwonimy TPSA gdy ALARM i bez SMSa (jak w niżej)
`!`#855B -1b numery na które wysyłamy SMSspecjalny (jak w niżej)
`!`#855C -1b numery na które wysyłamy ALARM SMSem bit0 to 0 użytkownika, =1 to wysyłamy
`!`#855D -1b numery na które wysyłamy INFORMACJĘ SMSem j.w.    
LD A,(HL)                         `\to co było wcześniej
LD C,A                            `/
LD (HL),E                         `Erej= to co ma być teraz
XOR E                             `\
LD D,A                            `/Drej= zmiany względem tego co było wcześniej
` bit w Drej =1 to zmiana, bit w Erej =1 to teraz włączone
`1. wysłanie SMSa potwierdzającego do nadawcy
PUSH DE                           `Drej= zmiany, Erej= to co ma być teraz
PUSH DE                           `Drej= zmiany, Erej= to co ma być teraz
PUSH BC                           `Crej= to co było wcześniej
CALL @BiqSi                       `
LD HL,(#8ACF)                     `#8ACF 2b pomocnicze do przechowania adresu
CALL @PexA_                       `
LD HL,@zmian                      `
CALL @PexA_                       `
POP BC                            `\Crej= to co było wcześniej
LD A,C                            `/Acc
CALL @BneTE                       `rozpisuje Acc jako kolejne telefony 1..8
LD HL,@na___                      `
CALL @PexA_                       `
POP BC                            `Crej= to co ma być teraz
LD A,C                            `Acc
CALL @BneTE                       `rozpisuje Acc jako kolejne telefony 1..8
LD A,(#85D9)                      `nadawca 0..9 rozkazu
` tekst od #8744                   
` numer Acc z kolejnych            
CALL @SMbAc          `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
` NC= nie wysłano SMSa, CY= wysłano SMSa
POP DE                            `Drej= zmiany, Erej= to co ma być teraz
`2. wysłanie SMSów na poszczególne numery dla których nastąpiła zmiana
` 'BiqSH SMS-ALARM-NA zmiana nr TELEFON8 wyl.'
LD A,(#8AD9)                      `kod rozkazu
`#8AD9 -1b kod rozkazu zinterpretowanego z SMSa przychodzącego
`#01 doczytaj i wykonaj FONICZNY_ALARM_NA 
CP #01                            `
JR Z,@finFA                       `hop -> to foniczny, na foniczne nie wysyłamy SMSów
LD B,#08                          `
RRC E                      @petlZ `
RRC D                             `
JR NC,@tuBzZ                      `hop -> ten numer bez zmian
PUSH BC                           `pętla w Brej
PUSH DE                           `bity co gdzie wysłać
PUSH BC                           `pętla w Brej
PUSH DE                           `bity co gdzie wysłać
PUSH BC                           `pętla w Brej
CALL @BiqSi                       `
LD HL,(#8ACF)                     `#8ACF 2b pomocnicze do przechowania adresu
CALL @PexA_                       `
LD HL,@zmian                      `
CALL @PexA_                       `
LD HL,@TELEF                      `
CALL @PexA_                       `
POP BC                            `pętla w Brej
LD A,#39                          `
SUB B                             `
LD (DE),A                         `
INC DE                            ` 
LD A,#20                          ` 
LD (DE),A                         `
INC DE                            ` 
POP BC                            `bit 7 Crej =1 to zal
SUB A                             `
RLC C                             `
JR C,@QWOJN                       `hop -> =1 więc załączony więc Acc=0
INC A                             `
CALL @oNoFo                @QWOJN `
`pomocnicza, drukuje dla Acc=0 (ON)
`                        Acc=1 (OFF)
`                        Acc>=2 (OK)
SUB A                             `
LD (DE),A                         `
POP BC                            `pętla w Brej
LD A,#0A                          `
SUB B                             `
` tekst od #8744                   
` numer Acc z kolejnych            
CALL @SMbAc          `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
` NC= nie wysłano SMSa, CY= wysłano SMSa
POP DE                            `bity co gdzie wysłać
POP BC                            `pętla w Brej
DJNZ @petlZ                @tuBzZ `
POP HL                     @finFA `
AND A                             `(NC)=poprawnie
RET                               `
`---------------------------------------
`
`doczytuje i wykonuje rozkaz TELEFON1 ? lub TELEFON1 +48123456789987654321
`trwa /poza NMI/                   
LD A,(HL)                  @TEL__ `doczytaj i wykonaj TELEFON
` odczytaj cyfrę za słowem 'TELEFON' 
CP #3F                            ` '?'
JR NZ,@TELgi                      `
LD A,(#85D9)                      `nadawca 0..9 rozkazu
SUB #02                           `
RET C                             `error
CALL @l;pkf                       `oblicza adres telefonu Acc
JP @?telX                         `
SUB #31                    @TELgi `
CP #08                            `
CCF                               `ret -> cyfra z poza zakresu 1-8 /tu wartość inna niż #00-#07/
RET C                             `(C)=error/rozkaz niezrozumiały
CALL @l;pkf                       `oblicza adres telefonu Acc
INC HL                            `adr. w SMSie
LD B,A                            `
LD A,(#85D9)                      `nadawca 0..9 rozkazu
SUB #02                           ` 0..7 jawne i #FE i #FF tajny i pajny
` nadawca rozkazu ma uprawnienia do pytania/zmiany tylko większych od swojej wartości
SUB B                             `
RET NC                            `(NC) =wykonano ->wyjdź bo brak uprawnień
CALL @minSP                       `miń spacje
LD A,(HL)                         `
CP #3F                            `czy to pytajnik?
JP Z,@?telX                       `hop ->to pytanie
CALL @rdTEL                       `to numer do zapisania
PUSH HL                           `adr. w treści analizowanego SMSa za odczytanym numerem
LD HL,(#87F3)                     `obliczony wcześniej adres rzeczonego SMSa
`#87F3 -2b pomocnicza zapamiętuje adres numeru tel dla interpretacji SMSa przychodzącego
LD DE,#8ACE                       `
LD B,#0B                          `
LD C,(HL)                  @nxBaJ `\
LD A,(DE)                         ` \
LD (HL),A                         `  \
LD A,C                            `   \zamień numery
LD (DE),A                         `   /
INC DE                            `  /
INC HL                            ` /
DJNZ @nxBaJ                       `/
LD HL,#8502                       `
`!`#8502 -> 8b oznaczających numer pozycji w książce na SIM z której 
`!`                               odczytano numer tel. do znanych (#00...#FF)
`!`       spróbujmy wprowadzić taką zasadę, przeszukując SIM szuka tylko pozycji 0 do &99
`!`       jeśli =#00 to brak nru z SIM, gdy #01-#64 jest poz z SIM
`!`       tak więc jeśli 7bit jest zapalony, czyli #81-#E4 to na numer z tej pozycji SIM
`!`       nadpisano numer z komputera -> trzeba nadpisać na SIM
`!`       jeśli zaś jest #80 to trzeba zapisać w jakiejkolwiek innej pozycji niż
`!`       znajdujące się pozycje SIM w tej tabeli
LD A,(#8ADC)                      `#8ADC -1b wartość 0..7 określająca TELEFONx
ADD A,L                           `\
LD L,A                            `/tutaj nie ma przełomu
SET 7,(HL)                        `zaznacz że nadpisany z komputera
LD A,#02                          `
LD (#807D),A                      `
`#807D -> 1b czas (minuty) do zapisu konfigów -biegnie sobie w dół popychany w time+
`            przejście z #01 na #00 powoduje (jeśli DKrok=#FF) wpisanie DKrok =#08, jeśli
`            niemożliwe to pozostaje przez kolejną minutę #01,
`            po potwierdzeniu zapisu SMSa w Dkroku =#09 wpisujemy tu czas w minutach do 
`            następnego zapisu konfigów
` tworzymy SMSa dla nowego numeru telefonu:
` 1. na nowy numer telefonu o treści 'BiqSH TELEFON8'
CALL @BiqSi                       `
LD HL,@TELEF                      `
CALL @PexAS                       `
```````                             
` poniższy fragment występuje 3 razy, możliwa oszczędność to 8bajtów
LD A,(#8ADC)                      `\numer, którego to dotyczy
ADD A,#31                         `/
LD (DE),A                         `
INC DE                            `
SUB A                             `
LD (DE),A                         `
```````                             
LD A,(#8ADC)                      `numer, którego to dotyczy
ADD A,#02                         `
` tekst od #8744                   
` numer Acc z kolejnych            
CALL @SMbAc          `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
` NC= nie wysłano SMSa, CY= wysłano SMSa
JR NC,@goSEn                      `hop -> nie wysłano
` gdzie i jak sprawdzić czy dostarczono?
LD A,#3C                          `\wartość TimeGuarda sekundowego =&60[sek]
LD (#88E2),A                      `/oczekiwania na dostarczenie dla ALARMu
CALL @bijTI                @spDeL `
LD A,(#8ADC)                      `numer, którego to dotyczy
ADD A,#02                         `
ADD A,A                          `*2
LD D,#00                         `\16 bitów
LD E,A                           `/ delty adresu
LD HL,#8083                      `
`#8082 -> #16 bajtów tabela &11 sztuk po 2 bajty w kolejności 0 do 9 odpowiadającej znanym numerom
`   i po nich A -dla numeru innego niż znane,
`   odliczanie rozpoczynamy z chwilą potwierdzenia wysłania SMSa!
`         zawiera informację o postępie wysyłania SMSa w dwóch bajtach:
`         bajt +#00 to numer umowny nadany przez NOKIA w momencie wysłania potwierdzenia
`                                              wysłania SMSa (ważna gdy drugi bajt <>#00!)
`         bajt +#01 to czas w sekundach od momentu tego: #00-nic STOP
`                                                        #01-#FE /odliczanie zaczynamy od #01/
`                                                         po #FE przeskakuje na #FF i robi STOP
ADD HL,DE                        `
LD A,(HL)                        `czas lub #00 gdy dostarczony
AND A                            `czy =0?
SCF                              `
JR Z,@goSEn                      `hop C -> dostarczony 
LD A,(#88E2)                     `\czy upłynął już TimeGuard?
AND A                            `/
JR NZ,@spDeL                     `nie minął czas, sprawdzaj dalej
PUSH AF                   @goSEn `NC= niedostarczony
CALL @BiqSi                       `
LD HL,@zmian                      `zmiana nr 
CALL @PexA_                       `
LD HL,@TELEF                      `
CALL @PexAS                       `
LD A,(#8ADC)                      `\numer, którego to dotyczy
ADD A,#31                         `/
LD (DE),A                         `
INC DE                            `
LD HL,@_z___                      `
CALL @PexA_                       `
LD HL,#8ACE                       `tutaj jest stary numer
CALL @NrTDe                       `dekompresuje numer tel (HL..) jako ASCII na (DE..)
LD HL,@na___                      `
CALL @PexA_                       `
LD HL,(#87F3)                     `
`#87F3 -2b pomocnicza zapamiętuje adres numeru tel dla interpretacji SMSa przychodzącego
CALL @NrTDe                       `dekompresuje numer tel (HL..) jako ASCII na (DE..)
LD HL,@s_num                      `
CALL @PexA_                       `
POP AF                            `NC= niedostarczony
LD HL,@nie__                      `
JR NC,@MkFtX                      `
LD HL,@doste                      `
` potwierdzenie to SMS:                
` 2. 'BiqSH zmiana nr TELEFON8 z +48123456789 na +48123456789, numer dostępny/niedostępny '
CALL @PexAS                @MkFtX `
LD A,(#85D9)               @MkFtx `nadawca 0..9 rozkazu
` tekst od #8744                   
` numer Acc z kolejnych            
CALL @SMbAc          `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
` NC= nie wysłano SMSa, CY= wysłano SMSa
POP HL                            `
AND A                             `(NC)=poprawnie
RET                               `
INC HL                     @?telX `
PUSH HL                           `
` BiqSH TELEFONx +48123456789      
CALL @BiqSi                       `
LD HL,@TELEF                      `
CALL @PexAS                       `
LD A,(#8ADC)                      `\numer, którego to dotyczy
ADD A,#31                         `/
LD (DE),A                         `
INC DE                            `
LD A,#20                          `
LD (DE),A                         `
INC DE                            `
LD HL,(#87F3)                     `
`#87F3 -2b pomocnicza zapamiętuje adres numeru tel dla interpretacji SMSa przychodzącego
CALL @NrTDe                       `dekompresuje numer tel (HL..) jako ASCII na (DE..)
JR @MkFtx                         `
`---------------------------------------
`
`doczytuje dane do rozkazu PROFIL i wykonuje go
`trwa /poza NMI/
LD A,(HL)                  @PRO__ `doczytaj i wykonaj PROFIL
CP #3F                            `
JR Z,@PRO_?                       `hop -> pytanie o profil
AND #DF                           `
CP #49                            `
LD A,#00                          `
JR NZ,@rd2C_                      `
LD A,#80                          `
INC HL                            `
LD (#87F5),A               @rd2C_ `
CALL @rd2CY                       `
LD A,C                            `
CP #10                            `
RET NC                            `->error
LD A,(#87F5)                      `
ADD A,C                           `
LD (#87F5),A                      `
CALL @minSP                       `
LD A,(HL)                         `
AND #DF                           `
CP #49                            `
JR NZ,@rd2_Y                      `
INC HL                            `
LD A,(#87F5)                      `
SET 7,A                           `
LD (#87F5),A                      `
LD A,(#85D9)               @rd2_Y `nadawca 0..9 rozkazu
SUB #02                           ` 0..7 jawne i #FE i #FF tajny i pajny
CP #04                            `
RET NC                            `->error /brak uprawnień/
PUSH HL                           `adr. w treści analizowanego SMSa za odczytanym
LD A,(#87F5)                      `\nowy profil
LD B,A                            `/
LD A,(#8559)                      `stary profil
`!`#8559 -1b profil ustalający siatkę zdarzeń generujących alarm/informację (0...&15)
`!`       AND #0F oczywiście, siatka >#0E to siatka z SIM =MISC=
`!`       bit7=0  ='priorytet ALARM'
`!`           =1  ='priorytet INFORMACJA'
LD C,A                            `stary profil
PUSH BC                           `
PUSH BC                           `
LD A,B                            `\nowy profil
LD (#8559),A                      `/
CALL @BiqSi                       `
LD HL,@proFU                      ` ' zmieniono profil z '
CALL @PexA_                       `
POP BC                            `
LD A,C                            `
CALL @profI                       `
LD HL,@na___                      ` ' na '
CALL @PexA_                       `
POP BC                            `
LD A,B                            `
CALL @profI                @LSEDK `
JP @MkFtx                         `
INC HL                     @PRO_? `
PUSH HL                           `adr. w treści analizowanego SMSa za odczytanym
`pytanie o profil                  
CALL @BiqSi                       `
LD HL,@PROFI                      `
CALL @PexA_                       `
LD A,(#8559)                      `profil
JR @LSEDK                         `
`---------------------------------------
`
`tworzy SMS odpowiedzi na żądanie TEST
`trwa /poza NMI/                   
PUSH HL                    @TES__ `wykonaj TEST, adr. w treści analizowanego SMSa za odczytanym
CALL @poTES                       `
POP HL                            `
AND A                             `(NC)=poprawnie
RET                               `
`---------------------------------------
`
`wykonuje polecenie SMSowe 'ALARM'
`trwa /poza NMI/
LD A,(#85D9)               @ALA__ `wykonaj ALARM, nadawca 0..9 rozkazu
CP #02                            `czy to uprawniony nadawca?
SCF                               `
RET NZ                            `(C)=NIEpoprawnie
PUSH HL                           `adr. w treści analizowanego SMSa za odczytanym
`                                  
` tutaj miejsce na realizację faktyczną alarmu
`                                  
CALL @BiqSi                       `
LD HL,@ALAR_                      `
JP @MkFtX                         `drukuj i wyjdź
`----------------------------------
`
`omija spacje (jeśli są)           
`trwa poza NMI                     
LD A,(HL)                  @minSP `
CP #20                            `
RET NZ                            `
INC HL                            `
JR @minSP                         `
`----------------------------------
`
`porównaj tekst z SMSa (HL) ze znanymi wzorami rozkazów
` wynik w Acc i #8AD9, (Z) =nierozpoznane, (NZ) =rozpoznane
`trwa poza NMI                     
CALL @minSP                @rdROZ `
EX DE,HL                          `DE=tekst w SMSie, HL=nic
LD HL,@rozka                      `adr. tabeli ze słowami kluczowymi
LD B,(HL)                         `\liczba wyrazów w tabeli
LD A,B                            `/
INC A                             `+1
PUSH AF                           `liczba wyrazów w tabeli+1
INC HL                            `adres pierwszej litery w tabeli pierwszego wyrazu
PUSH DE                    @nzWzW `tekst w SMSie
PUSH HL                           `wzór
LD A,(DE)                  @nxZnA `adr. w SMSie
CP #21                            `czy to spacja lub koniec textu?
JR NC,@noSPa                      `hop -> nie, normalny znak
LD A,#20                          `wpisz spacje bo nieznany kod
CP #61                     @noSPa `czy mała litera?
JR C,@duLIt                       `hop -> duża litera
AND #DF                           `zmień na dużą literę
CP (HL)                    @duLIt `porównaj Acc(z SMSa) ze wzorem z (HL)
LD A,(HL)                         `Acc=znak ze wzoru (aby sprawdzić czy to znak zakończenia)
INC HL                            `\
INC DE                            `/next znak tu i tu
JR Z,@nxZnA                       `hop -> identyczne znaki 
AND A                             `czy koniec wzoru?
JR Z,@bingo                       `hop -> koniec, więc znaleźliśmy
POP HL                            `nie koniec, inny, szukaj dalej
LD A,(HL)                  @nie0# `przelećmy go do końca
INC HL                            `adres następnego znaku
AND A                             `czy =#00
JR NZ,@nie0#                      `hop -> nie, następny
POP DE                            `adr. tekstu do rozpoznania
DJNZ @nzWzW                       `
POP AF                            `
SUB A                             `
LD (#8AD9),A                      `zapamiętaj kod rozkazu
EX DE,HL                          `HL=adr. pierwszego znaku tekstu
RET                               `(Z) =nierozpoznane
POP HL                     @bingo `adr. we wzorze
POP HL                            `adr. w SMSie
POP AF                            `liczba wyrazów tabeli +1
EX DE,HL                          `HL=adr.za tekstem
DEC HL                            `bo ten znak był różny
SUB B                             `minus kolejny (dla TELEFON minus 4)
LD (#8AD9),A                      `zapamiętaj kod rozkazu
RET                               `(NZ) =rozpoznane
`---------------------------------------   
`
`rozpoznaje liczbę jedno lub dwucyfrową
`wynik w Crej i (#8ADB), jeśli #FF to nie przeczytano żadnej liczby
`poza NMI                          
CALL @minSP                @rd2CY `
LD C,#FF                          `
LD A,(HL)                         `
SUB #30                           `
CP #0A                            `
JR NC,@opqwd                      `hop -> zapamiętaj i wyjdź
LD C,A                            `
INC HL                            `
LD A,(HL)                         `
SUB #30                           `
CP #0A                            `
JR NC,@opqwd                      `hop -> zapamiętaj i wyjdź
LD B,A                            `
LD A,C                            `
ADD A,A                           `
ADD A,A                           `
ADD A,C                           `
ADD A,A                           `
ADD A,B                           `
LD C,A                            `
LD A,C                     @opqwd `
LD (#8ADB),A                      `zapamiętaj wynik
RET                               `
`----------------------------------
`
`zamienia do 8 cyfr z zakr 1..8 na zapalone bity w Crej
` wynik w Acc i #8ADA
`poza NMI
CALL @minSP                @rd8CY `
LD BC,#0800 `LD B,#08             `do 8 miu znaków
`LD C,#00                         `
LD A,(HL)                  @nxCyF `odczytaj znak ASCII
SUB #31                           `\
CP #08                            `/zamień cyfrę 1-8 na wartość #00..#07
JR NC,@:asmw                      `ret -> niezidentyfikowany znak
INC A                             `#01..#08
PUSH BC                           `zacgowaj B
LD B,A                            `
LD A,#80                          `
RLCA                       @nxBiT `
DJNZ @nxBiT                       `
POP BC                            `odtwórz B
OR C                              `
LD C,A                            `
INC HL                            `
DJNZ @nxCyF                       `
LD A,C                     @;asmw `
LD (#8ADA),A                      `zapamiętaj wynik
RET                               `
SUB A                      @:asmw `
JR @;asmw                         `hop -> brak cyfr =wyczyść numery
`----------------------------------
`
`rozpoznaje numer telefonu ASCII w treści SMSa odebranego
`poza NMI                          
CALL @minSP                @rdTEL `
LD DE,#8ACE                       `bufor odczytanego numeru telefonu
PUSH DE                           `adres bofora rozpoznanego numeru -l.znaków
PUSH HL                           `adre w tekście SMSa
LD L,E                            `\
LD H,D                            ` |
INC DE                            ` |wyczyść bufor rozpoznanego numeru
PUSH DE                           ` |
LD BC,#000A                       ` |
LD (HL),B                         ` |
LDIR                              `/
POP DE                            `adr, bajtu dla cyfr rozpoznanego numeru
POP HL                            `adres w tekście SMSa
LD A,(HL)                         `odczytaj pierwszy znak ASCII
CP #2B                            `czy to '+'
JR NZ,@mn'+'                      `hop -> opiń znak '+'
INC HL                            `
LD B,#14                   @mn'+' `max liczba cyfr to &20
LD A,(HL)                  @rdASC `odczytaj znak
SUB #30                           `
CP #0A                            `
JR NC,@finNP                      `hop -> zakończ bo to nie cyfra
INC HL                            `next baht
DEC B                             `
LD C,A                            `
LD A,(HL)                         `
SUB #30                           `
CP #0A                            `
JR NC,@hpNCf                      `hop -> to nie cyfra
INC HL                            `next bajt
RLCA                              `
RLCA                              `
RLCA                              `
RLCA                              `
JR @toCYf                         `hop -> cyfra, więc przeskocz wypełnienie
LD A,#F0                   @hpNCf `uzupełnij bo to nie cyfra była
OR C                       @toCYf `
LD (DE),A                         `
INC DE                            `
AND #F0                           `
CP #F0                            `
JR Z,@finNP                       `hop -> finito bo nie cyfra
DJNZ @rdASC                       `dalej jedziemy
LD A,#14                   @finNP `\
SUB B                             `/oblicz liczbę rozpoznanych cyfr
POP DE                            `adr. l.znajów bufora
LD (DE),A                         `zapisz
RET                               `
`---------------------------------------   
`
`pomocnicza oblicza adres znanego jawnego telefonu Acc do (#87F3)
` nie zmienia HL i Acc
`trwa /poza NMI/                   
LD (#8ADC),A               @l;pkf `#8ADC -1b wartość 0..7 określająca TELEFONx
PUSH HL                           `
PUSH AF                           `
LD HL,#8580                       `adres numeru jawnego '0' /czyli znanego'2'/
LD C,A                            `
ADD A,A                           `
ADD A,A                           `
ADD A,C                           `
ADD A,A                           `
ADD A,C                           `=*&11
LD C,A                            `
LD B,#00                          `
ADD HL,BC                         `HL= adres numeru tel, który zmieniamy
LD (#87F3),HL                     `na zaś
`#87F3 -2b pomocnicza zapamiętuje adres numeru tel dla interpretacji SMSa przychodzącego
POP AF                            `
POP HL                            `
RET
`---------------------------------------
`
`drukuje wartość profilu i jeśli jest to literkę 'I'
`trwa poza NMI
BIT 7,A                    @profI `
PUSH AF                           `
AND #0F                           `
CALL @A_xxX                       `drukuje do (DE) liczbę z Acc z 1, 2 lub 3 cyfrach
POP AF                            `
JR Z,@bezIi                       `
LD A,#69                          ` 'i'
LD (DE),A                         `
INC DE                            `
SUB A                      @bezIi `
LD (DE),A                         `
RET                               `
`---------------------------------------
`
`pomocnicza, wykonuje tekst i wysyła dla TEST (zarówno z SMSa jak i z cyny)
` [BiqSisterHome v0.99  TEST 230v zal. lin.tel. zal. lin.alarm ok, poziom GSM 4]
`trwa poza NMI
CALL @BiqSi                @poTES `
LD HL,@TEST_                      `
CALL @PexA_                       `
LD HL,@230V_                      `
CALL @PexA_                       `
LD A,(#87E7)                      `
`#87E7 -1b bity ustawień detektora 230V
`         bit7 -=1 jest 230V, =0 brak 230V
`         bit6 - \                 
`         bit5 -  | nic             
`         bit4 - /                  
`         bit3 -=1 było zdarzenie NIESTABILNE 230V
`         bit2 -=1 było zdarzenie ZASILANIE 230V
`         bit1 -=1 było zdarzenie BRAK 230V
`         bit0 -=1 było zdarzenie ZANIK 230V
BIT 7,A                           `
LD A,#01                          `
`Acc=0 (ON)                       `
`Acc=1 (OFF)                      `
`Acc>=2 (OK)                      `
JR Z,@fin23                       `
DEC A                             `
CALL @oNoFo                @fin23 `
LD HL,@l.tel                      `
CALL @PexA_                       `
LD A,(#86F8)                      `
`#86F8 -1b etap RingStatusTepsa:   
`          #00 =stand-by normal                      `ON
`          #01 =brak napięcia na linii telefonicznej `OFF
`          #02 =podniesiona słuchawka                `OK
`          #03 =uszkodzenie modułu alarmu            `OFF
`          #04 =incomming ring                       `OK
`          #05 =incomming dial                       `OK
`          #06 =outgoing ring                        `OK
`          #07 =outgoing dial                        `OK
`          #08 =outgoing my connection               `OK
AND A                             `
JR Z,@fnTte                       `
CP #01                            `
JR Z,@fnTte                       `
DEC A                             `
DEC A                             `
CP #01                            `
JR Z,@fnTte                       `
LD A,#02                          `
`Acc=0 (ON)                       `
`Acc=1 (OFF)                      `
`Acc>=2 (OK)                      `
CALL @oNoFo                @fnTte `
LD HL,@br_al                      `
CALL @PexA_                       `
LD A,(#80AB)                      `
`#80AB -> 1b tu ląduje 8 bitów odczytanych z portu A 8255 IN płytka NOKIA 
`               |7|6|5|4|3|2|1|0|  
`                | | | | | | | |   
`                | | | | | | | --< bit DCF77                           -
`                | | | | | | ----< bit dzwonka telefonu na hamaku/TPSA ON
`                | | | | | ------< bit gongu do drzwi                  ON
`                | | | | --------< bit otwartych drzwi                 ON
`                | | | ----------< bit alarmu -brak napięcia brąza     OFF
`                | | ------------< n.c. 
`                | --------------< n.c. 
`                ----------------< n.c. 
OR #E1                            `olej nieistotne tutaj bity -tylko brąz zostaje nieobsikany
` obsikuje też DCF77 bo jest analizowany w innym miejscu, tutaj przeszkadza
LD B,#02                          `
CP #E1                            `
JR Z,@fnBrA                       `OK
DEC B                             `
BIT 4,A                           `
JR Z,@fnBrA                       `OFF
DEC B                             `ON
`Acc=0 (ON)                       `
`Acc=1 (OFF)                      `
`Acc>=2 (OK)                      `
LD A,B                     @fnBrA `
CALL @oNoFo                       `
LD HL,@_gsm_                      `
CALL @PexA_                       `
LD A,(#807C)                      `
ADD A,#2F                         `
LD (DE),A                         `
INC DE                            `
SUB A                             `
LD (DE),A                         `
LD A,(#85D9)                      `nadawca 0..9 rozkazu
` tekst od #8744                   
` numer Acc z kolejnych            
JP @SMbAc                         `wyślij SMSa niezależnie czy poprzedni dostarczył delivery
`---------------------------------------
`
`pomocnicza, drukuje dla Acc=0 (ON)
`                        Acc=1 (OFF)
`                        Acc>=2 (OK)
`trwa /poza NMI/                   
AND A                      @oNoFo `
LD HL,@on___                      `
JR Z,@druKu                       `
LD HL,@off__                      `
DEC A                             `
JR Z,@druKu                       `
LD HL,@ok___                      `
JP @PexA_                  @druKu `
`---------------------------------------
`
`pomocnicza, rozpisuje Acc jako kolejne telefony 1..8
`trwa /poza NMI/
PUSH AF                    @BneTE `
LD HL,@TELEF                      `
CALL @PexA_                       `
POP AF                            `
LD B,#08                          `
RRCA                       @nxBiA `
JR NC,@bzBiA                      `
PUSH AF                           `
LD A,#39                          `
SUB B                             `
LD (DE),A                         `
INC DE                            `
POP AF                            `
DJNZ @nxBiA                @bzBiA `
LD A,#20                          `
LD (DE),A                         `
INC DE                            `
SUB A                             `
LD (DE),A                         `
RET                               `
`---------------------------------
`
`dekompresuje numer tel (HL..) jako ASCII na (DE..)
`wyjście Crej= liczba znaków ASCII cyfr (lib 1 gdy wydrukował '?')
`trwa: poza NMI                   
LD A,(HL)                 @NrTDe `l. znaków
LD B,A                           `l. znaków
LD C,A                           `liczba znaków na wyjście
AND A                            `
JR Z,@badNR                      `hop -> zły numer (brak cyfr)
CP #15                           `
JR C,@godNR                      `hop -> dobry numer (do &20 cyfr)
LD A,#3F                  @badNR ` '?'
LD (DE),A                        `
INC DE                           `
LD C,#01                         `liczba znaków =1 na wyjście
JR @PoZNR                        `hop ->zakończ #00
CP #09                    @godNR `
JR C,@xnZNR                      `hop bo za mało cyfr
LD A,#2B                         `dopisz plus
LD (DE),A                        `
INC DE                           `
INC C                            `liczba znaków na wyjście
INC HL                    @xnZNR `adr. pierwszego znaku
LD A,(HL)                        `
PUSH AF                          `
AND #0F                          `
ADD A,#30                        `
LD (DE),A                        `
INC DE                           `
POP AF                           `
DEC B                            `
JR Z,@PoZNR                      `hop -> koniec znaków
RLCA                             `
RLCA                             `
RLCA                             `
RLCA                             `
AND #0F                          `
ADD A,#30                        `
LD (DE),A                        `
INC DE                           `
DJNZ @xnZNR                      `pętla
SUB A                     @PoZNR `
LD (DE),A                        `znak końca #00
RET                              `
`---------------------------------
`
`prześlij text ze znakiem zakończenia #00 
`trwa poza NMI                    
LD A,(HL)                 @PexAS `
LD (DE),A                        `
AND A                            `
RET Z                            `ret -> znak końca tekstu
INC HL                           `
INC DE                           `
JR @PexAS                        `następny bajt odczytaj
`---------------------------------
`
`pomocnicza skracająca kod -ustala DE na początek adresu treści SMSa wychodzącego
` i wpisuje tam nazwę 'BiqSisterHome v0.99 '
`trwa poza NMI
LD DE,#8744                @BiqSi `
LD HL,@PigBr                      `
`... JP @PexA_                    `
`---------------------------------
`
`wysyła text z (HL) do (DE) jak PexAS ale kończy go spacją
`trwa poza NMI
CALL @PexAS               @PexA_ `
LD A,#20                         `
LD (DE),A                        `
INC DE                           `
RET                              `
`---------------------------------
`
`drukuje do (DE) liczbę z Acc z zakresu 00..99 na dwóch pozycjach (dwie cyfry)
`trwa poza NMI
PUSH BC                   @_A_## `
LD C,#FF                         `-1
INC C                     @nx@0A `
SUB #0A                          `
JR NC,@nx@0A                     `
ADD A,#3A                        `zamień na ASCII i odwróć ostatnie odejmowanie
LD B,A                           `jednostki
LD A,#30                         `\
ADD A,C                          `/dziesiątki na ASCII
LD (DE),A                        `
LD A,B                           `
INC DE                           `
LD (DE),A                        `
INC DE                           `
POP BC                           `
RET                              `
`---------------------------------
`
`drukuje do (DE) liczbę z Acc z zakresu 0..255 w 1, 2 lub 3 cyfrach
`trwa poza NMI
LD C,#2F                  @A_xxX `
INC C                     @nazd3 `
SUB #64                          `
JR NC,@nazd3                     `
ADD A,#64                        `
PUSH AF                          `
LD A,C                           `
LD (DE),A                        `
INC DE                           `
POP AF                           `
`JR @_A__#                        `
`przechodzi dalej...               
`---------------------------------
`
`drukuje do (DE) liczbę z Acc z zakresu 00..99 w jednej lub 2 cyfrach
`trwa poza NMI
LD C,#FF                  @_A__# `-1
INC C                     @nx@oA `
SUB #0A                          `
JR NC,@nx@oA                     `
ADD A,#3A                        `zamień na ASCII i odwróć ostatnie odejmowanie
LD B,A                           `jednostki
LD A,#30                         `\
ADD A,C                          `/dziesiątki na ASCII
CP #30                           `
JR Z,@A_##_                      `
LD (DE),A                        `
INC DE                           `
LD A,B                    @A_##_ `
LD (DE),A                        `
INC DE                           `
RET                              `
`---------------------------------
`
` @P2HMS drukuj czas z (HL) do (DE), lub @P2H:M tylko z dwóch bajtów godz i min
`   (HL)=godziny,+1=minuty,+2=sekundy 
`   jeśli godziny =0 to drukuje 00m00s
`   else 00h00m
`trwa poza NMI
LD BC,#676D               @P2H:M `ASCII 'gm'
INC HL                           `
INC HL                           `
JR @2bG:M                        `
INC HL                    @P2HMS `
INC HL                           `
LD A,(HL)                        `
LD BC,#676D                      `ASCII 'gm'
AND A                            `czy godziny =0?
JR Z,@god<0                      `hop -> minuty i sekundy
CP #64                           `
JR C,@god>0                      `hop -> godziny i minuty
LD HL,@>99go                     `
` tutaj wypisz po prostu '>99godz '
JP @PexA_                        `wysyła text z (HL) do (DE)  kończy spacją
DEC HL                    @god<0 `tutaj minuty i sekundy
LD BC,#6D73                      `ASCII 'ms'
LD A,(HL)                 @2bG:M `
CALL @_A_##               @god>0 `drukuj pierwszą wartość
LD A,B                           `
LD (DE),A                        `
INC DE                           `
DEC HL                           `
LD A,(HL)                        `
CALL @_A_##                      `drukuj drugą wartość
LD A,C                           `
LD (DE),A                        `
INC DE                           `
LD A,#20                         `zakończ spacją
LD (DE),A                        `
INC DE                           `
RET                              `
`--------------------------------
`
`prodedurka sprawdzająca czy jest połączenie przychodzące na NOKIA
`i interpretujaca je odbiór / odrzucenie
`trwa /poza NMI/
LD HL,#86A7               @InRIN `
`#86A7 1b IncommingCallFlag       
`        |7|6|5|4|3|2|1|0|        
`         0 ? ? ? ? ? ? ?  =nic się nie dzieje,
`         1 --------------->ring lub dial,
`         dr vvv  G M ----->aktywność głośnika / mikrofonu (=0 to aktywny),
`         dr vvv      rd -->gdy zakończone połączenie to zakończone na ringu(=0) lub dialu (=1),
`         dr vvv        dN->gdy zakończone to przez kogo drugi/system (=0) lub NOKIA (=1),
`         1 011 xx00 => dzwoni, ale czas trwania dzwonka do 3 sekund
`         1 010 xx00 => dzwoni, czas trwania dzwonka powyżej 3 sekund
`         1 010 xx10 => rozmowa,  
`         0 011 xx00 => po dzwonku uznanym za cynk,
`         0 010 xx00 => po dzwonku,
`         0 010 xx10 => po rozmowie,
`     np. 0 000 -po RESET... /lub gdy wykorzystano już tą informację/
LD A,(HL)                        `
AND A                            `
RET Z                            `wyjdź bo nic do analizy
` 1. dlaczego odrzuca połączenia? gdzie to robi?
` 2. wyklucz wysyłanie SMSów po połączeniach ze znanych numerów
BIT 7,A                          `czy trwa?
RET NZ                           `wyjdź, bo jeszcze nie przestał
LD B,A                           `
LD A,(#8558)                     `
`!`#8558 -1b &8 kluczy zdarzeń specjalnych nie zapisywanych do LOGu na które wysyła SMS
LD C,A                           `
LD A,(#86B4)                     `
`#86B4 -> 1b numer: z kim/do kogo dzwonisz: #00-#09 pozycja w znanych numerach
`       po 10 wywołaniach CPIR procedurka poCPR robi tak:
`                                           #FF-zastrzeżony
`                                           #FE-nieznany /przeszuk cała ks.tel/
`                                           #FD-nieznany /NIE przeszuk cała ks.tel/
`                                           #FC-błędny
`                                          lub że rozpoznany (#00-#09) 
`                                               umownie  #0A -jako numer konfigu (20znakowy...)
CP #FC                           `
JR Z,@NoRin                      `wyjdź bo błędny numer
CP #FF                           `
JR Z,@NoRin                      `wyjdź bo zastrzeżony numer
CP #0A                           `
JR NC,@njjzn                     `hop -> to nie jest jawny znany numer
CP #02                           `
JR NC,@jaWzN                     `hop -> to jest jawny znany numer
`                                 
`                                 
` tutaj dzwoni tajny lub pajny    
` możesz cosik zrobić /np test/ lub olać wychodząc do --> @njjzn
`                                 
`                                 
JR @njjzn                        `
LD (#85D9),A              @jaWzN `dzwoniący dla potrzeb TEST 0..9 
`tutaj jawny znany numer           
BIT 3,C                          `
`!`       bit 3 - 0=nic, 1=połączenie ze znanych traktowane jako polecenie TEST
JP NZ,@MkTes                     `hop -> zachowaj się jak po komendzie TEST
JR @NoRin                        `RET -> wyjdź bo opcja nie przewiduje
BIT 4,C                   @njjzn `
`!`       bit 4 - 0=nic, 1=SMS o połączeniu przychodzącym gdy nieznany numer
JR Z,@NoRin                      `RET -> wyjdź bo opcja nie przewiduje
LD DE,#8744                      `miejsce docelowe dla tekstu
`#8744 -&161 (#A1) bajtów ASCII z których można zakodować treść SMSa wychodzącego
` dodaj napis 'połączenie przychodzące na GSM: '
LD HL,@połąc                     `
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
LD HL,#80A0                      `adr. l.znaków numeru w ramie
CALL @NrTDe                      `
`wyślij na specjalne numery       
LD A,(#855B)                     `
`!`#855B -1b numery na które wysyłamy SMSspecjalny 
`wejście: Acc bitowo bit=1 to wysłanie, bit=0 nie wysyła
CALL @SMd8N                      `
RET Z                            `ret -> nie wysłano na żaden
`      teraz zeruj IncommingCallFlag
SUB A                     @NoRin `
LD HL,#86A7                      `
LD (HL),A                        `
RET                              `
CALL @poTES               @MkTes `zachowaj się jak po komendzie TEST
JR @NoRin                        `RET -> wyjdź bo opcja nie przewiduje
`---------------------------------------
`
`analizuje możliwość i potrzebę wysłania SMSa reklamowego
` no i chyba prowadzi statystykę reklam...
`trwa poza NMI
LD A,(#8554)              @SMsp5 `
`!`       #8554 -bit7 -> reklamy aktywne =1
BIT 7,A                          `
` sprawdzaj też bit wyłączenia reklam
`RET Z                            `
RET `**************************************
LD HL,#8E08                      `spr. autosumę reklamy w RAM
PUSH HL                          `
LD B,#9F                         `max tyle znaków sprawdza
CALL @nxASZ                      `
`sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak lub niepoprawne)
POP DE                           `
JR C,@REKok                      `hop -> autosuma poprawna
`tutaj zła autosuma -> wyślij raport o złej autosumie
LD A,#00                         `czyli typ RAPORTU_REKLAMY
CALL @rArEK                      `<<<RAPORT_REKLAMA>>>              
PUSH DE                          `
LD HL,@werbu                     `reklama stała z EPROM
CALL @PexAS                      `przesyła text z (HL) do (DE) włącznie z #00
POP HL `LD HL,#8E08              `spr. autosumę reklamy w RAM
LD B,#9F                         `max tyle znaków sprawdza
CALL @nxASZ                      `
`sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak lub niepoprawne)
JR C,@REKok                      `hop -> autosuma poprawna
DEC HL                           `
XOR (HL)                         `
LD (HL),A                        `
SUB A                     @REKok `\
LD (#8EA7),A                     `/na wszelki wypadek postaw zero za ASCII'Z' reklamy w RAM
LD HL,#87F6                      `
LD A,(HL)                        `
`#87F6 -1b sekundowy stoper pomocniczy do wysyłania reklam
CP #0A                           `\
RET NC                           `/czyli wchodzi dalej nie częściej niż co ok. 250 sekund
LD A,#FF                         `\
LD (HL),A                        `/startuj stoper od początku
` niżej sprawdzimy poprawność autosumy tabeli wysłanych SMS użytkownika
LD HL,#8DF8                      `sprawdzimy poprawność autosumy
CALL @ifAD$                      `
`wynik: Z= autosuma (ADD) tabeli (HL) zgodna
`       NZ= niezgodna autosuma     
JR Z,@gootR                      `hop -> poprawnie
` tutaj niepoprawna autosuma       
` ponieważ dolicza i oblicza autosumę poza NMI
` więc nie ma tutaj obawy że wstrzeli się w środek zapisu
` i spowoduje błąd                 
LD HL,#8DF8                      `
LD B,#08                         `
LD (HL),#00                      `zeruj
DEC HL                    @nxLRS `kolejny adres
DJNZ @nxLRS                      `pętla
RET                              `
LD B,#08                  @gootR `bo sprawdza ilości dla 8miu numerów
LD HL,#8DF1                      `
`#8DF1..#8DF8 -8b liczniki wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów o zdarzeniach i specjalnych
`              do celu wysyłania reklam na te numery
LD C,#0A                         `
LD A,(#8EF8)                     `
`#8EF8 - 1b pomocnicza decydująca o wysłaniu SMSów reklamowych, delta do liczby losowo ustalona
AND #07                          `
CP #07                           `\
JR NC,@nxWeR                     `hop -> dla #03 bez zmian:
` statystycznie: dla #00 -3         |
`                    #01 -2         |aby dodać losowy emenet, nie co równe np &10
`                    #02 -1         |tylko około, średnio co np. &10
`                    #03  0         |
`                    #04 +1         |
`                    #05 +2         |
`                    #06 +3         |
`                    #07  0         |
ADD A,C                          ` |
SUB #03                          `/ 
LD C,A                           `
` --- pętla wysyłająca SMS reklamowy
PUSH HL                   @nxWeR `pętla  HL= adr. w tabeli iności neutralnych SMS dla tego nr tel
PUSH BC                          `C= próg wysyłania, B=kolejno 8..1 dla pętli
LD A,(HL)                        `
SUB C                            `
JR C,@bzWeR                      `hop -> bez reklamy
CP C                             `sprawdź czy nie jest za dużo
JR C,@gOtWA                      `
LD A,C                           `wartość graniczna
DEC A                            `o 1 mniej bo granica była przekroczona
LD (HL),A                 @gOtWA `zapisz po odjęciu
LD A,#0A                         `
SUB B                            `wynik to numer adresata reklamy
PUSH AF                          `Acc to adresat, sporządź tekst reklamy i wyślij ją
` utwórz SMSa reklamowego          
LD DE,#8744                      `
PUSH DE                          `
`#8E09 - #9F ASCIIZ zawierających informację reklamową ASCIIZ
`        z policzoną autosumą do pierwszego bajtu (#8E08), która wyświetlana jest na LCD
`        lub wysyłana SMSami       
LD HL,#8E09                      `
CALL @PexAS                      `przesyła text z (HL) do (DE) włącznie z #00
POP HL                           `#8744= tekst dla SMSa
LD (#84F1),HL                    `adres tekstu do SMSkompresowania
POP AF                           `Acc to adresat
LD (#84F3),A                     `numer odbiorcy SMSa z kolejnych 2..9
`  wyślij SMSa niezależnie czy poprzedni dostarczył delivery
LD A,#88                         `normalny tekstowy z potwierdzeniem, 
LD (#84EE),A                     `wyślij SMSa
CALL @bijTI               @_xS_5 `
LD A,(#84EE)                     `
AND #F0                          `
CP #50                           `
JR Z,@bzWeR                      `nie wysłano SMSa z przyczyn sieci
CP #40                           `
JR NZ,@_xS_5                     `hop -> SMS jeszcze w trakcie wysyłania
` tutaj wysłano SMSa              
LD A,(#8002)                     `
`#8002 -> komórka cykliczna (zmienia swą wartość z szybkością przerwań)
LD (#8EF8),A                     `
`#8EF8 - 1b pomocnicza decydująca o wysłaniu SMSów reklamowych, delta do liczby losowo ustalona
POP BC                           `C= próg wysyłania, B=kolejno 8..1 dla pętli
POP HL                           `HL= adr. w tabeli iności neutralnych SMS dla tego nr tel
PUSH HL                          `\
PUSH BC                          `/dalej zachowaj na stosie
`#8DE8..#8DEF -8b liczniki REKLAM wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów reklamowych
LD BC,#0008                      `\
`AND A   bo NC i tak             ` |oblicz adres dla tego samego numeru w drugiej
SBC HL,BC                        `/ ZWIĄZANEJ tabeli wysłanych reklam
INC (HL)                         `
` teraz liczymy autosumę tabel     
LD HL,#8DF8                      `sprawdzimy poprawność autosumy tab I
CALL @ifAD$                      `
`wynik: Z= autosuma (ADD) tabeli (HL) zgodna
`       NZ= niezgodna autosuma    
LD (HL),A                        `zapisz obliczoną autosumę
POP BC                    @bzWeR `
POP HL                           `
INC HL                           `
DJNZ @nxWeR                      `
` sprawdzamy teraz warunki brzegowe D i E
`   i jeśli któryś spełniony to wysyłamy statystykę SMS i zerujemy 
LD HL,#8DE8                      `
`#8DE8..#8DEF -8b liczniki REKLAM wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów reklamowych
LD B,#08                         `pętla dla 8miu wartości
LD DE,#0000                        
` do Drej suma all                 
` do Erej max wartość              
LD A,(HL)                 @chkSW `
CP E                             `sprawdzana - maksymalna
JR C,@SLFQW                      `hop -> wart. max jest większa /nie zmieniaj/
LD E,A                           `zapamiętaj jako wartość maksymalna
ADD A,D                   @SLFQW `\doliczamy do sumy całości
LD D,A                           `/
INC HL                           `
DJNZ @chkSW                      `
LD A,#13                         `czyli =&19 reklam SMS
CP E                             `czy max na jeden numer >= &20 reklamSMS ?
JR NC,@finRE                     `hop ->spełniony warunek brzegowy wysyłania SMS reklamy
LD A,#63                         `czyli =&99 reklam SMS
CP D                             `czy max na wszystkie numery >= &100 reklamSMS ?
RET C                            `wyjdź ->nie spełniony żaden warunek brzegowy
LD A,#80                  @finRE `czyli typ RAPORTU_REKLAMY
CALL @rArEK                      `<<<RAPORT_REKLAMA>>>              
` NC -> nie wysłano SMSa z przyczyn sieci
` CY -> wysłano SMSa              
RET NC                           `wyjdź, bo nie wysłano SMSa
`********                         
LD HL,#8554                      `blokuj bit reklamy
`!`       #8554 -bit7 -> reklamy aktywne =1
RES 7,(HL)                       `
`******** tu chyba jednak nie blokada reklamy...
LD A,#01                         `
LD (#807D),A                     `
`#807D -> 1b czas (minuty) do zapisu konfigów -biegnie sobie w dół popychany w time+
`            przejście z #01 na #00 powoduje (jeśli DKrok=#FF) wpisanie DKrok =#08, jeśli
`            niemożliwe to pozostaje przez kolejną minutę #01,
`            po potwierdzeniu zapisu SMSa w Dkroku =#09 wpisujemy tu czas w minutach do 
`            następnego zapisu konfigów
LD HL,#8DEF                      `
LD B,#09                         `
LD (HL),#00               @nxLRR `zeruj
DEC HL                           `kolejny adres
DJNZ @nxLRR                      `pętla
RET                              `
`----------------------------------------
`
`analizuje konieczność wysłania raportów płatniczych
` no i konieczność blokady wysyłania SMS
`trwa poza NMI
NOP                       @SMsp6 `
RET                              `
`----------------------------------------
`
`pomocnicza do wysyłania SMSa bajtowego raportu reklamy
`wejście Acc= typ raportu reklamowego
`wyjście:                         
` NC -> nie wysłano SMSa z przyczyn sieci
` CY -> wysłano SMSa              
`trwa poza NMI                    
LD HL,#8744               @rArEK `<<<RAPORT_REKLAMA>>>              
LD (#84F1),HL                    `
`#8744 -&161 (#A1) bajtów ASCII z których można zakodować treść SMSa wychodzącego
LD (HL),#10                      `czyli bajtowy raport reklamy
INC HL                           `
LD (HL),A                        `typ raportu
`LD A,#00                        `czyli typ RAPORTU_REKLAMY ->po pierwszym starcie
`LD A,#80                        `czyli typ RAPORTU_REKLAMY ->po osiągnięciu war. brzegowych
INC HL                           `
EX DE,HL                         `
LD HL,#8DE8                      `
`#8DE8..#8DEF -8b liczniki REKLAM wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów reklamowych
`#8DF0 -1b /ADRESY ZWIĄZANE z #8DE8../ autosuma #8DF1..#8DF8 (ADD)
`#8DF1..#8DF8 -8b liczniki wysłanych SMS na poszczególne numery tel.
`              odpowiadają jawnym numerom 1..8 i zawierają liczbę z zakresu #00..#FF odpowiadającą
`              liczbie wysłanych na ten numer SMSów o zdarzeniach i specjalnych
`              do celu wysyłania reklam na te numery
LD BC,#0011                      `
LDIR                             `
`#8E08 - autosuma dla tej informacji poniżej, XOR do bajtu #00 daje #00
`#8E09 - #9F ASCIIZ zawierających informację reklamową ASCIIZ
`        z policzoną autosumą do pierwszego bajtu (#8E08), która wyświetlana jest na LCD
`        lub wysyłana SMSami        
LD HL,#8E08                      `
LD BC,#0080                      `powinno być mniej ale i tak się mieści
LDIR                      @__3xs `
LD A,#00                         `\
LD (#84F3),A                     `/odbiorca =tajny numer
LD A,#84                         `\
LD (#84EE),A                     `/nadaj bajtowy bez delivery bez wcześniejszego delivery
CALL @bijTI               @_xS33 `
LD A,(#84EE)                     `
AND #F0                          `
CP #50                           `
RET Z                            `ret (NC) -> nie wysłano SMSa z przyczyn sieci
CP #40                           `
JR NZ,@_xS33                     `hop -> SMS jeszcze w trakcie wysyłania
SCF                              `
RET                              `ret (CY) -> wysłano SMSa
`----------------------------------------
`
`pomocnicza do wysyłania SMSa bajtowego raportu reklamy
`wejście Acc= typ raportu paynego 
`wyjście:                         
` NC -> nie wysłano SMSa z przyczyn sieci
` CY -> wysłano SMSa              
`trwa poza NMI                    
LD HL,#8744               @rApAY `<<<RAPORT_PAYA>>>
LD (#84F1),HL                    `
`#8744 -&161 (#A1) bajtów ASCII z których można zakodować treść SMSa wychodzącego
LD (HL),A                        `czyli bajtowy raport paya
INC HL                           `
EX DE,HL                         `
`#804E -> 2b CID      \           
`#8050 -> 2b LAC      |sieć i lokalizacja telefonu (chwilowe)
`#8052 -> 4b SIEĆ GSM /           
LD HL,#804E                      `
LD BC,#0008                      `
LDIR                             `
`#8059 -> 8b to &15 cyfr IMEI + zero skompresowanych dwie w jednym bajcie (identycznie jak w NOKII)
`  (ostatnia pusta pozycja to OR #F0)
`   aby sprawdzić czy jest IMEI, wystarczy sprawdzić ostatni bajt, 
`  (po starcie wpisujemy tam #00 (#8060))
`#8061 -> 6b to ASCIIZ nazwa modelu aparatu NOKIA np."NSE-1"
`#8067 -> 8b to ASCIIZ ? "0502562"
`#806F -> 5b to ASCIIZ ? "4230"   
`#8074 -> 6b to ASCIIZ ? "05.28"  
`...#807A  -> #0021               
LD HL,#8059                      `
LD BC,#0021                      `
LDIR                             `
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7 -> ?
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
`...#8556 -> #0003                
LD HL,#8554                      `
LD BC,#0003                      `
LDIR                             `
`!`#8580: 1b + #8581-#858A &10b numer 2 ('0' dla użytkownika) |(jak w SMSie)
`------------- koniec obszaru konfigu ------------            |ostatnia nieparzysta 
`  #858B: 1b + #858C-#8595 &10b numer 3 ('1' dla użytkownika) |uzupełniona o #F0
`  #8596: 1b + #8597-#85A0 &10b numer 4 ('2' dla użytkownika) |a po niej same zera!!!
`  #85A1: 1b + #85A2-#85AB &10b numer 5 ('3' dla użytkownika) |
`  #85AC: 1b + #85AD-#85B6 &10b numer 6 ('4' dla użytkownika) |jeśli jakaś pozycja zawiera
`  #85B7: 1b + #85B8-#85C1 &10b numer 7 ('5' dla użytkownika) |długość =0 
`  #85C2: 1b + #85C3-#85CC &10b numer 8 ('6' dla użytkownika) |to traktujemy ją jako pustą
`  #85CD: 1b + #85CE-#85D7 &10b numer 9 ('7' dla użytkownika) |
`         ^-----1b to liczba cyfr numeru tel.                  
`                         ...#85D7 -ostatni bajt numeru
LD HL,#8580                      `
LD BC,#0058                      `powinno być mniej ale i tak się mieści
LDIR                             `
`#8E00 -1b sek  \                 
`#8E01 -1b min   \wieczny zegar   
`#8E02 -1b godz  /                
`#8E03 -2b dni  /                 
`#8E05 -2b suma (#8E00..#8E02) + (#8E03) + wartość #55AA
LD HL,#8E00                      `
LD BC,#0007                      `powinno być mniej ale i tak się mieści
` razem:                         `
`      #0001                     `
`LD BC,#0008                     `
`LD BC,#0021                     `
`LD BC,#0003                     `
`LD BC,#0058                     `
`LD BC,#0007                     `
`-----------                     `
`      #008C                     `
JR @__3xs                        `
`----------------------------------------
`
`pomocnicza do obliczania autosum (ADD) tabeli SMSów
`wejście: HL=adres tabeli, autosuma liczona w dół adresów, porównanie pod tabelą
`wynik: Z= autosuma (ADD) tabeli (HL) zgodna
`       NZ= niezgodna autosuma
`trwa /poza NMI/
LD B,#07                   @ifAD$ `
LD A,(HL)                         `startuj autosumę
DEC HL                     @nxLRs `kolejny adres
ADD A,(HL)                        `dodaj wartość
DJNZ @nxLRs                       `pętla
DEC HL                            `adres bajtu autosumy
CP (HL)                           `sprawdź wynik
RET                               `
`------------------------ KONIEC NOKIA --------------------------------------
`----------------------------------------
`
`procedury sterujące LCD:                
`--------------------------------------------------
` @R_AcR trwa *249[tkt]         @R_AcD trwa *251[tkt]
` @W_AcR trwa *151[tkt]         @W_AcD trwa *139[tkt]
`--------------------------------------------------
`poniższa zmienia tylko E, 
LD E,#00               @W_AcR `zapisz Ac jako rozkaz (RS=0, RW=0)
JR #02                        `chodzi o bit PC3 x,x,x,x,rs,rw,en,x
`                                               x,x,x,x,RS,rw,en,x
LD E,#08               @W_AcD `zapisz Ac jako daną (RS=1, RW=0)
PUSH BC                       `
LD BC,#5041                   `
OUT (C),A                     `PB #5041
INC C                         `
LD A,(#80AC)                  `odczytaj co wysłać na PC
AND #F1                       `ustaw nieaktywne(=L) bity 1-3
OR E                          `
OUT (C),A                     `PC #5042 zapis do portu C
`                                          x,x,x,x,??,??,en,x
OR #02                        `zmień Enable w LCD czyli PC6 xxxx xxXx
`                                          x,x,x,x,??,??,EN,x
OUT (C),A                     `tutaj zapisz  PC #5042
AND #F1                       `ustaw nieaktywne bity 1-3
OUT (C),A                     `teraz wyzeruj bity sterujące LCD  PC #5042
POP BC                        `
RET                           `
`-----                         
LD E,#0C               @R_AcD `odczytaj Acc jako dane (RS=1, RW=1)
JR #02                        `chodzi o bit PC3 x,x,x,x,RS,RW,en,x
`                                               x,x,x,x,rs,RW,en,x
LD E,#04               @R_AcR `odczytaj Acc jako bit zajętości/adres (RS=0, RW=1)
PUSH BC                       `
LD A,#92                      `8255 PA in,  PB in, PC74 out, PC30 out
`------------------------------------------------------------------------------------------
`=1  bit7: zawsze 1            
`=00 bit6 i 5: tryb pracy rejestru A: 00-tryb 0, 01-tryb 1, 02 (i 03)- tryb 2
`=1  bit4: kierunek PA: 1-wejście, 0-wyjście
`=0  bit3: kierunek PC4-PC7: 1-wejście, 0-wyjście
`=0  bit2: tryb pracy PB: 0-tryb 0, 1-tryb 1
`=1  bit1:  kierunek PB: 1-wejście, 0-wyjście
`=0  bit0:  kierunek PC0-PC3: 1-wejście, 0-wyjście
`czyli w sumie 1001 0010 -> #92
`------------------------------------------------------------------------------------------
LD BC,#5043                   `
OUT (C),A                     `P@ #5043
DEC C                         `
LD A,(#80AC)                  `odczytaj co wysłać na PC
AND #F1                       `ustaw nieaktywne bity 1-3
OR E                          `
OUT (C),A                     `PC #5042 zapis do portu C
`                                          x,x,x,x,??,??,en,x
OR #02                        `zmień Enable w LCD czyli PC1 xxxx xxXx
`                                          x,x,x,x,??,??,EN,x
OUT (C),A                     `PC #5042
DEC C                         `
IN A,(C)                      `PB #5041
PUSH AF                       `
INC C                         `
SUB A                         `
OUT (C),A                     `PC #5042 (wyzeruj bity sterujące LCD)
INC C                         `
LD A,#90                      `8255 PB out, PC74 out, PC30 out, PA in
OUT (C),A                     `P@ #5043
DEC C                         `dla pewności bity PC30 wyzeruj
LD A,(#80AC)                  `odczytaj co wysłać na PC
AND #F1                       `ustaw nieaktywne bity 1-3
OUT (C),A                     `PC #5042 =#00 zapis do portu C
POP AF                        `
POP BC                        `
RET                           `
`-------------------------------
`
` procedura zerująca wyświetlacz LCD:
LD HL,@SWLCD           @reSLN `tabela zawierająca dane-bajty zerujące do wysłania do LCD,
LD B,(HL)                     `
INC HL                 @nxBYT `
LD A,(HL)                     `
CALL @W_AcR                   `
LD DE,#07FF        `czekaj >4,1[ms]?(dla #02FF)  (1tkt to 0,25 mikrosek), 4,1[ms] to 16400tkt
`                   #07FF to ok. 28tyś tkt -> 7[ms]
DEC E               @wtRES      `4tkt             \to trwa 16*(E-1)+11  \to trwa:
JR NZ,@wtRES                    `12(jump) 7(nie)  / dlaE=#00->4091tkt   | 16*(E-1)+11
DEC D                           `4tkt                                   |+4107*(D-1)+4102
JR NZ,@wtRES                    `12(jump) 7(nie)                        /
DJNZ @nxBYT                   `
RET                           `
` Sekwencja włączająca LCD     
DEFETYK @SWLCD                 
DEFBAJT1 #07   `w sumie 7 bajtów,
DEFBAJT1 #38   `pierwsze 4 bajty #38 to sekwencja zerująca oznaczająca,
DEFBAJT1 #38   `8 bitów, 2 wiersze, matrycę 5*7,
DEFBAJT1 #38   `                  
DEFBAJT1 #38   `                
DEFBAJT1 #06   `tryb wprowadzania: zwiększaj adres kursora, nie przesuwaj ekranu,
DEFBAJT1 #0C   `było #0C `sterowanie wyświetl: włącz wyświetl., kursor niewid, niemig,
DEFBAJT1 #01   `oczyść ekran,  
`---------------------------------------
`                               
` w Acc wychodzi liczba dni (0...#1E) w miesiącu A roku E
` trwa max 149tkt 
` nie zmienia DE
LD HL,@ldnim           @DmArE `
LD C,A                        `miesiąc
LD B,#00                      `
ADD HL,BC                     `bajt (HL) określa liczbę dni w miesiącu
CP #01                        `czy luty?
LD A,(HL)                     `tu nie luty -> z tabeli
RET NZ                        `Z to luty (dodatkowe sprawdzenie)
`                             NZ to inny niż luty -> liczba dni z tabeli
` lata przestępne -wiadomo że co czwarty, wyjątkiem jest 2100 i 2200`
LD A,E                        `rok
AND A                         `
LD A,#01                      `aby nie było #00 bo będzie przestępny, a 2000r to wyjątek
JR Z,@npret                   `hop -> nie przestępny
LD A,E                        `rok
CP #64                        `rok 2100     
JR Z,@npret                   `hop -> nie przestępny
CP #C8                        `rok 2200     
JR Z,@npret                   `hop -> nie przestępny
AND #03                       `
CP #00                 @npret `
` Z dla lat przestępnych       
LD A,#1C                      `#1C =&28 -> dzyli 29-ty dzień miesiąca! ->przestępny
RET Z                         `wyjdź gdy inny niż co czwarty lub gdy wyjątek
LD A,#1B                      `#1B =&27 -> dzyli 28-my dzień miesiąca!
RET                           `
`------------------------------
`
`w Acc wychodzi dzień tygodnia roku L (#00 to 2000r),
`                              miesiąca H (#00=styczeń),
`                            i dnia D (#00 to 1 'pierwszy')
`trwa max. +463tkt               
LD A,L                 @jakDT `rok
SUB #CC                       `2204
LD E,#06                      `NIEDZIELA 01.01.2204
JR NC,@indMa                  `hop w tym zakresie bez wyjątków
ADD A,#CC                     `
SUB #C8                       `2200
LD E,#02                      `ŚRODA 01.01.2200
JR NC,@NindM                  `hop w tym zakresie wyjątek
ADD A,#C8                     `
SUB #68                       `2104
LD E,#01                      `WTOREK 01.01.2104
JR NC,@indMa                  `hop w tym zakresie bez wyjątków
ADD A,#68                     `
SUB #64                       `2100
LD E,#04                      `PIĄTEK 01.01.2100
JR NC,@NindM                  `hop w tym zakresie wyjątek
ADD A,#64                     `
LD E,#05                      `SOBOTA 01.01.2000
LD B,A                 @indMa `w tym zakresie bez wyjątków
`    z Brej zrobimy potem pRO mod 4
RRCA                          `\
RRCA                          ` | div 4 /liczba pełnych 4 letnich okresów/
AND #3F                       `/
LD C,A                        `
ADD A,A                       `\
ADD A,A                       ` | * 5 bo każdy 4 letni okres daje DT +5
ADD A,C                       `/
ADD A,E                       ` dodajemy DT startowe dla 1 stycznia danego roku
LD E,A                        `
LD A,B                        `z Brej robimy pRO mod 4 /czyli liczba lat ponad pełne czwórki/
AND #03                       `mod 4
JR Z,@poRok                   `hop -> brak lat ponad pełne czwórki
INC E                         `bo w zakresie bezwyjątkowym pierwszy z czwórki jest przestępny
ADD A,E                @NindM `uzupełnij o liczbę lat (dla każdego poprawka o 1)
LD E,A                        `
LD A,H                 @poRok `tutaj mamy obliczony DT dla 1 stycznia danego roku
AND A                         `
JR Z,@poMIE                   `hop -> bo styczeń
DEC A                         `
LD BC,@DT_MI                  `
ADD A,C                       `
LD C,A                        `oblicz adres poprawki na miesiąc z tablicy @DT_MI
LD A,(BC)                     `
ADD A,E                       `
LD E,A                        `
LD A,H                        `miesiąc
CP #02                        `
JR C,@poMIE                   `hop -> bo styczeń lub luty
` tu wchodzi w grę luty (bo miesiąc marzec lub większy) tak więc trzeba sprawdzić czy podany rok
` jest rokiem przestępnym, jeśli jest to dodatkowo DT + 1
LD A,L                        `rok
CP #64                        `to 2100r
JR Z,@poMIE                   `hop -> nieprzestępny (wyjątek)
CP #C8                        `to 2200r
JR Z,@poMIE                   `hop -> nieprzestępny (wyjątek)
AND #03                       `
JR NZ,@poMIE                  `hop -> nieprzestępny 
`tu przestępny więc +1 ze względu na dłuższy luty
INC E                         `
LD A,D                 @poMIE `tu obliczony DT na pierwszy dzień danego miesiąca
` Drej to dni miesiaca-1       
ADD A,E                       `
` tu obliczony DT dla danej daty, trzeba jeszcze tylko zrobić modulo 7
` odtąd do końca trwa max. 176tkt
LD D,A                        `przechowaj wartość (będą potrzebne 3 najmłodsze bity)
LD E,#00                      `pomocnicza=0
RLCA                          `CY =7bit, czyli jeśli -128 to +2 (128 mod 7 = 2)
JR NC,@_jDT1                  `
LD E,#02                      `pomocnicza +2
RLCA                   @_jDT1 `CY =6bit, czyli jeśli -64 to +2 (64 mod 7 = 1)
JR NC,@_jDT2                  `
INC E                         `pomocnicza +1
RLCA                   @_jDT2 `CY =5bit, czyli jeśli -32 to +4 (32 mod 7 = 4)
JR NC,@_jDT3                  `
INC E                         `\
INC E                         ` \pomocnicza +4
INC E                         ` /
INC E                         `/
RLCA                   @_jDT3 `CY =4bit, czyli jeśli -16 to +2 (16 mod 7 = 2)
JR NC,@_jDT4                  `
INC E                         `\pomocnicza +2
INC E                         `/
RLCA                   @_jDT4 `
JR NC,@_jDT5                  `CY =3bit, czyli jeśli -8 to +1 (8 mod 7 = 1)
INC E                         `pomocnicza +1
LD A,D                 @_jDT5 `\
AND #07                       `/zachowaj tylko 3 najmłodsze bity (max 7)
ADD A,E                       `dodaj pomocniczą (max 10)
SUB #07                @_jDT6 `tu chamskie modulo 7 (ale max. wchodzi tu &17) -> max 3 razy
JR NC,@_jDT6                  `
ADD A,#07                     `
RET                           `wynik w Acc z zakresu 0-6 -> dzień tygodnia wejściowej daty
`-------------------------------
`
`procedurka wywoływana często, ale nieregularnie
`do wykonywania jeszcze innego zadania w tle
`pozostałych wątków programu        
`trwa /poza NMI/                  
PUSH AF                   @bijTI `bijTIME
PUSH BC                          `
PUSH DE                          `
PUSH HL                          `
`CALL @freeT                      `cóś tu zrób dowolnego...        
POP HL                           `
POP DE                           `
POP BC                           `
POP AF                           `
RET                              `
`---------------------------------
`
`sprawdza poprawność znajdującego się w RAM opisu ASCIIZ miejsca znajdowania
`się alarmu:                       
`sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak lub niepoprawne)
`nie zmienia DE                   
LD HL,#8EB9               @chAsI `
`#8EB9 -#3F bajtów 1b+ #39b ASCIIZ zawierających informację typu: 
`    'Swinoujscie, ul. Grunwaldzka 66/27 IV pietro'#00 z policzoną autosumą 
`    do pierwszego bajtu (#8EB9)    
`1. spr zakończenie #00 i liczbę znaków >min
LD B,#3F                         `max tyle znaków sprawdza
LD C,B                    @nxASZ `tutaj zaczynamy dla zdefiniowanego B i HL
INC HL                    @nxASz `pętla
LD A,(HL)                        `
AND A                            `czy to #00 ?
JR Z,@mam00                      `hop -> znaleziony
CP #20                           `
CCF                              `
RET NC                           `(NC) =źle, bo znak ASCII z poza zakresu
CP #7F                           `
RET NC                           `(NC) =źle, bo znak ASCII z poza zakresu
DJNZ @nxASz                      `pętla
RET                              `(NC) =źle, bo brak zakończenia #00
LD A,C                    @mam00 `\
INC A                            ` |wynik =liczba znaków ASCIIZ +1
SUB B                            `/
CP #04                           `min liczba znaków to 3 (bo #04 minus 1)
CCF                              `
RET NC                           `(NC) =źle, bo zbyt mała liczba znaków
`2. spr autosumę                   
LD B,A                           `dla tylu znaków licz autosumę
LD A,(HL)                        `startuj autosumę
DEC HL                    @nxAS_ `next  
XOR (HL)                         `dolicz bajt po tym NC
DJNZ @nxAS_                      `pętla <-nie zmienia Frej
INC HL                           `aby HL=adr pierwszego znaku
RET NZ                           `(NC) =źle, bo zła autosuma
SCF                              `
RET                              `(CY) =dobrze
`---------------------------------
DEFETYK @PRdom                      
`!`#850A -> 5b to dane o domyślnym prefiksie -dołączanym do każdego nru 
`!`            połączenia przychodzącego, który nie zaczyna się plusem
`!`   #850A -> 1b to liczba cyfr(tylko!) ASCII 0-4 domyślnego prefiksu (=0 gdy brak prefiksu)
`!`   #850B -> 4b to 4 kody ASCII cyfr tego domyślnego numeru prefixu
DEFBAJT1 #02 #34 #38 #00 #00 `domyślny prefix 
`-------------- poniżej same zera     
`DEFETYK @_wCO2  `zawartość 2 do tworzenia konfigu zerowego
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 `                           
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 #00 
`DEFBAJT1 #00 #00 #00 #00                 
`------------------------------
DEFETYK @_wCO3  `zawartość 2 do tworzenia konfigu zerowego
DEFBAJT1 #11 #FF #01                      
DEFBAJT1 #01 #01 #01 #01                 
`!`---znane numery w konfigu:            
`!`#855E-#8569 ->12& bajtów centrum SMS (jak w SMSie)         |gdy (#855E)=#00 to pusty
`!`#856A: 1b + #856B-#8574 &10b numer 0 ('0' poufnych)        |po &11 bajtów
`!`#8575: 1b + #8576-#857F &10b numer 1 ('1' poufnych)        |skompresowanych cyfr 
` to poniżej musi być tutaj już zakodowane!                                  
DEFBAJT1 #ED #01 #35 #18 #A5 #93 #34 #00 #0F #0F #E6 #1F  
`        #E6 #70 #B1 #12 #13 #7E #23 #0F #0F #0F #E6 #1F   <-- koder
`        --- --- --- --- --- --- --- --- --- --- --- --- 
`        #07 #91 #84 #06 #92 #15 #11 #F1 #00 #00 #00 #00 `nr centrum SMS Ery
`                                                    
DEFBAJT1 #5A #02 #A5 #68 #A6 #B5 #05 #13 #7E #23 #0F 
`        #4F #7E #0F #E6 #40 #B1 #12 #13 #7E #23 #0F   <-- koder
`        --- --- --- --- --- --- --- --- --- --- --- 
`        #0B #84 #96 #82 #66 #04 #F3 #00 #00 #00 #00 `tajny 0 /TakTak:692866403/
`
`DEFBAJT1 #5A #02 #15 #18 #77 #21 #04 #13 #7E #23 #0F 
``        #4F #7E #0F #E6 #40 #B1 #12 #13 #7E #23 #0F   <-- koder
``        --- --- --- --- --- --- --- --- --- --- --- 
``        #0B #84 #06 #32 #37 #70 #F2 #00 #00 #00 #00 `tajny 0 /mójGSM/
``
`DEFBAJT1 #5A #02 #96 #0A #79 #45 #09 #13 #7E #23 #0F  `<<<<<<<<< sprawdź czy dobrze zakodowany
``        #4F #7E #0F #E6 #40 #B1 #12 #13 #7E #23 #0F   <-- koder
``        --- --- --- --- --- --- --- --- --- --- --- 
``        #0B #84 #87 #24 #39 #94 #F7 #00 #00 #00 #00 `tajny /tak-tak/
``                                                    
`DEFBAJT1 #F1 #03 #18 #67 #39 #37 #77 #7E #23 #0F #0F
``        #E6 #7F #12 #13 #22 #D1 #80 #7E #23 #0F #0F   <-- koder
``        --- --- --- --- --- --- --- --- --- --- --- 
``        #0B #84 #06 #54 #17 #66 #F7 #00 #00 #00 #00 `tajny 1 /Aneta służbowy/
``                                                    
DEFBAJT1 #F1 #03 #A8 #95 #88 #D5 #73 #7E #23 #0F #0F 
`        #E6 #7F #12 #13 #22 #D1 #80 #7E #23 #0F #0F   <-- koder
`        --- --- --- --- --- --- --- --- --- --- --- 
`        #0B #84 #96 #82 #66 #04 #F3 #00 #00 #00 #00 `payny 1 /TakTak:692866403/
`
`DEFBAJT1 #F1 #03 #18 #45 #59 #41 #72 #7E #23 #0F #0F 
``        #E6 #7F #12 #13 #22 #D1 #80 #7E #23 #0F #0F   <-- koder
``        --- --- --- --- --- --- --- --- --- --- --- 
``        #0B #84 #06 #32 #37 #70 #F2 #00 #00 #00 #00 `payny 0 /mójGSM/
``
`DEFBAJT1 #F1 #03 #99 #37 #5B #65 #77 #7E #23 #0F #0F
``        #E6 #7F #12 #13 #22 #D1 #80 #7E #23 #0F #0F   <-- koder
``        --- --- --- --- --- --- --- --- --- --- --- 
``        #0B #84 #87 #24 #39 #94 #F7 #00 #00 #00 #00 `payny  /tak-tak/
``                                                    
DEFBAJT1 #0F  `<-- wartość 'czysta'                  `jawny 0 (brak)
`        #0F   <-- koder
`        ---   
`        #00   <-- to co pomiędzy NOKIA a system
`---------
`adresy procedur obsługi wyświetlania II linijki LCD
DEFETYK @_LCD_ `
DEFTABE LCD00  `+165tkt inicjacja wyświetlania LCD
DEFTABE LCD01  `+792tkt przedstawianie się na LCD
DEFTABE LCD02  `+717tkt reklamaz EPROM
DEFTABE LCD03  `+781tkt reklama z RAM
DEFTABE LCD04  `+880tkt wyświetlanie naprzemiennie dwu buforów zdarzeń od prawej
`DEFTABE LCD05  `alarmowo gdy nie ma np. możliwości wysłania SMS...
` wyższe to linijka nie wykorzystana
`------------------------------------
`
`miejsce dla wywoływania tej procedury (@RS_PC) to będzie 
`gdzieś w @_tme1 czyli wywoływana 250 razy w sekundzie
`ponieważ RS232 z komputerem jest taktowane i ustawione do
`prędkości 2500Bodów -> 250 bajtów/sekundę
`     mamy 1668tkt na to co wykonuje poniżej:
DEFETYK @kPCRS `kroki realizacji nadawania i odbioru wierszy do i z komputra PC
DEFTABE PRs00 ` +169tkt odbierz od PC bajt nagłówka #1F, startuj autosumę, rozpocznij TimeGuarda
DEFTABE PRs01 ` +262tkt odbierz bajt rozkazu wiersza RS232 z PC
DEFTABE PRs02 ` +295tkt odbierz bajt długości wiersza RS232 z PC
DEFTABE PRs03 ` +322tkt odbierz i zapisz w buforze bajty treści
DEFTABE PRs04 ` +258tkt odbierz i sprawdź bajt XOR autsumy
DEFTABE PRs05 ` +228tkt przerwa technologiczna przed nadaniem ACK i nadaj #1F
DEFTABE PRs06 ` +163tkt nadaj bajt ACK #7F
DEFTABE PRs07 ` +189tkt nadaj bajt XOR autosumy ACK
DEFTABE PRs08 ` +603tkt krok po odebraniu poprawnego wiersza z PC i jego          <----------
`                                                               potwierdzeniu ACK
DEFTABE PRs09 ` +280tkt decyduj co dalej robić, to węzeł pętli obliczający 
`                                        adresy itd dla nadawania obszaru pamięci
DEFTABE PRs0A ` +186tkt tutaj węzełek dla replay gdy brak lub błędny ACK z komputra
DEFTABE PRs0B ` +177tkt nadaj rozkaz
DEFTABE PRs0C ` +189tkt nadaj bajt długości do PCta
DEFTABE PRs0D ` +377tkt jeśli to obszar to nadaj bajt adresu (już jako treść) <--
DEFTABE PRs0E ` +271tkt nadaj Hbajt adresu (już jako treść)
DEFTABE PRs0F ` +189tkt nadaj bajt długości (już jako treść)
DEFTABE PRs10 ` +260tkt nadaj treść właściwą bufora i obszaru
DEFTABE PRs11 ` +189tkt nadaj XOR autosumy wiersza
DEFTABE PRs12 ` +249tkt odbierz #1F, ACK
DEFTABE PRs13 ` +247tkt odbierz #7F (ACK)
DEFTABE PRs14 ` +247tkt odbierz XOR od ACK
DEFTABE PRs15 `  +92tkt tutaj albo Time error albo błędny ACK
DEFTABE PRs16 ` +108tkt tutaj po nadaniu i odebraniu potwierdzenia
`--------------------------------
`
DEFETYK @tab01 `
DEFBAJT1 #00 #80 `LH adr stąd \dla #01 (free)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #B9 #8E `LH adr stąd \dla #02 (Żądanie tekstu opisu miejsca alarmu)
DEFBAJT1 #40     ` A l.bajtów /
DEFBAJT1 #57 #85 `LH adr stąd \dla #03 (Żądanie przez PC godziny meldunku dobowego)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #30 #85 `LH adr stąd \dla #04 (Żądanie przez PC numeru własnego)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #5A #85 `LH adr stąd \dla #05 (Żądanie wyznaczonych nr dla alarmu/inf/specj)
DEFBAJT1 #04     ` A l.bajtów /
DEFBAJT1 #18 #85 `LH adr stąd \dla #06 (Żądanie siatek LOG/informacja/alarm MISC)
DEFBAJT1 #18     ` A l.bajtów /
DEFBAJT1 #59 #85 `LH adr stąd \dla #07 (Żądanie bajtu profilu informacja/alarm)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #80 #85 `LH adr stąd \dla #08 (Żądanie jawnego tel. #00)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #8B #85 `LH adr stąd \dla #09 (Żądanie jawnego tel. #01)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #96 #85 `LH adr stąd \dla #0A (Żądanie jawnego tel. #02)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #A1 #85 `LH adr stąd \dla #0B (Żądanie jawnego tel. #03)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #AC #85 `LH adr stąd \dla #0C (Żądanie jawnego tel. #04)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #B7 #85 `LH adr stąd \dla #0D (Żądanie jawnego tel. #05)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #C2 #85 `LH adr stąd \dla #0E (Żądanie jawnego tel. #06)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #CD #85 `LH adr stąd \dla #0F (Żądanie jawnego tel. #07)
DEFBAJT1 #0B     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #10 (Żądanie bajtów konfiguracji RAM1)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #11 (Żądanie bajtów konfiguracji RAM2)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #12 (Żądanie bajtów konfiguracji RAM3)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #13 (Żądanie bajtów konfiguracji RAM4)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #14 (Żądanie bajtów konfiguracji RAM5)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #15 (Żądanie bajtów konfiguracji RAM6)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #16 (Żądanie bajtów konfiguracji RAM7)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #00 #00 `LH adr stąd \dla #17 (Żądanie bajtów konfiguracji RAM8)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #0A #85 `LH adr stąd \dla #18 (Żądanie prefixu domyślnego)
DEFBAJT1 #05     ` A l.bajtów /
DEFBAJT1 #5E #85 `LH adr stąd \dla #19 (Żądanie centrum SMS)
DEFBAJT1 #0C     ` A l.bajtów /
DEFBAJT1 #79 #00 `LH adr stąd \dla #1A (Żądanie ID EPROMu)
DEFBAJT1 #04     ` A l.bajtów /
DEFBAJT1 #58 #85 `LH adr stąd \dla #1B (Żądanie odczytu opcji SMSa specjalnego)
DEFBAJT1 #01     ` A l.bajtów /
DEFBAJT1 #59 #80 `LH adr stąd \dla #1C (Żądanie danych telefonu i GSM)
DEFBAJT1 #21     ` A l.bajtów /
DEFBAJT1 #11 #85 `LH adr stąd \dla #1D (Żądanie liczby wysłanych SMS duży/mały)
DEFBAJT1 #07     ` A l.bajtów /
DEFBAJT1 #F3 #8F `LH adr stąd \dla #1E (Żądanie nagłówka LOGu)
DEFBAJT1 #0D     ` A l.bajtów /
`---                           
DEFETYK @tab31 `
DEFTABE Roz31  ` +184tkt (Polecenie z PC  zadzwonienia na TPSA)
DEFTABE Roz32  `  +48tkt (Skasowanie znacznika zdarzenia error sprzętowy)
DEFTABE Roz33  ` +348tkt (Żądanie treści LOGu/MEMORY)
DEFTABE Roz34  ` +264tkt (Odczyt daty i czasu)
DEFTABE Roz35  ` +438tkt (Zapis daty i czasu)  <--------
DEFTABE Roz36  ` +167tkt (Zapis treści MEMORY)
DEFTABE Roz37  ` +tkt (zerowanie całkowite LOGu)
`---                           
DEFETYK @tab41 `
DEFBAJT1 #F7 #8F `LH adr. tutaj \dla #41 (Zapis wskaźnika 'DO_ODCZYTANIA')
DEFBAJT1 #02     ` A l.bajtów   /
DEFTABE Roz41    ` (#41)
DEFBAJT1 #B9 #8E `LH adr. tutaj \dla #42 (Zapis tekstu opisu miejsca alarmu)
DEFBAJT1 #3F     ` A l.bajtów   /
DEFTABE Roz42    ` (#42)
DEFBAJT1 #57 #85 `LH adr. tutaj \dla #43 (Zapis przez PC godziny meldunku dobowego)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz43    ` (#43)
DEFBAJT1 #30 #85 `LH adr. tutaj \dla #44 (Zapis przez PC numeru własnego)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz44    ` (#44)
DEFBAJT1 #5A #85 `LH adr. tutaj \dla #45 (Zapis wyznaczonych nr dla alarmu/inf/specj)
DEFBAJT1 #04     ` A l.bajtów   /
DEFTABE Roz__    ` (#45)
DEFBAJT1 #18 #85 `LH adr. tutaj \dla #46 (Zapis siatek LOG/informacja/alarm MISC)
DEFBAJT1 #18     ` A l.bajtów   /
DEFTABE Roz__    ` (#46)
DEFBAJT1 #59 #85 `LH adr. tutaj \dla #47 (Zapis bajtu profilu informacja/alarm)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz47    ` (#47)
DEFBAJT1 #80 #85 `LH adr. tutaj \dla #48 (Zapis jawnego tel. #00)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#48)
DEFBAJT1 #8B #85 `LH adr. tutaj \dla #49 (Zapis jawnego tel. #01)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#49)
DEFBAJT1 #96 #85 `LH adr. tutaj \dla #4A (Zapis jawnego tel. #02)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4A)
DEFBAJT1 #A1 #85 `LH adr. tutaj \dla #4B (Zapis jawnego tel. #03)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4B)
DEFBAJT1 #AC #85 `LH adr. tutaj \dla #4C (Zapis jawnego tel. #04)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4C)
DEFBAJT1 #B7 #85 `LH adr. tutaj \dla #4D (Zapis jawnego tel. #05)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4D)
DEFBAJT1 #C2 #85 `LH adr. tutaj \dla #4E (Zapis jawnego tel. #06)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4E)
DEFBAJT1 #CD #85 `LH adr. tutaj \dla #4F (Zapis jawnego tel. #07)
DEFBAJT1 #0B     ` A l.bajtów   /
DEFTABE Roz48    ` (#4F)
DEFBAJT1 #8D #F8 `LH adr. tutaj \dla #50 (Zapis konfiguracji RAM1)
DEFBAJT1 #03     ` A l.bajtów   /  `#F88D
DEFTABE Roz50    ` (#50)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #51 (Zapis konfiguracji RAM2)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz51    ` (#51)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #52 (Zapis konfiguracji RAM3)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz52    ` (#52)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #53 (Zapis konfiguracji RAM4)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz53    ` (#53)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #54 (Zapis konfiguracji RAM5)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz54    ` (#54)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #55 (Zapis konfiguracji RAM6)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz55    ` (#55)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #56 (Zapis konfiguracji RAM7)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz56    ` (#56)
DEFBAJT1 #00 #00 `LH adr. tutaj \dla #57 (Zapis konfiguracji RAM8)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz57    ` (#57)
DEFBAJT1 #0A #85 `LH adr. tutaj \dla #58 (Zapis prefixu domyślnego)
DEFBAJT1 #05     ` A l.bajtów   /
DEFTABE Roz58    ` (#58)
DEFBAJT1 #5E #85 `LH adr. tutaj \dla #59 (Zapis centrum SMS)
DEFBAJT1 #0C     ` A l.bajtów   /
DEFTABE Roz59    ` (#59)
DEFBAJT1 #07 #8E `LH adr. tutaj \dla #5A (Zapis reklamy z PC)
DEFBAJT1 #7A     ` A l.bajtów   /
DEFTABE Roz5A    ` (#5A)
DEFBAJT1 #58 #85 `LH adr. tutaj \dla #5B (Zapis opcji SMSa specjalnego)
DEFBAJT1 #01     ` A l.bajtów   /
DEFTABE Roz__    ` (#5B)
`------------------------------------
`
DEFETYK @PigBr `BiqBrotherHome v0.99 ID:
DEFBAJT1 #42 #69 #71 #53 #69 #73 #74 #65 
DEFBAJT1 #72 #48 #6F #6D #65 #20 #76 
DEFBAJT1 #30 #2E #39 #39 #20 #00
DEFETYK @PB_ID `'ID:'
DEFBAJT1 #49 #44 #3A #00
`DEFETYK @PigBr `BiqBrotherHome v0.99 ID:
`DEFBAJT1 #42 #69 #71 #42 #72 #6F #74 #68 
`DEFBAJT1 #65 #72 #48 #6F #6D #65 #20 #76 
`DEFBAJT1 #30 #2E #39 #39 #20 #49 #44 #3A 
`DEFBAJT1 #00
`DEFETYK @PigBr `"bIQb v0.99 #"
`DEFBAJT1 #62 #49 #51 #62 #20 #76 #30 #2E
`DEFBAJT1 #39 #39 #20 #00
`DEFETYK @PigBr `PigBrother v0.99 ID:
`DEFBAJT1 #54 #6F #6F #74 #61 #6C #49 #20
`DEFBAJT1 #76 #20 #30 #2E #39 #39 #00
`DEFETYK @PigBr `PigBrother v0.99 ID:
`DEFBAJT1 #50 #69 #67 #42 #72 #6F #74 #68 
`DEFBAJT1 #65 #72 #20 #76 #20 #30 #2E #39 
`DEFBAJT1 #39 #20 #49 #44 #3A #00
DEFETYK @NoTim      
DEFBAJT1 #2D #6E #69 #65 #7A #6E #61 #6E #79 #2D ` "-nieznany-"
DEFETYK @_???_ ` tekst ???
DEFBAJT1 #3F #3F #3F #3A #20 #00
DEFETYK @rozka                             
DEFBAJT1 #09 `-wszystkich słów kluczowych  
DEFETYK @sms_1
DEFBAJT1 #46 #4F #4E #49 #43 #5A #4E #59     
DEFBAJT1 #2D #41 #4C #41 #52 #4D #2D #4E     
DEFBAJT1 #41 #00                          `#01 FONICZNY_ALARM_NA 
DEFETYK @sms_2
DEFBAJT1 #53 #4D #53 #2D #53 #50 #45 #43     
DEFBAJT1 #4A #41 #4C #4E #59 #2D #4E #41     
DEFBAJT1 #00                              `#02 SMS_SPECJALNY_NA 
DEFETYK @sms_3
DEFBAJT1 #53 #4D #53 #2D #41 #4C #41 #52     
DEFBAJT1 #4D #2D #4E #41 #00              `#03 SMS_ALARM_NA 
DEFETYK @sms_4
DEFBAJT1 #53 #4D #53 #2D #49 #4E #46 #4F     
DEFBAJT1 #52 #4D #41 #43 #4A #41 #2D #4E     
DEFBAJT1 #41 #00                          `#04 SMS_INFORMACJA_NA 
DEFETYK @TELEF                             
DEFBAJT1 #54 #45 #4C #45 #46 #4F #4E #00  `#05 TELEFON 
DEFETYK @PROFI                             
DEFBAJT1 #50 #52 #4F #46 #49 #4C #00      `#06 PROFIL
DEFETYK @TEST_                             
DEFBAJT1 #54 #45 #53 #54 #00              `#07 TEST
DEFETYK @ALAR_                             
DEFBAJT1 #41 #4C #41 #52 #4D #00          `#08 ALARM
DEFBAJT1 #52 #45 #4B #4C #41 #4D #41 #00  `#09 REKLAMA
DEFETYK @zmian
DEFBAJT1 #7A #6D #69 #61 #6E #61 #20 #6E #72 #00 `zmiana nr 
DEFETYK @_z___
DEFBAJT1 #20 #7A #00 ` z 
DEFETYK @s_num
DEFBAJT1 #20 #6E #75 #6D #65 #72 #00 ` na numer 
DEFETYK @nie__
DEFBAJT1 #6E #69 #65 `nie
DEFETYK @doste
DEFBAJT1 #64 #6F #73 #74 #65 #70 #6E #79 #20 #00 `dostępny
DEFETYK @na___
DEFBAJT1 #20 #6E #61 #00
DEFETYK @proFU `tekst o ustawieniu profilu
DEFBAJT1 #20 #7A #6D #69 #65 #6E #69 #6F 
DEFBAJT1 #6E #6F #20 #70 #72 #6F #66 #69 
DEFBAJT1 #6C #20 #7A #20 #00
DEFETYK @230V_
DEFBAJT1 #32 #33 #30 #76 #00
DEFETYK @l.tel
DEFBAJT1 #6C #69 #6E #2E #74 #65 #6C #2E #00
DEFETYK @br_al
DEFBAJT1 #6C #69 #6E #2E #61 #6C #61 #72 #6D #00
DEFETYK @_gsm_
DEFBAJT1 #70 #6F #7A #69 #6F #6D #20 #47 #53 #4D #00 
DEFETYK @ok___
DEFBAJT1 #6F #6B #2C #00
DEFETYK @on___
DEFBAJT1 #7A #61 #6C #2C #00
DEFETYK @off__
DEFBAJT1 #77 #79 #6C #2C #00
DEFETYK @połąc
DEFBAJT1 #50 #6F #6C #61 #63 #7A #65 #6E `'Połączenie przychodzące na GSM: '
DEFBAJT1 #69 #65 #20 #70 #72 #7A #79 #63
DEFBAJT1 #68 #6F #64 #7A #61 #63 #65 #20
DEFBAJT1 #6E #61 #20 #47 #53 #4D #3A #00
DEFETYK @>99go 
DEFBAJT1 #3E #39 #39 #67 #6F #64 #7A #00 `>99godz
DEFETYK @werbu `tekst próbnej reklamy do RAM
DEFBAJT1 #20
DEFBAJT1 #62 #79 #20 #69 #6B #53 #20 #68 `-> #22 -> 
DEFBAJT1 #74 #74 #70 #3A #2F #2F         `-> #4A 
DEFBAJT1 #77 #77 #77 #2E #6D #6F #6A #61 `-> #50 
DEFBAJT1 #65 #6C #65 #6B #74 #72 #6F #6E `-> #00 
DEFBAJT1 #69 #6B #61 #2E #61 #73 #2E #70 `-> #01 
DEFBAJT1 #6C #00                         `-> #6C 
`----------------------------------
`
LD BC,#50C1                @dalll `
`  zerowanie 8251A dla PC           
SUB A                             `
OUT (C),A                         `
OUT (C),A                         `
OUT (C),A                         `
LD A,#40                          `
` w słowie rozkazu 6 bit = 1 to RESET
OUT (C),A                         `
LD A,#4E                          `
` słowo trybu pracy dla asynchronicznej:
`       ---------------------------------
`       | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
`       ---------------------------------
`      bit7, bit6                  
`         0   1   --> 1 bit stopu  
`      bit5=0 --> kontrola nieparzystości
`      bit4=0 --> kontrola (nie)parzystości włączona /przy nadawaniu!/
`      bit3, bit2                  
`         1   1   --> 8 bitów      
`      bit1, bit0                   
`         1   0   --> podział TxC i RxC przez 16
OUT (C),A                         `
DEC C                             `
IN A,(C)                          `
IN A,(C)                          `
INC C                             `
LD A,#07                          `
`   słowo rozkazu ma bity o następującym znaczeniu:
`             bit    0 -TxEn =1 nadawanie dozwolone
`             bit   1  -DTR  =1 linia wyj.DTR w stanie niskim -aktywnym
`             bit  2   -RxEn =1 odbiór dozwolony
`             bit 3    -SBRK =0 linia TxD pracuje normalnie
`      bit    4        -ER   =0 wyzerowanie wskaźników PE, OE i FE w słowie stanu
`      bit   5         -RTS  =0 linia wyj.RTS w stanie niskim -aktywnym
`      bit  6          -IR   =0 nic
`      bit 7           -EH   =0 nic
OUT (C),A                         `
`          zerowanie obszaru VRAM:          
LD HL,#801C                      `wyczyść pamięć RAM (też pauze)
LD E,L                           `
LD D,H                           `teraz to nie ma sensu...
INC DE                           `
LD (HL),#00                      `
LD BC,#02AD                      `do #82C9 włącznie
LDIR                             `
LD HL,#80AD                      `\redLED ->
`************** SET 6,(HL)                       ` |         zła autosuma EPROM
NOP `    tymczasowo, aby autosuma nie blokowała wysyłania SMSów
NOP                              `
`***********************************************************
SET 3,(HL)                       `/          brak konfigu na SIM
LD HL,(#8ACC)                    `stoper blokady wysyłania tajnych/pajnych
LD DE,#0258                      ` =&10minut w sekundach
SBC HL,DE                        `
JR C,@nieSK                      `hop -> nie skracaj bo mniej niż 10 minut
LD (#8ACC),DE                    `skróć do 10 minut
LD HL,#84EE               @nieSK `wyczyść pamięć RAM (też pauze)
LD E,L                           `
LD D,H                           `
INC DE                           `
LD (HL),#00                      `
LD BC,#007B                      `do #8569 włącznie
LDIR                             `
`od #85D8 \zeruj                  
`do #88E4 /                       
LD HL,#85D8                      `wyczyść pamięć RAM (też pauze)
LD E,L                           `
LD D,H                           `
INC DE                           `
LD (HL),#00                      `
LD BC,#030C                      `do #88E4 włącznie
LDIR                             `
`                                 
CALL @wsad+                      `wywołaj zeroustawianie dodatkowych bloków (innych niż kernel)
`                                 
`LD A,#03                         `\zaczniemy od nadania ramki rejestracyjnej
`LD (#802B),A                     `/   próbowałem dla przyspieszenia po RESET
`                                 
CALL @RLoRa                      `reset RAM LOGu
LD HL,(#8FFD)                    `\po RESET nie analizuj zdarzeń przeszłych
LD (#8FF9),HL                    `/które są w LOGU, dopiero te co będą...
`#8FF9- 2b -adr. pierwszego bajtu za ostatnim zrealizowanym zdarzeniem
`                używany tylko przez CPU w czasie realizacji zdarzeń,
`                zerowany gdy RESET i syf, ew. przesuwany za zdarzenie po jego realizacji
`#8FFD- 2b -[WOLNY] adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
LD BC,#0900                      `zdarzenie RESET, kodID = #00
CALL @_PZD_                      `zapisz RESET do logu
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres miesiąca
JR NC,@noREz                     `hop -> nie zapisano do LOGu
INC HL                           `\
LD A,(#8009)                     ` |dopisz ROK do daty zdarzenia
`#8009 -> lata (#00 = 2000r)     ` |
LD (HL),A                        `/

SUB A                     @noREz `\ poniższe dla obliczania autosumy EPROM
LD (#80BD),A                     `/
DEC A                            `\stoper reklamy na maxa
LD (#87F6),A                     `/

LD HL,#0000                      `\
LD (#80C2),HL                    `/zeruj adres autosumy EPROM
`#80C2 - 2b- adres dynamiczny liczonej autosumy EPROM
`#80BD - 1b- liczona dynamicznie autosuma 

LD A,#00 `LD A,#00,FF            `\tryb pracy drugiej linijki LCD
` #00 => normalny                 
` #FF => wyłączona                
LD (#86E9),A                     `/ ****************************_+_+_+_+_+_+_+_+_+_+_+

LD HL,#8F00                      `adres VRAM
LD E,L                           `\
LD D,H                           `/przepisz do DE
INC DE                           `następny
LD BC,#002F                      `długość obszaru o 1 mniejsza
LD (HL),#20                      `kod spacji
LDIR                             `
CALL @R_AcR                      `reset 8255 dla LCD
CALL @reSLN                      `RESET LCD
`                                 
LD HL,#0000                      `
`#80B4 -2b licznik sekundowy =#0000 lub 15bit=1 to stoi, 
`                     else idzie ->licznik pozytywnego poziomu GSM
`#80B6 -3b licznik sek/min/godz braku poziomu GSM, stoi gdy 7bit sek =1 else idzie
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i przedstawiania się na LCD
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
`#80BA -3b czas najdłuższego braku sygnału GSM, sek/min/godz
LD (#80B4),HL                    `zeruj czas trwania zasięgu GSM
LD (#80B6),HL                    `
LD (#80B8),HL                    `
LD (#80BA),HL                    `
LD (#80BB),HL                    `
CALL @resSM                      `--- zerowanie SMSów
CALL @resRD                      `po RESET zeruj ICF,ICR,MC,RSL !
CALL @TwCO0                      `ustal zerowy konfig dodaj tworzenie siatek...
CALL @MkSAI                      `odświerz adresy siatek LOG, alarm, informacja
LD HL,#86F4                      `
LD (HL),#00                      `dozwolona zmiana czasu i nie było jeszcze
INC HL                           `
SUB A                            `=#00
LD (HL),A                        `poprawka godziny =#00
CALL @verTI                      `veryfikuj czas z RAM
`     wyjście (NC) =dobry czas, (CY)= zły czas
CALL C,@resKT                    `--- zeruj książkę telefoniczną, bo syf w RAM
CALL @TELch                      `czy poprawne numery w całej książce tel?
`                                 jeśli nie poprawne to ją wyczyść
`    veryfikuj wieczny zegar         
CALL @chkWZ                      `
JR Z,@a$Tok                      `hop -> autosuma poprawna!
LD HL,#8DF9                      `
LD DE,#8E00                      `
LD BC,#0007                      `
LDIR                             `
CALL @chkWZ                      `
JR Z,@a$Tok                      `hop -> autosuma poprawna!
LD HL,#0000                      `\
LD (#8E00),HL                    ` \
LD (#8E02),HL                    ` /zeruj wieczny zegar
LD (#8E04),HL                    `/
NOP                       @a$Tok `
`SUB A                           `
`LD (#802E),A                    `blokuj `zeruj DKrok
`SUB A                           `Acc (juz jest) =#00
`LD (#8081),A                    `licznik żądań SMSa konfigu &08/09
`LD HL,#1000                     `czas określenia ostatniej LAC/CID /tutaj 16 minut/
`LD (#804C),HL                   `zeruj go
`SUB A                           `=0 => &256minut
`LD (#807D),A                    `czas (minuty) do zapisu konfigów
`                                 
LD A,(#8000)                     `
OR #80                           `ustawienia początkowe innych bitów można wybrać dowolne...
LD (#8000),A                     `odblokuj NMI
`                                 musi być po reset LCD i zapisaniu znaków itd...
` poczekajmy aż: 1. będzie zasięg
`                2. będzie przeczytana cała książka telefoniczna
`                3. Dkrok będzie neutralny (#FF)
`   1.będzie zasięg przez 10 sek.   
`LD A,(#80B9)              `@wtGLE `
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
`BIT 7,A                          `
`JR Z,@wtGLE                      `hop -> czekaj na pozytywny poziom GSM
LD HL,(#80B4)             @wtGLE `
LD A,H                           `
AND A                            `
JR NZ,@wtKST                     `hop -> długo jest zasięg
LD A,L                           `
CP #10                           `było #0A, zrobiłem #10 sekund wymaganego zasięgu
JR C,@wtGLE                      `
`   2. będzie przeczytana cała książka telefoniczna
`#807F -> 1b oznaczający kolejne #00-#08 przeszukiwane pozycje ks. tel SIM zawierające znane numery
`                 lub >#08 -przełącz, aby przeszukiwać teraz całą książkę (znane już przeszukane)
`                     #FE  -gdy szukaj kolejnego w ks. telefonicznej
`                     #FF  -gdy wszystkie przeszukane
` |odczyt książki telefonicznej wygląda tak: najpierw #807F =#00..#09 to spr. poz znane
` |                                          później  #807F =#FE to sprawdzamy cała ks tel
` |                               według #807E #00..#7F, a później #807F =#80
` |                                       a #807F =#FF i to oznacza przeszukanie całej książki
LD A,(#807F)              @wtKST `
INC A                            `
JR NZ,@wtKST                     `hop -> czekaj na przeczytanie całej książki telef
`   3. Dkrok będzie neutralny (#FF)
`#802E -> 1b DKROK, oznaczający:
`          #FF -nic nie rób w tej kwestii (normalna praca mbusa)
LD A,(#802E)              @wtDKr `
INC A                            `
JR NZ,@wtDKr                     `hop -> czekaj na nuetralny DKrok
CALL @bijTI               @DaleJ `kolejny niezależny wątek programowy
CALL @DzZda                      `czy jest nowe zdarzenie w Dzienniku Zdarzeń?
LD A,(#8000)                     `\czy aktualna ASCII dataczas?
BIT 0,A                          `/
JR NZ,@DaleJ                     `hop -> nieaktualny czas
CALL @SMSsp                      `czy wysłać SMSa specjalnego?
CALL @InSMS                      `a tutaj coś, np sprawdzanie czy przybył SMS sterujący...
CALL @InRIN                      `a tutaj sprawdzenie czy poł. przychodzące na GSM...
JR @DaleJ                        `
`----------------------------------
`
`sprawdza czas w RAM, jeśli zły to zeruje, jeśli dobry zostawia
`trwa poza NMI                    
`wyjście (NC) =dobry czas, (CY)= zły czas
`LD A,#FF                 `@verTI `
`LD (#86F3),A                    `odwrotna polaryzacja sygnału DCF77
`LD A,#00                        ` -> sekundy,       \
`#8004 -> sekundy,       \
`#8005 -> minuty,         \zliczane jako 
`#8006 -> godziny,        /czas rzeczywisty...
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`LD (#8004),A                    `
`LD A,#3A                        ` -> minuty,         \zliczane jako 
`LD (#8005),A                    `
`LD A,#02                        ` -> godziny,        /czas rzeczywisty...
`LD (#8006),A                    `
`LD A,#1B                        ` -> dni miesiąca   [#00 - #1E] /#00 to 1, #1B TO 28, #1E to &31/
`LD (#8007),A                    `
`LD A,#09                        ` -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`LD (#8008),A                    `
`LD A,#07                        ` -> lata (#00 = 2000r)
`LD (#8009),A                    `
`LD A,#06                        ` -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`LD (#800A),A                    `
LD HL,#8004               @verTI `adr. sekund
LD A,(HL)                        `sekundy
CP #3C                           `
JR NC,@zlyTi                     `hop -> zły czas startowy
INC HL                           `
LD A,(HL)                        `minuty
CP #3C                           `
JR NC,@zlyTi                     `hop -> zły czas startowy
INC HL                           `
LD A,(HL)                        `godziny
CP #18                           `
JR NC,@zlyTi                     `hop -> zły czas startowy
INC HL                           `
LD D,(HL)                        `dni miesiąca
INC HL                           `
LD A,(HL)                        `miesiąc
CP #0C                           `(#00-#0B)
JR NC,@zlyTi                     `hop -> zły czas startowy
LD B,A                           `miesiąc
INC HL                           `
LD E,(HL)                        `lata
INC HL                           `
PUSH HL                          `HL=adres dni tygodnia
PUSH BC                          `B=miesiąc
CALL @DmArE                      `w Acc wychodzi liczba dni w miesiącu A roku E /nie zmienia DE/
POP BC                           `B=miesiąc
POP HL                           `HL=adres dni tygodnia
SUB C                            `max - sprawdzana
JR C,@zlyTi                      `hop -> zły czas startowy
LD A,E                           `rok/lata
CP #05                           `lata sprawdzamy czy <2005, jeśli mniejsze to jako nieustawiony
JR C,@zlyTi                      `hop -> rok<2005 =nieustawiony
PUSH HL                          `HL=adres dni tygodnia
LD H,B                           `miesiąc
LD L,E                           `rok
`                                 D=dzień miesiąca
CALL @jakDT                      `w Acc wychodzi dzień tygodnia roku L (#00 to 2000r)
`                                 z miesiąca H (#00=styczeń) i dnia D (#00 to 1 'pierwszy')
POP HL                           `HL=adres dni tygodnia
LD B,(HL)                        `dzień tygodnia
CP B                             `czy identyczny z obliczonym?
JR NZ,@zlyTi                     `hop -> dzień tygodnia różny
`    tutaj mamy poprawny czas w systemie, przechowany w RAM bateryjnym
LD A,#01                         `StatusTime =ustawiony z RAM lub konfigu 
LD (#8001),A                     `/czyli nieaktualny, ale nie uwsteczniaj/
SUB A                            `+00h poprawki godzin przy ich przeskoku
LD (#86F5),A                     `
RET                              `(NC) dobry czas, wyjdź
LD HL,#8001               @zlyTi `wyczyść czas i TimeStatus
LD E,L                           `
LD D,H                           `
INC DE                           `
LD (HL),#00                      `
LD BC,#0009                      `czyli wyzeruj obszar liczników daty/czasu 
LDIR                             `i status Time =nieustawiony
SCF                              `
RET                              `(C) zły czas
`-------------------------------------------
`
`tworzenie zawartości konfigu zerowego
`trwa poza NMI
LD HL,#070A                @TwCO0 `utwórz konfig zerowy /poza NMI/
`!`#850F ->1b skonfigurowany max czas w minutach, powyżej którego Z80 żąda sieci,LAC/CID
`!`#8510 ->1b dzień tygodnia [0..6] wysłania ostatniego meldunu dobowego
LD (#850F),HL                     `
LD A,#0F                          `\zeruj datę abonamentową -> nieznana!
LD (#8555),A                      `/
LD HL,@_wCO3                      `utwórz konfig zerowy /poza NMI/
LD DE,#8557                       `prześlij do configu /bo bez poz na SIM ;o) /
LD BC,#002A                       `7+&35 =&7+&12+11+11+1
LDIR                              `
` teraz rozkodujemy to co przepisano z EPROM:
LD DE,#855E                       `
LD HL,@kode3                      `aby nie na przełomie!
CALL @dkdN_                       `
`obszar IIIb : #856D..#858B [#8263..#8271] &15 -> #0F
`trwa +675tkt                   -> +1001tkt !!!!!
LD DE,#856D                       `
LD HL,@kode4                      `aby nie na przełomie!
CALL @dkdN_                       `
`obszar IIIc : #857C..#858A [#8272..#8280] &15 -> #0F
`trwa +663tkt                      
LD DE,#857C                       `
LD HL,@kode5                      `aby nie na przełomie!
CALL @dkdN_                       `
LD A,#01                          `\
LD HL,#855B                       ` \informacja SMS na numer jawny0
LD (HL),A                         `  \
`!`#855B -1b numeru na które wysyłamy SMSspecjalny (jak w niżej)
INC HL                            `    \
LD (HL),A                         `    /
`!`#855C -1b numery na które wysyłamy ALARM SMSem bit0 to 0 użytkownika, =1 to wysyłamy
INC HL                            `  /
LD (HL),A                         ` /
`!`#855D -1b numery na które wysyłamy INFORMACJĘ SMSem j.w.    
RET                               `
`----------------------------------
`                               
`data i czas rzeczywisty do przodu, komórka cykliczna do przodu
`delay key NOKIA do przodu       
`trwa max. +2129tkt                +48+2081tkt (dla @_tme0)
`           na @time+ mamy max 2697tkt
LD HL,#8002             @time+ `teraz przesuń cykliczną i zegar
`#8002 -> komórka cykliczna (zmienia swą wartość z szybkością przerwań)
INC (HL)                       `tutaj zwiększa komórkę cykliczną
LD A,(HL)                      `
INC L                          `
AND #03                        `
` minęło 38tkt                 `
JP Z,@_tme0                    `hop ->analiza brąz linii, DCF77, 230V, TPSA,mamy max 2644tkt
`                               @_tme0 trwa max +2081tkt (dla @TPSA_)
DEC A                          `
` minęło 52tkt                 `
JP Z,@_tme1                    `hop ->max +2054tkt 
DEC A                          `
` minęło 66tkt                 `
JP Z,@_tme2                    `hop ->free
` minęło 76tkt                 `
INC (HL)                       `zwiększ ułamek sekund
`#8003 -> ułamki sekund zliczane co czwarte przerwanie, modulo &250 (#FA)
LD A,(HL)                      `
CP #FA                         `
JP NC,@_tme+                   `hop -> zmiana czasu, bo przeskok ułamka sekund /+486tkt/
` minęło 111tkt                `
AND #1F                        `
` a po AND #1F : #0A - #15 -> 8 razy w sekundzie
SUB #0A                        `
JP Z,@NkKey `obsługa przycisków NOKIA -8razy w sekundzie /+279tkt/
` minęło 135tkt                `
LD A,(HL)                      `ułamek sekund
CP #F9                         `tylko końcówka sekundy
RET NZ                         `wyjdź gdy nie końcówka
` jeszcze +144tkt
` tutaj ociupinkę przed przeskokiem sekundy 
LD HL,#8004                    `adr. sekund
LD A,(HL)                      `
AND A                          `
RET NZ                         `
` tutaj ociupinkę przed przeskokiem 1 sekundy po przeskoku minut
INC HL                         `adr. minut
LD A,(HL)                      `
AND A                          `
RET NZ                         `
` tutaj ociupinkę przed przeskokiem 1 sekundy po przeskoku godzin
`   tu przeskok godzin-> cyknij stoperek pogarszacza czasu
LD DE,#809E                    `adr.stoperek pogarszacza czasu
LD A,(DE)                      `stoperek pogarszacza czasu
AND A                          `
RET Z                          `
DEC A                          `
LD (DE),A                      `stoperek pogarszacza czasu
RET NZ                         `
LD DE,#8001                    `adr.StatusTime
LD A,(DE)                      `StatusTime
CP #04                         `
RET C                          `już pogorszony
LD A,#03                       `=ustawiony ale dawno
LD (DE),A                      `StatusTime =ustawiony ale dawno
RET                            `
`------------------------------
`
` obsługa pod znakiem zapytania, ponieważ umiem już odkładać słuchawkę mbusem 
` więc pewnie też da się odbierać rozmowę i ją kończyć mbusem                 
`obsługa przycisków OK i C
`                                            #xx : 7 6 5 4 3 2 1 0
`   wciśnięcie samego OK na krótko:          #84 : 1 0 x 0 x 1 0 0
`   wciśnięcie samego OK na długo :          #94 : 1 0 x 1 x 1 0 0
`   wciśnięcie samego C na krótko:           #80 : 1 0 x 0 x 0 0 0
`   wciśnięcie samego C na długo :           #90 : 1 0 x 1 x 0 0 0
`   wc. C, i OK na krótko z krótką przerwą : #C8 : 1 1 0 0 1 0 0 0
`   wc. C, i OK na krótko z długą przerwą :  #E8 : 1 1 1 0 1 0 0 0
`   wc. C, i OK na długo z krótką przerwą :  #D8 : 1 1 0 1 1 0 0 0
`   wc. C, i OK na długo z długą przerwą :   #F8 : 1 1 1 1 1 0 0 0
`   wc. OK, i C na krótko z krótką przerwą : #C4 : 1 1 0 0 0 1 0 0
`   wc. OK, i C na krótko z długą przerwą :  #E4 : 1 1 1 0 0 1 0 0
`   wc. OK, i C na długo z krótką przerwą :  #D4 : 1 1 0 1 0 1 0 0
`   wc. OK, i C na długo z długą przerwą :   #F4 : 1 1 1 1 0 1 0 0
`   wc. 2* OK na krótko z krótką przerwą :   #CC : 1 1 0 0 1 1 0 0
`   wc. 2* OK na krótko z długą przerwą :    #EC : 1 1 1 0 1 1 0 0
`   wc. 2* OK na długo z krótką przerwą :    #DC : 1 1 0 1 1 1 0 0
`   wc. 2* OK na długo z długą przerwą :     #FC : 1 1 1 1 1 1 0 0
`   wc. 2* C na krótko z krótką przerwą :    #C0 : 1 1 0 0 0 0 0 0
`   wc. 2* C na krótko z długą przerwą :     #E0 : 1 1 1 0 0 0 0 0
`   wc. 2* C na długo z krótką przerwą :     #D0 : 1 1 0 1 0 0 0 0
`   wc. 2* C na długo z długą przerwą :      #F0 : 1 1 1 1 0 0 0 0
`----
`                                   
`wywoływana 8 razy w ciągu sekundy z procedury @time+, sama sobie cyka #804A
`#8049 -> 2b KEYów co zrobić: /lub co właśnie robimy/
`   #8049 1szy bajt bitami:
`         7  6  5  4  32  10  
`         0=nic           
`         1=zrób          
`            0=jeden przycisk (pierwszy)
`            1=dwa przyciski
`               0=krótka przerwa pomiędzy wciśnięciami
`               1=długa    -||-      -||-      -||- 
`                  0=krótkie przyciśnięcie
`                  1=długie   -||-   -||- 
`                     00- C   C
`                     01- C   OK (pierwszy OK)
`                     10- OK  C  (pierwszy C)
`                     11- OK  OK
`                         00=przed wciskaniem
`                         01=1szy wciśnięty
`                         10=przerwa
`                         11=2gi wciśnięty
`   #804A 2gi bajt to czas 0-7 trwania wciśnięcia lub przerwy
`
`trwa: +279tkt                 
LD HL,#8049            @NkKey `adres co robić
LD A,(HL)                     `odczytaj bajt co robić
LD E,A                        `zapamiętaj na zaś
AND #80                       `tylko 7 bit
RET Z                         `RET -> nic
LD BC,#804A                   `adres timea
LD A,E                        `co robić
AND #03                       `tylko bity postępu
JR NZ,@noBef                  `hop -> to nie przed, -jesteśmy w trakcie
LD A,E                        `co robić
INC A                         `
LD (HL),A                     `zwiększ etap (bit01) co robić
LD A,E                        `co robić
BIT 4,A                       `0=krótkie/1=długie przyciśnięcie
LD A,#03                      `czas dla krótkiego
JR Z,@ANUIO                   `
LD A,#08                      `czas dla długiego
LD (BC),A              @ANUIO `ustaw czas trwania wciśnięcia keya
LD A,E                        `co robić
BIT 2,A                       `który przycisk pierwszy OK (=1) czy C (=0)
LD A,#B0               @macha `maska wciśniętego OK i wyciśniętego OnOff
` bitD7=1 to OnOff nie wciśnięte
` bitD6=0 to C     nie wciśnięte
` bitD5=1 to OK    wciśnięte  
` bitD4=1 to fala to podtrzymanie zasilania systemu
` bityD0-3 bez znaczenia       
JR NZ,@ANUI2                  `
LD A,#D0                      `maska wciśniętego C  i wyciśniętego OnOff
` bitD7=1 to OnOff nie wciśnięte
` bitD6=1 to C     wciśnięte   
` bitD5=0 to OK    nie wciśnięte
` bitD4=1 to fala to podtrzymanie zasilania systemu
` bityD0-3 bez znaczenia       
LD BC,#5081            @ANUI2 `ustaw maskę
LD (#80C4),A                  `maska dla klawiszy NOKIA
`#80C4 - 1b maska dla klawiszy NOKIA, umożliwiająca generację lub zakończenie generacji
`           fali prostokątnej podtrzymującej zasilanie autkowego
OUT (C),A                     `
RET                           `
DEC A                  @noBef `tu gdy nie przed, sprawdzimy więc gdzie
JR NZ,@noFir                  `hop -> to nie w czasie wciskania pierwszego
LD A,(BC)                     `jaki czas
AND #0F                       `zabezpieczenie, max czas to #0F
DEC A                         `cyknij czas
LD (BC),A                     `zapisz
RET NZ                        `wyjdź gdy jeszcze trwa
LD A,E                        `
BIT 6,A                       `
JR Z,@OnOne                   `hop -> bo tylko jeden przycisk
INC A                         `
LD (HL),A                     `zwiększ etap (bit01) co robić
BIT 5,A                       `0=krótka/1=długa przerwa
LD A,#03                      `czas dla krótkiej
JR Z,@ANUI3                   `
LD A,#0A                      `czas dla długiej
LD (BC),A              @ANUI3 `ustaw czas trwania przerwy
LD BC,#5081            @ncNiW `nic nie wciśnięte
LD A,#90                      `ustal maskę
` bitD7=1 to OnOff nie wciśnięte
` bitD6=0 to C     nie wciśnięte
` bitD5=0 to OK    nie wciśnięte
` bitD4=1 to fala to podtrzymanie zasilania systemu
` bityD0-3 bez znaczenia      
LD (#80C4),A                  `maska dla klawiszy NOKIA
OUT (C),A                     `
RET                           `
DEC A                  @noFir `tu gdy nie pierwszy, sprawdzimy więc co...
JR NZ,@noPau                  `hop -> to nie przerwa
LD A,(BC)                     `jaki czas
AND #0F                       `zabezpieczenie, max czas to #0F
DEC A                         `cyknij czas
LD (BC),A                     `zapisz
RET NZ                        `wyjdź gdy jeszcze trwa
LD A,E                        `odtwórz co było,
INC A                         `kolejny etap
LD (HL),A                     `zwiększ etap (bit01) co robić
BIT 4,A                       `0=krótkie/1=długie przyciśnięcie
LD A,#03                      `czas dla krótkiego
JR Z,@ANUI4                   `
LD A,#08                      `czas dla długiego
LD (BC),A              @ANUI4 `ustaw czas trwania wciśnięcia keya
LD A,E                        `co robić
BIT 3,A                       `który przycisk drugi OK (=1) czy C (=0)
JR @macha                     `hop -> ustal maskę dla przycisku
LD A,(BC)              @noPau `to drugi przycisk
AND #0F                       `zabezpieczenie, max czas to #0F
DEC A                         `cyknij czas
LD (BC),A                     `zapisz
RET NZ                        `wyjdź gdy jeszcze trwa
SUB A                  @OnOne `tylko jeden, więc zeruj zadanie i wyjdź
LD (HL),A                     `zeruj, a więc po wszystkim
JR @ncNiW                     `hop -> nic nie wciśnięte
`------------------------------------
`
`trwa: +2081tkt max (dla @TPSA_) a mamy max 2634tkt
`   zakładamy że z @TPSA_ obetniemy jeszcze 100tkt,
`   a w chwili obecnej trwa max 
LD BC,#5040             @_tme0 `250 razy w sekundzie tu jest...
`                               obsługa testera stanu na 8255
IN A,(C)                       `odczyt portu A
LD (#80AB),A                   `zapisz, aktywne gdy =0
DEC L                          `
`#8002 -> komórka cykliczna (zmienia swą wartość z szybkością przerwań)
LD A,(HL)                      `
RRCA                           `
RRCA                           `zmienia swą wartość z każdym wywołaniem 
RRCA                           `
` +58tkt                        
JP C,@TPSA_                    `max +68+2013tkt ->hop =an. tel. stacjonarnego 125razy/sek
`                mamy max 2566tkt /tyle samo na @TPSA_/
AND #03                        `
JP Z,@analB                    `0-> hop =zamień bity z brąz linii na kod
DEC A                          `
JP Z,@Dcf77                    `1-> max.ok?1100tkt 1-> hop =analizuj pod kątem DCF
DEC A                          `
JP Z,@DorGo                    `+1912tkt 2-> hop =analizuj pod kątem drzwi/dzwonka/alarmu/usterki
` minęło +113tkt               `
CALL @ts230                    `+17+1077tkt 3-> detektor 230V
LD A,(#802D)                   `a tu zrób delay key dla nokia
AND A                          `
JR Z,@pswsw                    `hop gdy =0 -> nie decrementuj
DEC A                          `to zmiejsz
LD (#802D),A                   `zapisz delay nokia
`---
LD A,(#8003)            @pswsw `uł. sekund
`minęło +1255tkt max, mamy do 821tkt max (do @TPSA_)
` tutaj jest co 32[ms], 31 i 1/4 raza w sekundzie
RRCA                           `
RRCA                           `
RRCA                           `
DEC A                          `aby ominąć #00...
AND #1F                        `
CP #09                         `\ <-bezpiecznik
RET NC                         `/interesuje nas tylko #00..#08, raz w sekundzie
LD HL,@LTime                   `
JP @jp(hl                      `+10+54+to_co_wykonuje(max +699tkt) 
`                                            jest tu raz w sekundzie dla każdej proc.
`------------------------------------------
`
`procedura wykonywana w co czwartym przerwaniu powoduje wyrzucanie na 
`LCD znaków z pamięci VRAM (obszar ASCII dla ekranu)
`odświerzanie praktycznie 4 razy na sekundę cały ekran...
`
` ---------- komórki VRAM ----------------------------------
`#8F00 ->&48 bajtów obszaru VRAM
`     #8F00 -> pierwsza linijka &24bajtów
`     #8F18 -> druga linijka &24bajtów
` ---------- koniec komórek VRAM ---------------------------
`
`trwa +2054tkt = +1333+721 (a mamy max 2648tkt)
CALL @RS_PC             @_tme1 ` ...Call t max +721tkt (=+17+704)
LD A,(#8003)                   `
AND #3F                        `czyli 4 razy na sekundę
`#8003 -> ułamki sekund zliczane co czwarte NMI. 250 (#FA) przeskakuje na 0 (#00),
`#00 -> kursor                  
`#01-pierwsza linia znak  &1 z pola +#00
`...                             
`#18-pierwsza linia znak &24 z pola +#17
`#19 -> kursor                   
`#1A-druga linia znak  &1 z pola +#18
`...                              
`#31-druga linia ostatni znak &24 z pola +#30
`wcześniejsza instr. była AND więc wskaźniki są ustawione.
JR Z,@FirLi                    `hop -> kursor dla pierwszej linijki
CP #19                         `
JR Z,@SerLi                    `hop -> kursor dla drugiej linijki
JR C,@poDCa                    `
CP #32                         `
JR NC,@LASNC                   `RET bo z poza zakresu ekranu VRAM
DEC A                          `dla potrzeb adresu z VRAM
LD HL,#8FFF             @poDCa `/adres VRAM o 1 mniejszy!!! -no prawie/
`          H to starszy bajt adresu VRAM a L to wartość młodszego adresu VRAM minus 1
ADD A,L                        `
LD L,A                         `
LD A,(HL)                      `odczytaj bajt
CP #20                         `
JR C,@popAS                    `hop -> z poza akceptowalnego ASCII
CP #80                         `
JR C,@ASCok                    `hop -> kod ASCII akceptowalny
LD A,#20                @popAS `wpisz kod spacji
CALL @W_AcD             @ASCok `-> wypisz na LCD jako daną (trwa 139tkt)
JR @LASNC                      `
LD A,#80                @FirLi `ustaw kursor na początku pierwszej linijki
JR @DWABa                      `
LD A,#C0                @SerLi `ustaw kursor dla drugiej linijki
CALL @W_AcR             @DWABa `wypisz na LCD jako rozkaz (trwa 151tkt)
`--- blok zapisu do LCD trwa max. +294tkt 
`             ==============    
`--- teraz blok ?                  
LD A,(#8003)            @LASNC `ułamki sekund [LD A,(#8002)]
LD B,A                         `
AND #7F                        `
CP #32                         `po ostatnim znaku w drugiej linii
JP Z,@2lLCD                    `+10+979tkt hop -> utwórz 2gą linię dla LCD
CP #72                         `
JP Z,@2razS                    `hop -> analiza poziomu GSM i takich tam innych 2 razy w sek
LD A,B                         `
AND #0F                        `licznik uł. sekund, robi &250 zliczeń w sekundzie
`                               tak więc Z będzie ok. 16 razy z sekundzie
JP NZ,@%_LOG                   `+12+473tkt max jako free
` generalnie to powyżej to zapchajdziura...
`                               
`--- +79tkt tutaj +LCD oczywiście jeszcze...
JR @LED&w                      `+12+968tkt max
`---------------------------------
`
`wykonaj bit watchdoga i flash LEDy, wywoływana 16razy w sekundzie     
`trwa +968tkt max                   
`LD A,(#80AC)           @LED&w `tu bit0 to watchdog
` założenie że na bicie tym ma być fala prostokątna
` w #80AC jest to co poprzednio zostało wysłane na watchdoga i LEDy
`#80AC -> 1b z którego 4 bity 3-0 wysyłamy do portu C 8255 OUT
`               |7|6|5|4|3|2|1|0|
`                | | | |       |-> =0/1 pobudzanie watchdoga
`                | | | | |-|-|---> bez znaczenia /steruje nimi dla LCD/
`                | | | ----------> =0 świeci LEDblueLED zapełnienie LOGu
`                | | ------------> =0 świeci LEDgreen poziom GSM
`                | --------------> =0 świeci LEDyellow poziom DCF77
`                ----------------> =0 świeci LEDred statusu
LD A,(#8002)            @LED&w `
`#8002 -> komórka cykliczna (zmienia swą wartość z szybkością przerwań)
`        bit7 -> ok.4Hz czyli 128[ms]+128[ms] ????? \
`        bit6 -> ok.8Hz czyli 64[ms]+64[ms] ?????   /chyba dwa razy wolniej
RRCA                           `
RRCA                           `
RRCA                           `
AND #10                        `tu tylko bit4 to watchdog
LD C,A                         ` czyli tylko bit watchdoga jest teraz na poz bit4
`                   minęło max +24tkt
`--- teraz zajmiemy się blueLED czyli stanu zapełnienia LOGu
LD A,(#8FF3)                   `StatusLEDblue
`#8FF3- 1b -wskaźnik 'kierujący' sposobem świecenia LED_BLUE: #00->ciągle=źle, #05->zgaszona=OK
CALL @flLED                    `+17+136tkt
RR C                           `7bit Crej to blueLED, 3bit to watchdog, pozostałe =0
`                   minęło max +205tkt =+181tkt+24
`--- teraz zajmiemy się greenLED czyli komunikacji mBus i poziomu sygn GSM
LD A,(#807C)                   `poziom GSM
`#807C -> 1b poziom sygnału GSM i stan komunikacji mbus 
`                                   #00 to brak komunikacji z tel.
`                                   #01 to poziom GSM odpowiadający 0 kresek na wyśw. NOKIA
`                                   #02-#05 to poziom GSM odpowiadający 1-4 kresek na wyśw. NOKIA
DEC A                          `
CP #05                         `
JR C,@KALSJ                    `hop bo dobry poziom
SUB A                          `=0 (jakiś nieznany poziom (traktujemy jak 0))
CP #02                  @KALSJ `
JR C,@AWLXC                    `
INC A                          `
`       zielona LED więc znaczenie mrugania odwrócone
LD B,A                  @AWLXC `
LD A,#05                       `
SUB B                          `
CALL @flLED                    `+17+136tkt
RR C                           `7bit Crej to greenLED, 6bit =blueLED, 
`                                                  2bit to watchdog, pozostałe =0
`                   minęło max +443tkt= +238+205
`--- teraz zajmiemy się yellowLED czyli poziomu DCF77(GPS) i posiadania akt. czasuDCF(GPS)
LD A,(#86EA)                   `
`#86EA -1b poziom sygnału DCF77 /#00 - #09/ liczba kolejnych poprawnych sekund
SUB #04                        `
JR C,@bt_NA                    `hop -> czyli naśladuj bit wejściowy DCF77 z PIO ;o)
CP #05                         `czy to super poziom?
JR C,@bitNA                    `hop -> słaby poziom, wyświetl
`tutaj poziom the best, jeśli jednak nie masz ustawionego czasu z DCF77
`to zrób wolne mruganie...           
LD A,(#8001)                   `\czy ustawiony
CP #05                         `/z DCF lub lepiej?
LD A,#05                       `poziom =#05 =zgaszona =super
JR NC,@bitNA                   `hop -> ustawiona, wyświetl super poziom #05
DEC A                          `poziom =#04 =wolno mruga, prawie dobrze
CALL @flLED             @bitNA `+17+136tkt
JR @_btNA                      `hop -> mamy bit w rejF w CY, wpisz go do Crej
LD A,(#80AB)            @bt_NA `bit0 to DCF77 z PIO bezpośrednio
XOR #01                        `odwrócony żeby świecił jak nic nie ma!
RRCA                           `bit0 (CDF77) sprowadzamy do CY
RR C                    @_btNA `7bit Crej to yellowLED, 6bit =greenLED, 5bit =blueLED, 
`                                                  1bit to watchdog, pozostałe =0
`                   minęło max +702tkt= +259+443
`--- teraz zajmiemy się redLED czyli ogólna alarmowa StatusSystemu
LD A,(#80C5)                   `dla LED StatusSystemu
CALL @flLED                    `+17+136tkt
RR C                           `7bit Crej to redLED, 6bit =yellowLED, 
`                       5bit =greenLED, 4bit =blueLED, 0bit to watchdog, pozostałe =0
`                   minęło max +883tkt= +181+702
`--- teraz wynik zajęć trzeba zapisać do komórki pamietającej
`                                i do portu PIO ster LEDami i watchdogiem
LD A,C                         `
LD (#80AC),A                   `tu tylko bit0 to LED stanu, 5=G, 4=M
`                               
`#80AC -> 1b z którego 4 bity 3-0 wysyłamy do portu C 8255 OUT
`               |7|6|5|4|3|2|1|0|
`                | | | |       |-> =0/1 pobudzanie watchdoga
`                | | | | |-|-|---> bez znaczenia /steruje nimi dla LCD/
`                | | | ----------> =0 świeci LEDblueLED zapełnienie LOGu
`                | | ------------> =0 świeci LEDgreen poziom GSM
`                | --------------> =0 świeci LEDyellow poziom DCF77
`                ----------------> =0 świeci LEDred statusu
LD BC,#5042                    `PC
OUT (C),A                      `zapis do portu C
`                   minęło max +918tkt=+35+883 /w tym bloku oczywiście/
`             ==============       
`--- teraz cykniemy TimeGuarda oczekiwanie na zapełnienie zdarzenia
`    choć do tej pory nie jest używany, bo procedury zapełniają zdarzenia za pierwszym razem
LD HL,#8FF5                    `\ cyka &16razy w sekundzie
LD A,(HL)                      ` |
AND A                          ` |
RET Z `JR Z,@nieCk             ` |
INC (HL)                       ` |TimeGuard zabezpieczającego oczekiwanie na zapełnienie
`                              `/ zdarzenia po zarezerwowaniu pamięci w LOGu
`--- +39tkt tutaj + wcześniejsze bloki...
RET `NOP                @nieCk `
`-----------------------------------------
`                             
`ustala do flagi CY czy ma świecić czy nie świecić LED
`według poziomu z Acc (#00-#FF):
`#00 świeci ciągle             (b.źle)
`#01 b.szybko mruga            (źle) 
`#02 szybko mruga              (kiepsko)
`#03 średnio mruga             (znośnie)
`#04 wolno mruga               (dobrze)
`#05...i więcej zgaszona       (b.dobrze)
`wywoływana 128 razy w sekundzie (częściej nie ma sensu, rzadziej nie można)
`dioda LED jest podłączona do PC0 i do +5V, tak więc świeci gdy PC0= L (0V)!
`                               
`zmienia AF, wynik: CY= świeć, NC= NIEświeć
`trwa: +136tkt max              
AND A                   @flLED `
RET Z                          `ret NC =świeć bo poziom =0
CP #05                         `
CCF                            `
RET C                          `ret C =nie świeć
LD B,A                         `dla pętli poniżej, Brej =4 max
LD A,(#8003)                   `ułamki sekund /do mrugania/
RLCA                           `
RRCA                    @QWR;K `
DJNZ @QWR;K                    `
AND #18                        `#1C
RET Z                          `NC
SCF                            `
RET                            `CY
`-------------------------------
`                               
`tutaj jest 250razy w sekundzie 
`mamy max rozsądnie do 2081tkt, 
`    aby nie było najdłuższą procedurą w @time+
`trwa +tkt max                  
NOP                     @_tme2 `
RET                            `
`-----------------------------------
`
`utwórz 2gą linię dla LCD             
`przesyła ASCII znaki w obszar VRAM drugiej linii dla wyświetlania LCD
` jest tutaj 2 razy w ciągu każdej sekundy
`trwa: +99tkt+ to_co_wykonuje 
`    max dla #04 -> +99+880 = +979tkt
LD A,(#86E9)              @2lLCD `
`#86E9 -1b tryb pracy wyświetlacza LCD (drugiej linijki):
CP #05 `CP #06                   `bezpiecznik i wyłącznik wyświetlania II linjki LCD
RET NC                           `LCD II linijka nie używana
LD HL,@_LCD_                     `adr. tabeli procedur obsł II linijki LCD
JP @jp(hl                        `+10+54tkt+...to co wykonuje
`-----------------------------------
`
` trwa: +165tkt max        #00 = inicjacja wyświetlania II linijki
SUB A                     @LCD00 `\
LD (#88E5),A                     ` |
LD (#88E6),A                     ` |czyść bufory LCD 2 linijki dla 
LD (#88E8),A                     ` | przedstawiania i zdarzeń
LD (#88E9),A                     ` |
LD (#898A),A                     ` |
LD (#8A2B),A                     ` |
DEC A                            ` |
LD (#88E7),A                     `/ =#FF, po INC =#00
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit5: =0 nic, =1 przedstawiono się na LCD
LD A,(#80B9)                     `
BIT 5,A                          `czy już się przedstawialiśmy na LCD?
LD A,#01                         `tryb II linijku => przedstawianie się
JR Z,@usTR2                      `hop -> ustal tryb na przedstawianie
LD A,#04                         `tryb II linijku => wyświetlanie zdarzeń
LD (#86E9),A              @usTR2 `+24tkt ustal
RET                              `
`------------------------------------
`
`#01 = realizowane przedstawianie się na LCD
` trwa: +792tkt max                 
LD HL,#80B9               @LCD01 `
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit5: =0 nic, =1 przedstawiono się na LCD
`         bit4: =0 nic, =1 gotowy tekst z bufSMSa czeka na wykorzystanie do przedstawienia
BIT 4,(HL)                       `sprawdź czy gotowy               
RET Z                            `wyjdź, bo niegotowy
LD HL,#8744                      `tekst w buforze SMSa
CALL @_LCD0                      `
RET NZ                           `jeszcze nie koniec
LD HL,#80B9                      `\
SET 5,(HL)                       `/bit5: =0 nic, =1 przedstawiono się na LCD
RET                              `
`------------------------------------
`
`pomocnicza dla II linijki LCD 
` trwa: +697tkt max                 
PUSH HL                   @_LCD0 `
LD HL,#88E7                      `
`#88E7 -1b określający od którego znaku wyświetlamy ten komunikat na LCD
INC (HL)                         `cyknij na następny znak
LD A,(HL)                        `
LD E,A                           `\
LD D,#00                         `/16 bitów, 
POP HL                           `
ADD HL,DE                        `mamy adres znaku na LCD
CALL @PrINt                      `+17+534tkt wypisz znak i przesuń
` jeśli Z to koniec -> zmiana linijki
RET NZ                           `(NZ) wywalony znak, jeszcze w trakcie
` tutaj skończona linijka         
LD HL,#86E9               @inLCe `+56tkt tryb pracy wyświetlacza LCD (drugiej linijki)
INC (HL)                         `
LD A,#FF                         `\ =#00 po inc
LD (#88E7),A                     `/
SUB A                            `
RET                              `(Z) ->finish
`--------------------------------
`
`#02 = reklama z EPROM              
` trwa: +717tkt max                
LD HL,@werbu              @LCD02 `tekst reklamowy
JP @_LCD0                        `
`------------------------------------
`
`#03 = reklama z RAM
` trwa: +781tkt max                
LD HL,#8E09               @LCD03 `adres reklamy z RAM
LD A,(HL)                        `
AND A                            `
JR Z,@inLCe                      `hop -> next etap 
`#8926 -1b określający od którego znaku wyświetlamy ten komunikat na LCD
LD A,(#88E7)                     `kolejny wyświetlany znak \
INC A                            `bo zaczynasz #FF          |bezpiecznk
CP #A0                           `=&160 znaków max          | 'na wszelki słuczaj'
JR NC,@inLCe                     `next etap                /
JP @_LCD0                        `działaj
`------------------------------------
`
`#00 = realizowane nadchodzące zdarzenia
` trwa: +880tkt max                
SUB A                     @LCD04 `to samo co spacja
LD (#8F30),A                     `wpisz pusty, jeśli miało by przeskoczyć...
LD HL,#88E6                      `
`#88E6 -1b określający który z komunikatów jest właśnie wyświetlany na LCD #00..#02
LD B,(HL)                        `która linijka
INC HL                           `
INC (HL)                         `cyknij znak od którego wyświetlamy
LD A,(HL)                        `
CP #88                           `=&160-&24=#88
LD C,A                           `który znak w linijce
JR Z,@>160_                      `hop -> przekroczył &160 znaków, zmień linijki
PUSH HL                          `adr. #88E7 -1b określający od którego znaku 
`                                                wyświetlamy ten komunikat na LCD
INC HL                           `\
INC HL                           `/adr linijki #00 -> #88E9
LD A,B                           `która linijka
AND A                            `czy to linijka #00 ?
JR Z,@to00#                      `hop -> to pierwsza
LD HL,#898A                      `adr linijki #01
DEC A                            `czy to linijka #01 ?
JR Z,@to00#                      `hop -> to pierwsza
LD HL,#8A2B                      `adr linijki #02
LD B,#00                  @to00# `16 bitów, C już jest
ADD HL,BC                        `adres znaku do wpisania
CALL @PrINt                      `wypisz znak i przesuń
` jeśli Z to koniec -> zmiana linijki
POP HL                           `
RET NZ                           `wyjdź bo trwa
LD (HL),#FF               @>160_ `czyli po INC będzie od znaku +#00 (pierwszego)
DEC HL                           `adr numeru linijki
INC (HL)                         `przeskocz na kolejną
LD A,(HL)                        `\
CP #03                           `/modulo 2 linijki
RET C                            `ok. to w zakresie
LD (HL),#00                      `zacznij od linii #00 bo przekroczony zakres
LD HL,#88E5                      `
`#88E5 -1b określający ile razy informacja o zdarzeniach została wyświetlona
`          od ostatniej zmiany/reklamy
INC (HL)                         `
LD A,(HL)                        `
CP #0A                           `czy &10 wyświetleń zdarzeń bez zmiany?
RET C                            `mniej
LD (HL),#00                      `zeruj licznik wyświetleń bez miany
`                                 
` TERAZ:                          
` przejście na etap LCD 02, czyli wyświetlanie reklamy na LCD
`                                 
LD A,#02                         `tryb II linijku => wyświetlanie zdarzeń
JP @usTR2                        `ustal tryb II linijki
`                                 
`  lub                            
` przejście na etap #05 czyli wyświetlania sytuacji awaryjnych typu: brak możl. wysłania SMS
`                                 
` a jeśli nie to znów zdarzenie z bufora #00
`                                 
`RET                              `
`---------------------------------
`
`tymczasowo /nie wykorzystywana jeszcze/
`trwa mniej niż inne z rodziny ;o)
`LD A,#02                  @LCD05 `tryb II linijku => wyświetlanie zdarzeń
`JP @usTR2                        `ustal tryb II linijki
`---------------------------------
`
`pomocnicza ->wpisuje znak na LCD II linijkę i przesuwa całość o 1 znak
`wyjście Z=koniec linijki,
`        NZ=jeszcze ciągniemy linijkę
`trwa +534tkt 
LD A,(HL)                 @PrINt `odczytaj znak
AND A                            `
LD (#8F30),A                     `tutaj wpisz znak /za ekranem/
LD HL,#8F19                      `\
LD DE,#8F18                      ` \przesuń o 1 znak w lewo
LD BC,#0018                      ` /
LDIR                             `/ nie zmiania w rejF Z ani CY
` jeśli Z to koniec -> zmiana linijki
RET                              `
`---------------------------------
`
`realizuje kroki transmisji systemu z PC 
`dostępny czas liczony następująco:
`najdłuższa do tej pory @_tme0 (przez @TPSA_), ale zakładamy obcięcie w @TPSA_ do 100tkt
` mamy po obliczeniach [@time+ -> @_tme2 ->...] max +1769tkt na @RS_PC
`    czyli 1668tkt na to co wykonuje
`trwa: +101tkt + to co wykonuje(max.+603tkt) = +704tkt max
LD A,(#8813)          @RS_PC `odczytaj krok transmisji system - PC
CP #17                       `sprawdź zakres kodu
JR NC,@baKOD                 `hop -> zła wartość kodu
LD HL,@kPCRS                 `adr. tabeli procedur wykonawczych
JP @jp(hl                    `pobierz adres z tabeli i skocz do niego
`                             +10+54tkt+...to co wykonuje
SUB A                 @baKOD `+28tkt \
LD (#8813),A                 `        |zła wawrtość kodu -> startuj od początku
RET                          `       /
`---------------------------------
`
`nadaj bajt Acc jeśli to możliwe
`0stos, zmienia: FBCE
`wyjście: [czasy dla: @Tx_PC]
`   CY -> nadano                   (trwa +77 tkt) \dla HO dodaj +12tkt
`   NC -> nie nadano bo full bufor (trwa +53 tkt) /
`    nadal aktualna koncepcja wykorzystania jednego 8251 więc niewiadomo...
`LD BC,#40C1        @Tx_HO `-8251 do domowego
`JR @TxTx_                 `
LD BC,#50C1        @Tx_PC `-8251 do PC-ta
LD E,A             `@TxTx_ `bajt do nadania
IN A,(C)                  `bajt stanu 8251
`                          bit0 -TxRdy =1 to nadajnik gotowy do przyjęcia słowa danych
CPL                       `odwrócenie bitów  =0
AND #01                   `Z (po odwróceniu) to gotowy na przyjęcie słowa danych
LD A,E                    `bajt do nadania
RET NZ                    `ret -> nie gotowy do przyjęcia bajtu +52tkt
DEC C                     `po tym C=#00 i ustawiona flaga Z
OUT (C),A                 `nie zmienia rej. F
SCF                       `CY
RET                       `tkt CY & Z +77tkt
`---------------------------
`
`odbierz bajt -sprawdza czy jest w 8251 odebrany bajt,
`1stosu, zmienia AFBCE
`wyjście:
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
`LD BC,#40C1        @Rx_HO `-8251 do domowego
`JR @RxRx_                 `
LD BC,#50C1        @Rx_PC `-8251 do PC-ta
IN A,(C)           `@RxRx_ `
`       bit1 -RxRdy    - =1 to w buforze odbiornika czeka bajt
CPL                       `
AND #02                   `
RET NZ                    `hop -> brak bajtu +44 tkt
DEC C                     `
IN E,(C)                  `to odebrany bajt,
INC C                     `
IN A,(C)                  `odczyt słowa stanu,
AND #38                   `
`     bit   3 -PE - =1 to błąd parzystości
`     bit  4  -OE - =1 to błąd straty bajtu
`     bit 5   -FE - =1 to błąd formatu,
SCF                       `
RET Z                     `CY & Z -> oki +92 tkt
LD A,#37                  `
`   słowo rozkazu ma bity o następującym znaczeniu:
`             bit    0 -TxEn =1 nadawanie dozwolone
`             bit   1  -DTR  =1 linia wyj.DTR w stanie niskim -aktywnym
`             bit  2   -RxEn =1 odbiór dozwolony
`             bit 3    -SBRK =0 linia TxD pracuje normalnie
`      bit    4        -ER   =1 wyzerowanie wskaźników PE, OE i FE w słowie stanu
`      bit   5         -RTS  =1 linia wyj.RTS w stanie niskim -aktywnym
`      bit  6          -IR   =0 nic
`      bit 7           -EH   =0 nic
OUT (C),A                     `flaga CY zerowana przez OR, flaga Z zależna od OR
`                              OUT nie zmienia Z i C
`  zakładamy że nie jest potrzebne gaszenie bitu erroru...
AND A                     `NC
RET                       `NC & NZ -> error +120 tkt
`--------------------------------
`
`cyka i sprawdza TimeGuarda,
`jeśli jeszcze płynie to NZ NC, gdy koniec to Z NC
`trwa +57tkt
LD HL,(#8810)             @dc810 `sprawdź TimeGuarda
DEC HL                           `cyknij
LD (#8810),HL                    `
LD A,H                           `\czy =0?
OR L                             `/
RET                              `ret -> NZ,NC=jeszcze płynie, Z,NC=koniec
`---------------------------------
`
`procedurka liczy autosumę EPROM 
` autosuma jest korygowana bajtem o adresie @EPRA$ i musi wynosić ileś tam, np. #27
`trwa +780tkt max /a może max trwać do: +1519tkt/
LD A,(#80BD)              @lczAS `
`   po hop minęło w PRs00 +149tkt a na całą @PRs00 mamy max +1668tkt
LD HL,(#80C2)                    `
BIT 7,H                          `czyli czy to już adres #8000 ? /dla 32kB/
JR NZ,@poLa$                     `hop -> już po liczeniu autosumy
`#80C2 - 2b- adres dynamiczny liczonej autosumy
`#80BD - 1b- liczona dynamicznie autosuma 
LD B,#10                         `liczba bajtów dla jakiej jednorazowo liczymy autosumę
`    wielokrotność Brej musi dawać #8000,
`    dla B=#10 trwa całość max: +780tkt dodać to co w ramach psucia
XOR (HL)                  @nxA$$ `
INC HL                           `kolejny bajt
DJNZ @nxA$$                      `pętla
LD (#80BD),A                     `\zapisz
LD (#80C2),HL                    `/
BIT 7,H                          `czyli czy to już adres #8000 ? /dla 32kB/
RET Z                            `ret -> jeszcze nie
AND A                     @poLa$ `
RET NZ                           `
` tutaj napraw bo dobra autosuma
LD HL,#80AD                      `
RES 6,(HL)                       `zeruj bit =dobra autosuma
RET                              `
`---------------------------------
`
`odbierz od PC bajt nagłówka #1F, startuj autosumę, rozpocznij TimeGuarda
`trwa +169tkt
CALL @Rx_PC               @PRs00 `
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
JR NC,@lczAS `RET NC             `ret ->brak bajtu /licz autosumę EPROM/
`                                 po hop minęło w PRs00 +149tkt
LD A,E                           `
CP #1F                           `
RET NZ                           `ret -> to nie nagłówek
LD (#8812),A                     `startuj XOR autosumę
LD HL,#0080                      `\czas w liczbie wywołań do TimeGuarda =ok 0,5[s]
` to jest czas liczony tylko gdy brak bajtu od momentu
` otrzymania bajtu czołówki do bajtu autosumy
`     było #0100         czyli ok 1[s]
LD (#8810),HL                    `/
LD HL,#8813               @RSicK `+31tkt adr. kroku
INC (HL)                         `zwiększ
RET                              `
`--------------------------------
`
`pomocnicza sprawdza, czy nie upłynął czas TG i jeśli tak to 
`przechodzi na krok oczekiwania na #1F
`trwa +127tkt max
CALL @dc810               @chkTG `+127tkt sprawdź TimeGuarda
RET NZ                           `ret -> jeszcze płynie NZ i NC
SUB A                     @pcErr `+28tkt \
LD (#8813),A                     `        |startuj od początku -> koniec TimeGuarda
RET                              `ret -> NZ i NC
`--------------------------------
`
`pomocnicza skracająca, odbiera Rx bajt, gdy go brak
`to sprawdza TimeGuarda i ew. zmienia krok na odbiór od początku (NC) max +276tkt
`gdy jest to dolicza do autosumy                                 (CY) max +162tkt
` brak bajtu (NC) max +276tkt
` jest bajt  (CY) max +162tkt, bajt w Erej
CALL @Rx_PC               @PRsRx `
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
JR NC,@chkTG                     `+12+127tkt jp ->brak bajtu, sprawdź TimeGuard
` minęło +119tkt= +17+92+10tkt
LD HL,#8812                      `\
LD A,(HL)                        ` |
XOR E                            ` |uwzględnij w autosumie
LD (HL),A                        `/
SCF                              `
RET                              `Acc=autosuma i Z/NZ
`--------------------------------
`
`odbierz bajt rozkazu wiersza RS232 z PC
`trwa +262tkt                        
CALL @PRsRx               @PRs01 `
` brak bajtu (NC) max +276tkt     
` jest bajt  (CY) max +162tkt, bajt w Erej
RET NC                           `
LD A,#7F                         `\
CP E                             ` |
JR Z,@pcErr                      `/ jr -> error, bo to kod ACK a nie rozkazu

LD A,E                           `
AND A                            `dla nowej kod rozkazu nie może być #00 !
JR Z,@pcErr                      `jr -> error, bo to kod #00

LD HL,#8814                      `\
LD (HL),E                        `/zapisz odebrany bajt rozkazu
JR @RSicK                        `next krok
`--------------------------------
`
`odbierz bajt długości wiersza RS232 z PC
`trwa +295tkt MAX                 
CALL @PRsRx               @PRs02 `
` brak bajtu (NC) max +276tkt     
` jest bajt  (CY) max +162tkt, bajt w Erej
RET NC                           `
` już +184tkt                     
LD A,E                           `
CP #7B                           `max długość +1
JR NC,@pcErr                     `jr -> error
LD HL,#8815                      `\
LD (HL),A                        `/zapisz odebrany bajt długości
AND A                            `
JR NZ,@nieZE                     `hop -> długość większa od 0
LD A,#04                         `\
LD (#8813),A                     ` |przejdź do kroku odbioru XOR autosumy
RET                              `/bo zerowa długość treści
SUB A                     @nieZE `+60tkt \
LD (#8808),A                     `       /cykana w górę ilość odebranych b.treści wiersza
JR @RSicK                        `next krok
`--------------------------------
`
`odbierz i zapisz w buforze bajty treści
`trwa +322tkt max                 
CALL @PRsRx               @PRs03 `
` brak bajtu (NC) max +276tkt     
` jest bajt  (CY) max +162tkt, bajt w Erej
RET NC                           `
` już +184tkt                     
LD HL,#8816                      `\
LD A,(#8808)                     ` \
LD C,A                           `  |obl. adres dla bajtu w buforze
LD B,#00                         ` /
ADD HL,BC                        `/
LD (HL),E                        `zapisz bajt
INC A                            `\
LD (#8808),A                     `/cyknij licznik bajtów w wierszu
LD E,A                           `liczba odebranych bajtów
LD A,(#8815)                     `odebrany bajt długości treści wiersza
CP E                             `całkowita minus odebrana
RET NZ                           `jeszcze nie wszystkie
JR @RSicK                        `next krok
`--------------------------------
`
`odbierz i sprawdź bajt XOR autsumy
`trwa +258tkt max                 
CALL @PRsRx               @PRs04 `
` brak bajtu (NC) max +276tkt     
` jest bajt  (CY) max +162tkt, bajt w Erej
RET NC                           `Acc=autosuma
` już +184tkt                     
JR NZ,@pcErr                     `jeśli inna niż zero to error
LD HL,#0020                      `\czas przerwy w liczbie wywołań do TimeGuarda 0,064[s]
` może też być LD HL,#0010       ` | 0,064[s]
LD (#8810),HL                    `/ 
JP @RSicK                        `next krok
`--------------------------------
`
`przerwa technologiczna przed nadaniem ACK i nadaj #1F
`trwa +228tkt max                 
CALL @dc810               @PRs05 `odczytaj TimeGuarda
RET NZ                           `ret -> jeszcze płynie
LD A,#1F                         `bajt nagłówka
CALL @Tx_PC               @Rs05_ `nadaj do PC-ta
`   nadaj bajt Acc jeśli to możliwe
`   CY -> nadano                   (trwa +77 tkt) 
`   NC -> nie nadano bo full bufor (trwa +53 tkt) 
RET NC                           `nie nadano
JR @RSicK                        `next krok
`--------------------------------
`
`nadaj bajt ACK #7F
`trwa +163tkt
LD A,#7F                  @PRs06 `
JR @Rs05_                        `+12+144tkt
`--------------------------------
`
`
`nadaj bajt XOR autosumy ACK
`trwa +189tkt
LD HL,#0010               @PRs07 `\czas przerwy w liczbie przerwań do TimeGuarda
LD (#8810),HL                    `/
LD A,#60                         `bajt XOR autosumy dla PCta (z #1F XOR #7F)
JR @Rs05_                        `+12+144tkt
`--------------------------------
`
`krok po odebraniu poprawnego wiersza z PC i jego potwierdzeniu ACK
` na to co wykonujemy mamy max. +1545tkt [bo 1668tkt - 123tkt]
`trwa +534tkt max:                     
`  dla przesyłania:                                           +534tkt max  
`  dla rozkazów #01..#1E:                                     +260tkt max
`  dla rozkazów #31..#36: +156tkt max +to co wykonuje, razem: +603tkt max <---
`  dla rozkazów #41..#5B: +219tkt max +to co wykonuje, razem: +509tkt max
LD A,(#8814)              @PRs08 `
CP #41                           `
JR NC,@roz41                     `+12+477tktmax hop -> rozkaz wpisania z PC do systemu
AND A                            `czy =0?
JR Z,@roz00                      `hop -> trwa wpisywanie...
CP #31                           `
JR NC,@roz31                     `+12+526max hop -> rozkaz specjalny
CP #1F                           `bezpiecznik 
JP NC,@pcErr                     `hop -> nieznany rozkaz
DEC A                            `bo nie ma rozkazu #00
LD E,A                           `\
ADD A,A                          ` \ na 16 bitów
ADD A,E                          ` | i *3 bo tyle ma wers rozkazu
LD E,A                           ` / 
LD D,#00                         `/
LD HL,@tab01                     `\adres w tabeli
ADD HL,DE                        `/
`CALL @pres*                      `pipeńka
LD A,(#8815)                     `
AND A                            `
JP NZ,@pcErr                     `hop -> zła długość
LD E,(HL)                        `\
INC HL                           ` \ odczytaj adr.
LD D,(HL)                        ` / skąd chce PC dane
INC HL                           `/
LD A,(HL)                        ` i ile bajtów
LD (#880D),DE             @Roz_N `+77tkt wyślij Acc bajtów spod adresu (DE)
LD (#8815),A                     `\zapisz ile bajtów
LD (#880F),A                     `/
LD A,#0A                         `\krok nadania jednego wiersza
LD (#8813),A                     `/
RET                              ` -> następny krok to #0A czyli wysłanie wieRSza do PC
SUB #31                   @roz31 `+546tkt max(@Roz35)
CP #07                           `bezpiecznik 
JP NC,@pcErr                     `hop -> nieznany rozkaz
LD HL,@tab31                     `
JP @jp(hl                        `+54+ max438
SUB #41                   @roz41 `+477tkt max odejmij podstawę
CP #1C                           `bezpiecznik 
JP NC,@pcErr                     `hop -> nieznany rozkaz
LD HL,#8816                      `\adres z którego przesłać
LD (#8741),HL                    `/z PC
LD E,A                           `\
ADD A,A                          ` \
ADD A,A                          `  \ na 16 bitów * 5
ADD A,E                          `  /  bo 1 wiersz to 5 bajtów
LD E,A                           ` /
LD D,#00                         `/
LD HL,@tab41                     `tabela dla rozkazów przesłania z PC do systemu
ADD HL,DE                        `adr w tabeli
`LD A,D                           `[#00] \rozkaz zero
`LD (#8814),A                     `      /aby next działało przeładowanie
LD E,(HL)                        `\
INC HL                           ` \ DE= adres na który przesłać z PC
LD D,(HL)                        ` / 
INC HL                           `/
LD (#8697),DE                    `zapisz
LD A,(HL)                        `\ 
INC HL                           ` |ile bajtów 
LD (#8743),A                     `/
LD A,(HL)                        `\
INC HL                           ` \ adres procedury
LD H,(HL)                        ` / sprawdzającej poprawność danych
LD L,A                           `/
JP (HL)                          `+54+ max221(@Roz48) to co wykonuje...
LD A,(#8743)              @roz00 `+534tkt max trwa wpisywanie...
AND A                            `czy l.bajtów do przesłania =0?
JR Z,@finRz                      `hop -> przesłano już wszystkie bajty
LD B,A                           `ile jeszcze bajtów
CP #08                           `max tyle, aby nie za długo
JR C,@ok08m                      `mniej
LD B,#08                         `więcej, więc #08
SUB B                     @ok08m `odejmij na przyszłość
LD (#8743),A                     `i zapisz to co zostanie na zaś
LD HL,(#8697)                    `\odczytaj adresy
LD DE,(#8741)                    `/od i do
` od @roz00 minęło +102tkt        
LD A,(DE)                 @ptLDI `\
LD (HL),A                        ` \  to trwa (Brej*39)-5 
INC DE                           `  |  dla B=8 trwa 307tkt
INC HL                           ` /   dla B=5 trwa 190tkt
DJNZ @ptLDI                      `/
LD (#8697),HL                    `
LD (#8741),DE                    `
`AND A `chyba niepotrzebnie       `
RET `NZ                           `opcja
LD (#8815),A              @finRz `+84tkt
LD A,#02                         `\zapisz za 2min
LD (#807D),A                     `/konfig
LD A,(#88C9)                     `
AND A                            `
JP Z,@pcErr                      `hop -> nic nie nadawaj po przeładowaniu
LD (#8814),A                     `rozkaz jaki nadać
RET                              `przy następnym wywołaniu @RS_PC zachowa się tak,
`                                 jakby otrzymał taki właśnie rozkaz o zerowej długości treści
`--------------------------------
`
`decyduj co dalej robić ->to węzeł pętli obliczający 
`                  adresy itd dla nadawania obszaru pamięci
`trwa +280tkt max                   
LD HL,(#8809)             @PRs09 `\adr. BIG do adresu small
LD (#880D),HL                    `/
LD HL,(#880B)                    `długość BIG
LD A,H                           `starszy bajt
AND A                            `czy =0?
JR NZ,@zaDLU                     `hop -> zbyt duża, więc max jaką się da
LD A,L                           `młodszy bajt
CP #7A                           `czy mniejszy od max w jednym wierszu?
JR C,@juzDL                      `hop -> krótszy
LD HL,#007A               @zaDLU `przyjmij max tego co da się naraz wysłać
LD A,L                    @juzDL `
LD (#880F),A                     `długość treści rzeczywistej (nie wiersza!)
ADD A,#03                        `\
LD (#8815),A                     `/o 3 więcej bo 2b adresu i 1b długości w treści
EX DE,HL                         `długość przesyłanej treści do DE
LD HL,(#8809)                    `\
ADD HL,DE                        ` |popraw BIG adres
LD (#8809),HL                    `/
LD HL,(#880B)                    `\
SUB A                            ` \ (zeruj CY i zeruj Acc)
SBC HL,DE                        ` /popraw BIG długość
LD (#880B),HL                    `/
`SUB A                            `=#00 (już jest)
LD (#8890),A                     `zeruj liczbę powtórek nadawania tego wiersza
JP @RSicK                        `next krok
`--------------------------------
`
`tutaj węzełek dla replay gdy brak lub błędny ACK z komputra
`nadaj #1F
`trwa +186tkt max                 
LD A,#1F                  @PRs0A `bajt nagłówka
CALL @Tx_PC                      `nadaj do PC-ta
`   nadaj bajt Acc jeśli to możliwe
`   CY -> nadano                   (trwa +77 tkt) 
`   NC -> nie nadano bo full bufor (trwa +53 tkt) 
RET NC                           `nie nadano
LD HL,#0100                      `\czas oczekiwania na ACK z komputera
LD (#8810),HL                    `/
LD (#8812),A                     `inicjuj autosumę
JP @RSicK                        `next krok
`--------------------------------
`
`nadaj rozkaz
`trwa +177tkt
LD A,(#8814)              @PRs0B `kod rozkazu
CALL @Tx_PC               @txBAJ `+164tkt nadaj do PC-ta
`   nadaj bajt Acc jeśli to możliwe
`   CY -> nadano                   (trwa +77 tkt) 
`   NC -> nie nadano bo full bufor (trwa +53 tkt) 
RET NC                           `nie nadano
LD HL,#8812                      `\
XOR (HL)                         ` |popraw autosumę
LD (HL),A                        `/
JP @RSicK                        `next krok
`--------------------------------
`
`nadaj bajt długości do PCta
`trwa +189tkt
LD A,(#8815)              @PRs0C `kod długości
JR @txBAJ                        `+12+164tkt nadaj do PC-ta itd.
`--------------------------------
`
`jeśli to obszar to nadaj bajt adresu (już jako treść)
`trwa +377tkt max                 
LD HL,(#880D)             @PRs0D `\
LD (#8806),HL                    `/adres skąd będziemy nadawać
LD A,(#880F)                     `\
LD (#8808),A                     `/długość, którą będziemy nadawać po bajtach adr i długości
LD A,(#8814)                     `
CP #F0                           `
JR NC,@Rs0D_                     `hop -> tak, to kod rozkazu obszaru
LD A,#10                         `krok nadawania treści wiersza (bez adresu i dł dla obszaru)
LD (#8813),A                     `adr. kroku
JR @PRs10                        `+12+260tkt hop do kroku
LD HL,(#880D)             @Rs0D_ `+228tkt adres do nadania bezwzględny
`LD DE,#9000                      `adr. początku logu
`JR NZ,@NOadW                     `hop -> adres normalny
`AND A                            `NC
`SBC HL,DE                        `zrób adres względny
LD A,L                    `@NOadW `+180tkt L bajt adresu nadawany w wierszu obszaru
JR @txBAJ                        `+12+164tkt nadaj do PC-ta itd.
`--------------------------------
`
`nadaj Hbajt adresu (już jako treść)
`trwa +271tkt max                 
LD A,(#8814)              @PRs0E `
CP #F0                           `
LD HL,(#880D)                    `adres do nadania bezwzględny
`JR NZ,@NOad2                     `hop -> nadaj normalnie adres bezwzględny
`LD DE,#9000                      `adr. początku logu
`LD A,(#8814)                     `
`CP #F0                           `
`JR NZ,@NOad2                     `hop -> adres normalny
`AND A                            `NC
`SBC HL,DE                        `zrób adres względny
LD A,H                    `@NOad2 `H bajt adresu nadawany w wierszu obszaru
JR @txBAJ                        `+12+164tkt nadaj do PC-ta itd.
`--------------------------------
`
`nadaj bajt długości (już jako treść)
`trwa +189tkt max                 
LD A,(#880F)              @PRs0F `bajt długości nadawany w wierszu obszaru
JR @txBAJ                        `+12+164tkt nadaj do PC-ta itd.
`--------------------------------
`
`nadaj treść właściwą bufora/obszaru
`trwa +260tkt
LD HL,(#8806)             @PRs10 `
LD A,(HL)                        `
CALL @Tx_PC                      `nadaj do PC-ta
`   nadaj bajt Acc jeśli to możliwe
`   CY -> nadano                   (trwa +77 tkt)
`   NC -> nie nadano bo full bufor (trwa +53 tkt)
RET NC                           `nie nadano
LD HL,#8812                      `\
XOR (HL)                         ` |popraw autosumę
LD (HL),A                        `/
LD HL,(#8806)                    `\
INC HL                           ` |incknij adres, bo ten bajt już wysłano
LD (#8806),HL                    `/
LD A,(#8808)                     `\
DEC A                            ` |decrementuj liczbę bajtów do wysłania
LD (#8808),A                     `/
RET NZ                           `
JP @RSicK                        `next krok
`--------------------------------
`
`nadaj XOR autosumy wiersza
`trwa +189tkt
LD A,(#8812)              @PRs11 `bajt autosumy
JR @txBAJ                        `+12+164tkt nadaj do PC-ta itd.
`--------------------------------
`
`odbierz #1F, ACK
`trwa +249tkt max                 
CALL @Rx_PC               @PRs12 `
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
JR NC,@chTGk                     `+12+110tkt ret ->brak bajtu
LD A,E                           `
CP #1F                           `
JR NZ,@chTGk                     `+12+110tkt ret -> to nie nagłówek
`LD (#8812),A                     `startuj XOR autosumę
JP @RSicK                        `+10+31tkt zwiększ krok
`--------------------------------
`
`procedura cykania TimeGuarda i czekania lub ew. przejścia do kroku @PRs15
`trwa +110tkt max                 
CALL @dc810               @chTGk `+17+57tkt sprawdź TimeGuarda
RET NZ                           `ret -> jeszcze płynie
LD A,#15                  @_chTk `+31tkt \krok decydowania czy próbujemy jeszcze raz nadawać
LD (#8813),A                     `        | -> koniec TimeGuarda/error
RET                              `       /
`--------------------------------
`
`odbierz #7F (ACK)
`trwa +247tkt max                
CALL @Rx_PC               @PRs13 `+109tkt =92+17
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
JR NC,@chTGk                     `ret ->brak bajtu
LD A,E                           `
CP #7F                           `
JR NZ,@_chTk                     `ret -> to nie nagłówek
`LD HL,#8812                      `\
`XOR (HL)                         ` |popraw autosumę
`LD (HL),A                        `/
JP @RSicK                        `zwiększ krok
`--------------------------------
`
`odbierz XOR od ACK
`trwa +247tkt max                  
CALL @Rx_PC               @PRs14 `
`   CY & Z  -> odebrany poprawnie bajt w rej E (trwa  +92 tkt)  \
`   NC & NZ -> odebrany bajt w rej E           (trwa +120 tkt)  |dla HO dodaj +12tkt
`   NC & NZ -> brak bajtu                      (trwa  +44 tkt)  /
JR NC,@chTGk                     `ret ->brak bajtu
`LD A,(#8812)                     `\
`XOR E                            `/spr. autosumę
LD A,E                           `\
CP #60                           `/tyle powinna wynieść autosuma dla ACK
JR NZ,@_chTk                     `ret -> błędna autosuma
LD A,#16                         `krok po nadaniu wiersza
LD (#8813),A              @zaWie `+24tkt zapisz KROK
RET                              `
`---------------------------------
`
`tutaj albo Time error albo błędny ACK
`trwa +92tkt max                  
LD HL,#8890               @PRs15 `
LD A,(HL)                        `\
INC A                            ` |zwiększ liczbę fauli
LD (HL),A                        `/
CP #05                           `
LD A,#00                         `krok oczekiwania na PC
JR NC,@zaWie                     `
LD A,#0A                         `krok nadawania wiersza
JR @zaWie                        `
`---------------------------------
`
`tutaj po nadaniu i odebraniu potwierdzenia
`trwa +108tkt max                  
LD A,(#8814)              @PRs16 `
CP #F0                           `
LD A,#00                         `krok #00
JR C,@zaWie                      `hop -> to nie obszar
LD HL,(#880B)                    `długość BIG
LD A,H                           `\
OR L                             `/
JR Z,@zaWie                      `hop -> długość do nadania =0
LD A,#09                         `krok dla kolejnego wiersza
JR @zaWie                        `wykonaj
`---------------------------------
`                                 
`trwa +184tkt max                  
LD A,(#8815)              @Roz31  `Polecenie z PC  zadzwonienia przez TPSA
`#8815 -1b Rx/Tx długość,          
`#8816- #888F (#7A bajtów) Rx/Tx treść gdy odbierane/nadawane jest do/z bufora,
CP #0D                            `=&13 10+1+1+1
JP NZ,@pcErr                      `hop -> zła długość
LD (#8743),A                      `ile bajtów do przesłania
LD A,(#88A8)                      `
AND #0F                           `
CP #08                            `czy jest już zlecenia nadania?
JP Z,@pcErr                       `hop -> jest coś dzwonione
LD HL,#8816                       `przesłane
LD (#8741),HL                     `przesyłaj z #8816
LD DE,#889C                       `m.docelowe
LD (#8697),DE                     `przesyłaj na #889C
SUB A                             `\czyli będzie przeładowywał...
LD (#8814),A                      `/
LD A,#1A                          `\nadaj później ID EPROM
LD (#88C9),A                      `/
RET                               `
`--------------------------------
`
`trwa +48tkt max                   
SUB A                     @Roz32  `Skasowanie znacznika zdarzenia error sprzętowy
`#87E6 -1b gdy = #00 (np. po RESET) to znaczy że nie było
`              <>#00 tzn że było zdarzenie typu nieznany error:
`                bit0 =1 -error polegający na wystąpieniu sprzętowego błędu przy detekcji
`                         poziomu napięcia na linii tel. stacjonarnego, 
`                         tzn. H pokazywał wyższe od wysokiego progu 
`                              a L pozkazywał niższe od niskiego (transoptory)
`                bit1 =1 -         
`                bit2 =1 -         
`                bit3 =1 -         
`                bit3 =1 -         
`                bit4 =1 -         
`                bit5 =1 -         
`                bit6 =1 -         
LD (#87E6),A                      `
LD A,#1A                          `\nadaj ID EPROM na potwierdzenie
LD (#8814),A                      `/
RET                               `
`----------------------------------
`                                  
`trwa +348tkt max                  
LD HL,(#8816)             @Roz33  `\
LD (#8809),HL                     `/adr. BIG ->Żądanie treści LOGu/MEMORY
` sprawdzamy wartość adr. czy zgodna z zakresem LOGu
PUSH HL                           `\
LD DE,#9000                       ` |
SBC HL,DE                         ` |czy dobry zakres?
POP HL                            `/
```````````JP C,@pcErr                       `hop -> za mały adres
NOP `
NOP `
NOP `
PUSH HL                           `\
LD DE,#F800                       ` |
SBC HL,DE                         ` |czy nie zbyt wiele?
POP BC                            `/
```````````JP NC,@pcErr                      `hop -> za duży adres
NOP `
NOP `
NOP `
LD HL,(#8818)                     `\dł. BIG
LD (#880B),HL                     `/
` sprawdzamy wartość adr+dł czy zgodna z zakresem LOGu
ADD HL,BC                         `
PUSH HL                           `
SBC HL,DE                         `czy nie zbyt wiele?
POP HL                            `
```````````JP NC,@pcErr                      `hop -> za duży adres + długość
NOP `
NOP `
NOP `
LD DE,#9000                       `
SBC HL,DE                         `czy dobry zakres?
```````````JP C,@pcErr                       `hop -> za mały adres + długość
NOP `
NOP `
NOP `
LD A,#F0                          `\aby nadawał obszar LOGu
LD (#8814),A                      `/
JP @RSicK                         `+10+31tkt next krok, bo to żądanie obszaru pamięci
`----------------------------------
`                                  
`Odczyt daty i czasu z systemu     
`trwa +264tkt max                  
LD HL,(#8001)             @Roz34  `\
LD (#8816),HL                     `/
LD HL,(#8003)                     `\
LD (#8818),HL                     `/
LD HL,(#8005)                     `\
LD (#881A),HL                     `/
LD HL,(#8007)                     `\
LD (#881C),HL                     `/
LD HL,(#8009)                     `\
LD (#881E),HL                     `/
LD DE,#8816                       `skąd =z bufora framki
LD A,#0A                          `ile =&10bajtów
JP @Roz_N                         `+10+77tkt nadaj
`----------------------------------
`                                  
`zapis czasu z PC gdy oczywiście jest taka potrzeba
`trwa +458tkt max                  
LD HL,#8815               @Roz35  `Zapis daty i czasu do systemu
LD A,(HL)                         `
`#8815 -1b Rx/Tx długość,          
`#8816- #888F (#7A bajtów) Rx/Tx treść gdy odbierane/nadawane jest do/z bufora,
CP #07                            `
JP NZ,@pcErr                      `hop bo zła długość -> olej
INC HL                            `
LD A,(#8001)                      `status TIME:  /zakres #00...#07!/
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA lub z tel. stacjonarnego (może być zły)
`                           to chyba też z SMSa otrzymanego?
`                   ---------      
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno lub z PC
`                      #04-ustawiony z delivery niedawno
`                      #05-ustawiony z DCF77
CP #03                            `
JR NC,@_Rz0D                      `nie ma takiej potrzeby /mamy lepszy czas/-> olej
LD A,(HL)                         `sekundy [#8816]
INC HL                            `
CP #3C                            `
JR NC,@_Rz0D                      `error -> olej
LD A,(HL)                         `minuty
INC HL                            `
CP #3C                            `
JR NC,@_Rz0D                      `error -> olej
LD A,(HL)                         `godziny
INC HL                            `
CP #18                            `
JR NC,@_Rz0D                      `error -> olej
LD A,(HL)                         `dni m-ca
INC HL                            `
CP #1F                            `
JR NC,@_Rz0D                      `error -> olej
LD A,(HL)                         `miesiące
INC HL                            `
CP #0C                            `
JR NC,@_Rz0D                      `error -> olej
INC HL                            `
LD A,(HL)                         `dni tygodnia
INC HL                            `
CP #07                            `
JR NC,@_Rz0D                      `error -> olej
LD HL,#8816                       `
LD DE,#8004                       `
`#8004 -> sekundy,       \         
`#8005 -> minuty,         \zliczane jako 
`#8006 -> godziny,        /czas rzeczywisty...
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)       
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
LD BC,#0007                       `
LDIR                              `
`                                  
LD HL,#8000                `\ustaw, że nieaktualne ASCIIdatyczasu
SET 0,(HL)                 `/
`                                  
LD A,#02                         `\zapisz a 2min
LD (#807D),A                     `/konfig
LD A,#34                   @_Rz0D `\
LD (#8814),A                      `/odpowiedz datą i czasem          
RET                               `
`----------------------------------
`                                  
`trwa +167tkt max                  
LD A,(#8815)              @Roz36  `Zapis treści MEMORY /długość wiersza
DEC A                             `\minus dwa bajty adresu
DEC A                             `/
LD (#8743),A                      `
JP Z,@pcErr                       `+10+28 hop -> zła długość
CP #79                            `
JP NC,@pcErr                      `+10+28 hop -> zła długość
LD HL,(#8816)                     `początek treści jako adres docelowy w MEMORY
LD (#8697),HL                     `zapisz
LD HL,#8818                       `adres źródłowy (z odenranej framki)
LD (#8741),HL                     `zapisz
SUB A                             `\
LD (#8814),A                      `/aby robił przeładowanie
LD A,#1A                          `\
LD (#88C9),A                      `/i potwierdził IDem EPROM
RET                               `
`----------------------------------
`                                  
`trwa +tkt max                  
CALL @RLoRz                @Roz37 `+17+162tkt, zerowanie całkowite LOGu
LD A,#1E                          `\
LD (#8814),A                      `/odpowiedz nagłówkiem LOGu
RET                               `
`----------------------------------
`                                  
`z poniższych można wyjść albo przez JP @pcErr,
`   albo przez wpisanie następnego po wykonaniu rozkazu do (#88C9) /lub #00
`   i #00 do (#8814) /aby przesyłało bajty jak w tabeli
`trwa +145tkt max +++++++++                 
LD HL,#8FF4                @Roz41 `
`#8FF4- 1b -wskaźnik procentowego zapełnienia LOGu #00 to 0%, #3F to 100% 
`           zapalony 7bit to PRE_OVER_LOG
`           zapalony 6bit to OVER_LOG
`           odczytując robimy AND #7F bo 7bit odrzucamy
`           z tego wskaźnika ustalana jest LEDka zapełnienia bufora
RES 6,(HL)                        `
RES 7,(HL)                        `
`  #8816- #888F (#7A bajtów) Rx/Tx treść gdy odbierane/nadawane jest do/z bufora,
LD HL,(#8816)                     `
LD (#8FF7),HL                     `
`#8FF7- 2b -[DO ODCZYTANIA] adr. wykorzystywany tylko przez PC i ustawiany tylko przez PC,
`                ew. zerowany przez RESET gdy syf w logu
`tutaj trzeba także zerować liczniki zdarzeń, duży i mały

LD HL,#0000                       `
`#8EFC - 2b licznik 'absolutny' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
LD (#8EFC),HL                     `
LD (#8EFE),HL                     `
`                                  
` problem polaga na tym iż od momentu skasowania bitów
` do momentu zapisu wartości wywołana będzie procedura, która i tak ustawi bity...
` więc zrobimy tak: przepiszemy pierw do 'do_odczytania' wartość 'wolne' co spowoduje
` nieustawianie bitów:             
`LD HL,(#8FFD)                     `
`LD (#8FF7),HL                     `
`
`
`
`                                  
LD A,(#8815)               @Roz__ `+105tkt długość z ramki
LD B,A                            `
LD A,(#8743)                      `długość oczekiwana
CP B                              `
JP NZ,@pcErr                      `hop -> inne długości =error

LD HL,#8814                @_Rz41 `+58tkt przeładuj jak z tabeli bez sprawdzania
LD A,(HL)                         `
AND #3F                           `
LD (#88C9),A                      `
LD (HL),#00                       `
RET                               `
`----------------------------------
`                                  
`trwa +87tkt max                   
SUB A                      @Roz42 `
`nie sprawdzamy czy dobra długość, bo i tak max #3F przeładowujemy
LD (#8EF7),A                      `na końcu ma być #00 ;o)
JR @_Rz41                         `+12+58tkt przeładuj jak z tabeli bez sprawdzania długości
`----------------------------------
`                                  
`trwa +tkt max                     
LD A,(#8816)               @Roz43 `czyli ustawianie godziny meldunku dobowego
CP #01                            `
JP NZ,@pcErr                      `hop -> zła długość ramki
`!`#8557 -1b godz wysłania melduna dobowego 
`!`      7bit=0 z meldunkiem dobowym, =1 bez meldunku dobowego
LD HL,#8557                       `
BIT 7,(HL)                        `
JR Z,@Roz__                       `+12+105tkt przeładuj jeśli zgodna długość ramki
LD HL,#0000                       `
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
LD (#8EFE),HL                     `
JR @Roz__                         `+12+105tkt przeładuj jeśli zgodna długość ramki
`----------------------------------
`                                  
`trwa +164tkt max                   
LD A,(#8816)               @Roz44 `
CP #04                            `
JP C,@pcErr                       `hop -> zbyt mało cyfr numeru
CP #15                            `
JP NC,@pcErr                      `hop -> zbyt wiele cyfr numeru
JR @Roz__                         `+12+105tkt przeładuj jeśli zgodna długość ramki
`----------------------------------
`                                  
`trwa +147tkt max                    
LD A,(#8816)               @Roz47 `
CP #11                            `
JP NC,@pcErr                      `hop -> zła wartość
JR @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +221tkt ++++++++ max                  
LD A,(#8816)               @Roz48 `
`CP #04                            `
`JP C,@pcErr                       `hop -> zbyt mało cyfr numeru
CP #15                            `
JP NC,@pcErr                      `hop -> zbyt wiele cyfr numeru
` sprawdzamy czy przeszukiwanie ks tel jest bądź całkowicie zakończone,
` bądź zakończony etap przeszukiwania pozycji znanych
LD HL,#807F                       `
LD A,(HL)                         `
CP #FE                            `
JP C,@pcErr                       `hop -> olej, jeszcze szukamy w znanych
LD A,#FF                          `\zaznacz, że
LD (HL),A                         `/zakończono przeszukiwanie ks tel.
`  na koniec musi jeszcze spowodować zapis konfigu a wcześniej numerów ks tel do SIM
LD HL,#8502                       `
LD A,(#8814)                      `\
SUB #48                           `/numer do zapisu #00-#07
ADD A,L                           `\
LD L,A                            `/tutaj nie ma przełomu
SET 7,(HL)                        `zaznacz że nadpisany z komputera
` znajdowanie numeru wolnej poz na SIM będzie podczas zapisu pozycji do książki telefonicznej
JR @Roz__                         `+12+105tkt przeładuj jeśli zgodna długość ramki
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz50 `
JR @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz51 `
JR @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz52 `
JR @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz53 `
JR @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz54 `
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz55 `
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz56 `
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +tkt max                    
NOP                        @Roz57 `
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +147tkt max                  
LD A,(#8816)               @Roz58 `
CP #05                            `
JP NC,@pcErr                      `hop -> zła długość ASCII (w pierwszym bajcie)
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +147tkt max                    
LD A,(#8816)               @Roz59 `
CP #0C                            `
JP NC,@pcErr                      `hop -> zła długość bajtowa
JP @Roz__                         `+12+105tkt 
`----------------------------------
`                                  
`trwa +87tkt max                   
SUB A                      @Roz5A `
LD (#8EA7),A                      `
JP @_Rz41                         `+12+58tkt przeładuj jak z tabeli bez sprawdzania długości
`---------------------------------
`
`pomocnicza przy sprawdzaniu poprawności wiecznego zegara
`  i jego kopii po RESET        
`trwa /poza NMI/               
LD BC,(#8E05)          @chkWZ `sprawdź autosumę wiecznego zegara
PUSH BC                       `
CALL @nie4a                   `
POP BC                        `
AND A                         `
SBC HL,BC                     `
RET                           `
`---------------------------------
`
`cyknij zegar i kalendarz do przodu
`trwa max: 486tkt
`-----------------------
`#8003 -> ułamki sekund zliczane co czwarte NMI. 250 (#FA) przeskakuje na 0 (#00),
`#8004 -> sekundy,       \
`#8005 -> minuty,         \zliczane jako 
`#8006 -> godziny,        /czas rzeczywisty...
`-----------------------
SUB A                  @_tme+ `pomiędzy kreseczkami to 146tkt max
LD (HL),A                     `#8003 zeruj ułamki sekund
INC L                         `
LD (#86C1),A                  `startuj od początku kroczki wykonania ASCII czasu z czasu
`                             `zerowanie #86C1 oznacza że ASCII daty/czasu nieaktualne
LD A,(HL)                     `#8004 -> sekundy
`CP #FF                       `
`RET Z                        `to ew. blokada czasu
INC A                         `przeskok sekundy...
LD (HL),A                     `
CP #3C                        `#3C=&60
RET C                         `
SUB A                         `
LD (HL),A                     `#8004 zeruj sekundy
INC L                         `
LD A,(HL)                     `#8005 minuty
INC A                         `przeskok minuty...
LD (HL),A                     `
CP #3C                        `#3C=&60
JR NC,@59>00                  `hop -> przeskok minuty
CP #3B                        `=&59
RET NZ                        `ret bo nie przeskok z &58 -> &59 minuta
`   tutaj przeskok minuty z 58 na 59
SUB A                         `#00
LD (#86F5),A                  `wartość poprawki
`HL jest tutaj równy #8005 (minuty)
INC L                         `
LD C,(HL)                     `godzina
INC L                         `
LD A,(HL)                     `dzień miesiąca, ponieważ szukamy ostatniej niedzieli
`                              interesuje nas niedziela która jest dniem miesiąca
`                              &25 lub większym (marzec i październik mają &31 dni)
CP #18                        `bo #17 odpowiada &24 dniu (#00 to pierwszy)
RET C                         `ret -> dzień 1-&24 -nie interesuje nas
INC L                         `
LD B,(HL)                     `miesiąc
INC L                         `
INC L                         `
LD A,(HL)                     `dzień tygodnia
CP #06                        `czy to niedziela?
RET NZ                        `ret -> nie niedziela
`       tutaj mamy ostatnią niedzielę miesiąca
LD A,B                        `miesiąc
CP #02                        `czy to marzec?
JR NZ,@noIII                  `hop -> nie marzec
LD A,C                        `godzina
CP #01                        `czy 1-sza?
RET NZ                        `
`       tutaj mamy ostatnią niedzielę marca, godzina 01:59:00
`       a więc będzie zmiana czasu z 02:00 na 03:00
LD A,#01                      `+1h poprawki
LD (#86F5),A           @porHo `zapisz do wykonania (jeśli jeszcze dziś nie było)
RET                           `
CP #09                 @noIII `czy to październik?
RET NZ                        `
LD A,C                        `godzina
CP #02                        `czy 2-ga?
RET NZ                        `
`       tutaj mamy ostatnią niedzielę października, godzina 02:59:00
`       a więc będzie zmiana czasu z 03:00 na 02:00 /jeśli jeszcze nie było/
LD A,#FF                      `-1h poprawki
JR @porHo                     `wykonaj
SUB A                  @59>00 `
LD (HL),A                     `#8005 zeruj minuty
INC L                         `adr. godzin
LD A,(#86F4)                  `przeskok minuty z &59 na &00 czyli przeskok godziny
AND #C0                       `sprawdzamy bity zabroniona zmiana czasu i była zmiana
JR NZ,@n5859                  `hop -> albo zabroniona zmiana, albo była
LD A,(#86F5)                  `
ADD A,(HL)                    `popraw godziny o przygotowaną poprawkę
LD (HL),A                     `zapisz
LD A,(#86F4)                  `
SET 6,A                       `zaznacz, że była zmiana czasu
LD (#86F4),A                  `
LD A,(HL)              @n5859 `#8006
INC A                         `przeskok godziny...
LD (HL),A                     `
CP #18                        `#18=&24
RET C                         `
SUB A                         `
LD (HL),A                     `#8006 zeruj godziny
`-----------------------
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`-----------------------
LD HL,#86F4                    `
RES 6,(HL)                     `kasuj znacznik -dziś była zmiana czasu
INC HL                         `
SUB A                          `=#00
LD (HL),A                      `poprawka godziny =#00
LD HL,#800A                    `dni tygodnia   [#00 - #06, #00 to niedziela]
LD A,(HL)                      `
INC A                          `cyknij dzień tygodnia
CP #07                         `
JR C,@dobei                    `hop bo nie przeskoczył tydzień
SUB A                          `
LD (HL),A               @dobei `
LD A,#02                       `\zaznacz konieczność zapisania konfigu na SIM 
LD (#807C),A                   `/     bo -> przeskoczył dzień
LD L,#07                       `LD HL,#8007 adres dni miesiąca
INC (HL)                       `inc(dzień_miesiąca)
LD D,(HL)                      `liczba dni zwiększona o 1 !
INC L                          `
LD A,(HL)                      `miesiące [#00 - #0B] /#00 to styczeń, #0B to grudzień/
INC L                          `
LD E,(HL)                      `lata (#00 => 2000r) kukuryku
CALL @DmArE                    `w Acc wychodzi liczba dni w miesiącu A roku E 
`                                                     (nie zmienia D, zmienia HL)
CP D                           `max.liczba_dni - sprawdzana liczba dni -> CY=zeruj, NC=nie zeruj
RET NC                         `wyjdź bo nie przeskoczył miesiąc
SUB A                          `
LD HL,#8007                    `adres dni miesiąca
LD (HL),A                      `zeruje liczbę dni i wtedy musi przeskoczyć miesiąc...
INC L                          `adres miesięcy
INC (HL)                       `popchnij miesiąc
LD A,(HL)                      `
CP #0C                         `modulo &12 /#0B =&11 czyli 12-ty miesiąc!/
RET C                          `
SUB A                          `
LD (HL),A                      `zeruj miesiące (tzn. zrób styczeń)
INC L                          `adres rok
INC (HL)                       `popchnij rok
RET                            `
`--------------------------------
`
` na każdą mamy jakieś +701tkt aby wyrównać do @TPSA_ ...
DEFETYK @LTime `tabela adresów procedur wywoływanych tylko raz w sekundzie
DEFTABE LTm1_   `trwa max +699tkt         <----------------------------------------------max! 
` pomocnicza przerzuca ASCII daty/czasu do VRAM
` cyka pomiar czasu braku sygnału GSM
` cyka czas pozytywnego poziomu sygnału GSM
` cyka czas od pierwszego wczytania konfigu
` cyka czas od RESET                       
DEFTABE LTm2_   `trwa max +690tkt
` cyka czasy 11 stoperów SMSów oczekiwania na delivery
` cyka drugi TimeGuard zewnętrzny wysyłania SMSów
DEFTABE LTm3_   `trwa max +660tkt free 41tkt
`cyka wewnętrzny, pierwszy TimeGuard wysłania SMSa /ew. wysyła go jeszcze raz/
` cyka w każdej 15-ej sekundzie minutnik zapisu konfigów, ew. ustala DKrokNOKIA
` cyka czas jaki upłynął od określenia pozycji LAC/CID z GSM
` cyka czas oczekiwania na poz z książki telefonicznej
` cyklicznie sprawdza zakres StatusTime (i ew. poprawia)
` cyka stoper sekundowy wysyłania reklam SMSami
` cyka stoper sekundowy interwału SMS taj/pay
` cyka czas dzwonka/rozmowy GSM /ew. klasyfikuje jako cynę gdy dzwonek do 3 sekund/
DEFTABE LTm4_   `trwa max +552tkt free 149tkt
` cyka wieczny zegar czasu pracy i zegar czasu pracy od utworzenia konfigu
DEFTABE LTm5_   `trwa max +405tkt free 296tkt
` obsługuje stoper resms SMSa tajnego
DEFTABE LTm6_   `trwa max +417tkt free 284tkt
` obsługuje stoper resms SMSa paynego
DEFTABE LTm7_   `trwa max +558tkt
`cyka czasy stoperów 230V      
` cyka stoperek blokady zdarzenia #14 TPSA po zaniku i pojawieniu się nap. linii telef
` cyka czas od ostatniego wykonania tel. TPSA alarmowego
` cyka czas dla redialu na stacjonarny, gdy takie ustawienie
` cyka TimeGuarda Alarmowego wywołania numeru TPSA
DEFTABE LTm8_   `
`cyka czasy trwania dzwonka i otwartych drzwi
` cyka czas trwania rozmowy TPSA, 
` cyka czas blokady ponownego zgłoszenia brąz alarmu
` cyka 5-cio sekundowy TimeGuard odbioru CID w TPSA
` cyka stoperek sekundowy braku napięcia 230V
DEFTABE LTm9_   `
`    cyka stoper blokady zdarzenia brak nap. linii telefonicznej
`    cyka w każdej 16-ej sekundzie odebrany czas z DCF77, dla porównania 
`                             
`tutaj mogą być jeszcze adresy innych oczywiście
`procedurek, w sumie do 9 sztuk wykonywane będą one raz w każdej sekundzie
`liczba procedurek jest określana przez CP #0A w ten sposób że #02 jest dla jednej, 
`#03 dla dwóch itd a #0A dla 9-ciu procedurek
`----------------------------------
`
`pomocnicza przerzuca ASCII daty/czasu do VRAM
` cyka pomiar czasu braku sygnału GSM
` cyka czas pozytywnego poziomu sygnału GSM
` cyka czas od pierwszego wczytania konfigu
` cyka czas od RESET                       
`trwa: +699tkt                 
LD HL,#800B            @LTm1_ `wywal datę i czas do VRAM
LD DE,#8F00                   `
LD BC,#0010                   `
LDIR                          `
` minęło +361tkt               
LD HL,(#80B4)                 `
`#80B4 -2b licznik sekundowy =#0000 lub 15bit=1 to stoi, 
`                     else idzie ->licznik pozytywnego poziomu GSM
BIT 7,H                       `
JR NZ,@nic1a                  `hop ->już stoi
LD A,H                        `
OR L                          `
JR Z,@nic1a                   `hop ->jeszcze stoi
INC HL                        `
LD (#80B4),HL                 `
LD HL,#80B3            @nic1a `
`#80B3 - 1b sekundy od pierwszego wczytania konfigu,
`        stoi gdy 7bit=1 lub gdy =#00, else idzie co sekundę do góry
LD A,(HL)                     `
DEC A                         `
BIT 7,A                       `
JR NZ,@nic1b                  `
INC (HL)                      `
LD HL,(#87F7)          @nic1b `
`#87F7 -2b sekundowy stoper od RESET idzie od #0000 do #FFFF potem stoi
INC HL                        `
LD A,H                        `
OR L                          `
JR Z,@nic1c                   `
LD (#87F7),HL                 `
`#80B6 -3b licznik sek/min/godz braku poziomu GSM, stoi gdy 7bit sek =1 else idzie
LD HL,#80B6            @nic1c `
LD A,(HL)                     `
BIT 7,A                       `
RET NZ `JR NZ,@nic1d          `hop ->stoi
INC (HL)                      `cyknij sekundy
LD A,(HL)                     `odczytaj sekundy po cyknięciu
CP #3C                        `czy < &60 ?
RET C `JR C,@nic1d            `hop -> ok, mniejsze
LD (HL),#00                   `zeruj sekundy
INC HL                        `adr minut
INC (HL)                      `cyknij minuty
LD A,(HL)                     `odczytaj minuty
CP #3C                        `czy < &60
RET C `JR C,@nic1d            `hop ->ok, mniejsze
LD (HL),#00                   `zeruj minuty
INC HL                        `adr godzin
INC (HL)                      `cyknij godziny
LD A,(HL)                     `odczytaj godziny
AND A                         `czy < max
RET NZ `JR NZ,@nic1d          `hop ->ok, mniejsze
LD (HL),#FF                   `godziny max
RET                    `@nic1d `
`-------------------------------
`
`cyka czasy 11 stoperów SMSów oczekiwania na delivery
` cyka drugi TimeGuard zewnętrzny wysyłania SMSów
`trwa +690tkt                  
LD HL,#8083            @LTm2_ `cyka czasy wszystkich SMSów oczekujących na potwierdzenie
LD B,#0B                      `ile tych SMSów, tych liczników sekundowych
LD A,(HL)              @OIAWV `odczytaj bajt (nie rusza gdy #00 lub #FF),
INC A                         `zwiększ (do testów też),
CP #02                        `pozostaw gdy #00,#01 (czyli wcześniej #FF,#00),
JR C,@poaks                   `hop -> nie zwiększaj -pozostaw,
LD (HL),A                     `zapisz już zwiększony o 1,
INC HL                 @poaks `adres kolejnego 
INC HL                        `adres kolejnego 
DJNZ @OIAWV                   `pętla, next [622 =(44+13)*11 -5]
` poniżej to 40tkt + 11(Ret)   
LD HL,#88E2                   `
`#88E2 -1b sekundowy TimeGuard oczekiwania na delivery jakiegokolwiek SMSa po 
`          zleceniu wysłania SMSów alarmowych, idzie w dół gdy >0, potem stoi
LD A,(HL)                     `
AND A                         `
JR Z,@nic2a                   `hop -> bo równy zero więc stoi
DEC A                         `cyknij
LD (HL),A              @nic2a `zapisz
RET                           `
`-------------------------------
`
`cyka wewnętrzny, pierwszy TimeGuard wysłania SMSa /ew. wysyła go jeszcze raz/
` cyka w każdej 15-ej sekundzie minutnik zapisu konfigów, ew. ustala DKrokNOKIA
` cyka czas jaki upłynął od określenia pozycji LAC/CID z GSM
` cyka czas oczekiwania na poz z książki telefonicznej
` cyklicznie sprawdza zakres StatusTime (i ew. poprawia)
` cyka stoper sekundowy wysyłania reklam SMSami
` cyka stoper sekundowy interwału SMS taj/pay
` cyka czas dzwonka/rozmowy GSM /ew. klasyfikuje jako cynę gdy dzwonek do 3 sekund/
`trwa +660tkt                  
LD HL,#84FF            @LTm3_ `\odczytaj TimeGuarda wysyłania SMSa
LD A,(HL)                     `/
AND A                         `\czy równy #00 (tzn. czy stoi)
JR Z,@nic3a                   `/hop -> stoi
INC A                         `
LD (HL),A                     `
CP #14                        `=&20 sek oczekiw na potwierdze wysłania/NIEwysłania SMSa
`                              od czasu utworzenia USERa
JR C,@nic3a                   `hop -> za krótki czas od zrobienia ramki
LD (HL),#00                   `zatrzymaj stoper /ponownie jest uruchamiany przy 
`                                                kolejnym zrobieniu ramki USERa z SMSem/
LD L,#EE `LD HL,#84EE         `adr. statusu tworzenia SMSa
LD A,(HL)                     `
AND #F0                       `\
CP #B0                        `/czyli czy oczekuje na odpowiedź NOKIA czy nadała, czy nie
JR NZ,@nic3a                  `hop -> status inny niż oczekuje na potwierdzenie nadania SMSa
LD A,(HL)                     `
AND #8F                       `czyli zlecenie tworzenia USERa SMSa na nowo
LD (HL),A                     `zapisz 
`119                           
`---                            
LD A,(#8004)           @nic3a `bieżąca sekunda
CP #0F                        `w każdej &15-ej sekundzie
JR NZ,@nic3c                  `ret =inna sekunda
LD HL,#807D                   `minutnik zapisu konfigów
DEC (HL)                      `
LD A,(HL)                     `odczytaj
AND A                         `czy =0?
JR NZ,@nic3c                  `ret =nie, a więc nie przeskok z #01 -> #00
LD DE,#802E                   `adr DKroku
LD A,(DE)                     `
INC A   `CP #FF               `czy wolny?
JR Z,@nic3b                   `
INC (HL)                      `wycofaj się, bo zajęty DKrok
JR @nic3c                     `
LD A,#08               @nic3b `DKrok =#08 to zapis nr tel nadpisanych i konfigów na SIM
LD (DE),A                     `żyto =wykonaj
` 117 +119 = 236               
`---                            
LD HL,#804D            @nic3c `popycha zliczane co 1s stopery
LD A,(HL)                     `zaczynamy od czasu określenia pozycji wgGSM
CP #F0
JR NC,@nic3d                  `hop -> nie cykaj
DEC HL                        `
INC (HL)                      `cyknij sekundy
LD A,(HL)                     `odczytaj sekundy
CP #3C                        `
JR C,@nic3d                   `hop -> cyknięte sekundy, ale nie przeskoczyły minuty
SUB A                         `zeruj
LD (HL),A                     `sekundy
INC HL                        `
INC (HL)                      `cyknij minuty
` 97 +236 = 333                
`---                           
LD HL,#807A            @nic3d `1b licznik w dół czasu oczekiwania na książkę telef.
LD A,(HL)                     `
AND A                         `
JR Z,@nic3e                   `=0 więc wyjdź
DEC (HL)                      `odlicz 1 sekundę oczekiwania na odp książki tel.
` 39 +333 = 372                
`---                                                 
LD HL,#8001            @nic3e `cykliczne sprawdzenie poprawności
LD A,(HL)                     `StatusTime
AND #07                       `
CP #06                        `
JR C,@nic3f                   `hop -> poprawna
SUB A                         `zeruj, bo zła wartość Status Time 
LD (HL),A              @nic3f `
` 49 +372 = 421                
LD HL,#87F6                   `
`#87F6 -1b sekundowy stoper pomocniczy do wysyłania reklam
DEC (HL)                      `cyknij zegar wysyłania SMSów reklamowych
` 21 + 421 = 442tkt            
LD HL,#8EFB                   `
`#8EFB - 1b sekundowy stoper interwału SMS taj/pay idzie w dół do #00 potem stoi
DEC (HL)                      `
LD A,(HL)                     `
INC A                         `
JR NZ,@nie3z                  `
LD (HL),A                     `
` 46 + 442 = 488               
` niżej      161               
`             11               
`           ----               
`            660               
LD HL,#86B3                   `
`#86B1 -> 3b pomiar czasu: -dzwonienia przychodzącego, 
`                          -rozmowy przychodzącej,
`                          -dzwonienia drugiego telefonu,
`                          -rozmowy wychodzącej,
`                          -wybierania numeru,
`      #86B1 -> sekundy,\
`      #86B2 -> minuty, |bieżące tego co się dzieje od zera w górę...
`      #86B3 -> godziny /
`   czas tutaj jest cykany przez time+ wtedy gdy godziny <#7F (&128),
`   co pozwoli nam blokować czas z zapamiętaniem jego wartości poprzez zapalenie 7bitu godzin,
`   wartość =#7F oznacza że trwa zdarzenie, ale czas jest równy lub większy od &127 godzin
LD BC,#86A7            @nie3z `szybciej i taniej
LD A,(HL)                     `
CP #7F                        `
RET NC `JR NC,@nie3h          `nie cykaj, bo zablokowane 7 bitem lub wartość =#7F
DEC HL                        `\obl. adres sekund
DEC HL                        `/
INC (HL)                      `cyknij sekundy
LD A,(HL)                     `odczytaj sekundy
CP #3C                        `czy nie przekroczyły &60 ?
` już 74                       
JR C,@nic3g                   `hop, nie przekroczyły, sprawdź czy powyżej 3 sek. cyna
` niżej +80tkt                 
SUB A                         `=#00
LD (HL),A                     `zeruj sekundy
INC HL                        `adres minut
INC (HL)                      `cyknij minuty
LD A,(HL)                     `odczytaj minuty
CP #3C                        `czy nie przekroczyły &60 ?
RET C `JR C,@nie3h            `hop, nie przekroczyły
SUB A                         `=#00
LD (HL),A                     `zeruj minuty
INC HL                        `adres godzin
INC (HL)                      `cyknij godziny
RET  `JR @nie3h               `
CP #03                 @nic3g `sprawdź czy to 3 sekundy?
RET NZ `JR NZ,@nie3h          `hop, nie 3 sekundy
LD A,(BC)                     `sprawdź czy to jeszcze oznaczone poł. jako cyna
AND #F0                       `wywal nieznaczące bity
CP #B0                        `sprawdź: dzwoni, czas trwania do 3 sekund
RET NC `JR NZ,@nie3h          `hop, nie jako cyna (a więc np minuta i 3 sek ;o) )
LD A,(BC)                     `
RES 4,A                       `zgaś bit oznaczający teraz cynę przychodzącą
LD (BC),A                     `
` najdłużej (bez skoku @nic3f) -> 81+80 = 161
RET                   `@nie3h `
`------------------------------
`                              
` cyka wieczny zegar czasu pracy i zegar czasu pracy od utworzenia konfigu
`trwa  +552tkt max             
LD HL,#8E00            @LTm4_ `
LD DE,#8DF9                   `
LD BC,#0007                   `
LDIR                          `30+7*21-5=172tkt
` 172                          
LD HL,#8E00                   `
INC (HL)                      `
LD A,(HL)                     `sekundy
CP #3C                        `
JR C,@nie4a                   `
LD (HL),#00                   `
INC HL                        `
INC (HL)                      `
LD A,(HL)                     `minuty
CP #3C                        `
JR C,@nie4a                   `
LD (HL),#00                   `
INC HL                        `
INC (HL)                      `
LD A,(HL)                     `godziny
CP #18                        `
JR C,@nie4a                   `
LD (HL),#00                   `
LD HL,(#8E03)                 `\
INC HL                        ` |cyknij dni
LD (#8E03),HL                 `/
` 186 +172 = 358               
`  teraz wypada jeszcze tylko policzyć autosumę
LD DE,#8E03            @nie4a `+203tkt
LD HL,#4FAA                   `
LD BC,(#8E03)                 `
ADD HL,BC                     `
LD B,#03                      `
DEC DE                 @nic4b `
LD A,(DE)                     `
LD C,A                        `
ADD HL,BC                     `
DJNZ @nic4b                   `3*(28+16)-5=127
LD (#8E05),HL                 `zapisz autosumę
` 183 + 358 = 541              
`+11                           
RET                           `tutaj busi być RET bo ta proc [@nie4a] jest jeszcze wywoływana
`-------------------------------
`
`obsługuje stoper resms SMSów tajnych
`trwa: +405tkt                 
`
`
`tutaj mamy wolnych do 701 - 405 = 296tkt
`
`
LD HL,#8DD9              @LTm5_ `
`poniżej trwa +394tkt max        
BIT 7,(HL)               @stpHL `jeśli stoi to wyzeruj go i nie cykaj
` obsługa cykania stopera raz w sekundzie
` wejście: HL=adres stopera 4bajtowego dla paya lub tajnego
JR Z,@zerHL                     `
LD E,L                          `\pamiętaj adres
LD D,H                          `/
INC HL                          `
INC (HL)                        `cyknij sekundy
LD A,(HL)                       `
CP #3C                          `
JR C,@bzClK                     `
LD (HL),#00                     `
INC HL                          `
INC (HL)                        `cyknij minuty
LD A,(HL)                       `
CP #3C                          `
JR C,@bzClK                     `
LD (HL),#00                     `
INC HL                          `
INC (HL)                        `cyknij godziny
` poniżej porównamy ile naliczył 
LD B,#05                 @bzClK `czyli dla wartości #05 
LD L,E                          `
LD H,D                          `
LD A,(HL)                       `odczytaj krok
AND #7F                         `tylko wartość kroku
CP #7F                          `
JR NZ,@HLduz                    `hop ->mniejsze niż granica zakresu
LD A,#FE                        `czyli zmniejsz o 1 /zapal 7bit/
LD (HL),A                       `i zapisz
CP #07                   @HLduz `
JR C,@HL07v                     `hop ->oki
LD A,#07                        `
AND #07                  @HL07v `
INC HL                          `dotyczy sekund
SUB #02                         `
JR C,@HL?05                     `hop -> krok #00, #01
INC HL                          `dotyczy minut
SUB #02                         `
JR C,@HL?05                     `hop -> krok #02, #03
INC HL                          `dotyczy godzin
JR Z,@HL_05                     `hop ->krok #04
CP #FE                   @HL?05 `czyli dla wartości #05 
JR Z,@HL_05                     `hop ->kroki #00 lub #02
LD B,#18                        `czyli dla wartości #18 (&24) kroki: #01, #03, >=#05
LD A,B                   @HL_05 `
CP (HL)                         `granica - licznik
RET NC                          `-> jeszcze trwa, licznik nie większy od granicy
` licznik większy od granicy, zeruj stoper
EX DE,HL                        `
LD A,(HL)                @zerHL `tutaj zeruje cały stoper
AND #7F                         `\nie zmieniając KROKu stopera
LD (HL),A                       `/
SUB A                           `=#00
INC HL                          `
LD (HL),A                       `sekundy
INC HL                          `
LD (HL),A                       `minuty
INC HL                          `
LD (HL),A                       `godziny
RET                             `-> już nie trwa
`------------------------------
`                              
`obsługuje stoper resms SMSów paynych
`trwa: +417tkt                 
`
`
`tutaj mamy wolnych do 701 - 417 = 284tkt
`
`
LD HL,#8DDD              @LTm6_ `
`trwa +394tkt max                
JR @stpHL                       `hop -> wykonaj obsługę
`------------------------------
`
`cyka czasy stoperów 230V      
` cyka stoperek blokady zdarzenia #14 TPSA po zaniku i pojawieniu się nap. linii telef
` cyka czas od ostatniego wykonania tel. TPSA alarmowego
` cyka czas dla redialu na stacjonarny, gdy takie ustawienie
` cyka TimeGuarda Alarmowego wywołania numeru TPSA
`trwa: +630tkt  ----------- ??               
LD HL,(#87E8)          @LTm7_ `cyka czasy stoperów 230V
BIT 7,H                       `
JR NZ,@nic7a                  `
INC HL                        `
LD (#87E8),HL          @nic7a `
`#87E8 -2b CT230 =czas trwania napięcia 230V
LD A,(#87EA)                  `A=godz
BIT 7,A                       `bit7 = 1 to STOP
JR NZ,@nic7b                  `
LD B,A                        `B=godz
LD HL,(#87EB)                 `H=sek, L=min
INC H                         `
LD A,H                        `
CP #3C                        `
JR C,@HMSok                   `hop -> mniej niż &60, =ok
LD H,#00                      `
INC L                         `
LD A,L                        `
CP #3C                        `
JR C,@HMSok                   `hop -> mniej niż &60, =ok
LD L,#00                      `
INC B                         `
LD A,B                        `
CP #7F                        `
JR C,@HMSok                   `hop -> mniej niż &128, =ok
DEC B                         `
LD A,B                 @HMSok `
LD (#87EA),A                  `zapisz godziny
LD (#87EB),HL                 `H=sek, L=min
`#87EA -3b (godz/min/sek) CP230 =czas przerwy 230V bit7 w godzinie (#87EA) =1 to stop
`    #87EA -godz 0-127&  gdy bit7=1 to stoi 
`    #87EB -min  0-59&             
`    #87EC -sek  0-59&            
`---                           
` teraz cyka stoper blokady generacji zdarzeń przez TPSA 
`                po zaniku/pojawieniu się nap. telefonicznego
LD HL,#80BE            @nic7b `
`#80BE - 1b stoperek blokady gen. zdarzenia #14 TPSA (poł. przychodzące)
`          aktywowany po zaniku/pojawieniu się nap. linii telefonicznej
`          oczywiście dłuższym niz pulsowe wybieranie numeru
`                gdy #00 to stoi =nie ma blokady,
`                gdy >0 to idzie i blokuje gen zdarzenia #14
`                     cyka co sekundę                          
LD A,(HL)                     `
AND A                         `
JR Z,@nic7c                   `
DEC A                         `\cyknij i zapisz stoperek
LD (HL),A                     `/blokady zdarzenia #14 -> pol. przychodzące
LD HL,(#88E3)          @nic7c `
`#88E3 -2b sekundy od ostatniego wykonania telefonu stacjonarnego
`          na alarmowy numer wraz z informacją foniczną z IDS1420 [1h = #0E10]
LD A,H                        `\
OR L                          `/czy =0?
JR Z,@nic7d                   `hop -> nie cykaj
DEC HL                        `
LD (#88E3),HL          @nic7d `zapisz
LD HL,#88C8                   `adr. Make_Call_TPSA /radialu/
LD A,(HL)                     `
AND A                         `
JR Z,@nic7e                   `hop -> stoi, nic nie rób
DEC A                         `
LD (HL),A                     `
JR NZ,@nic7e                  `hop -> idzie, wyjdź po cyknięciu
LD HL,#88A8                   `
LD A,(HL)                     `odczytaj Make_Call_TPSA
AND #91                       `\czy kwalifikuje się do Redial?
CP #11                        `/
JR NZ,@nic7e                  `wyjdź, bo nie kwalifikuje się do redial
LD A,(HL)                     `odczytaj Make_Call_TPSA
AND #F0                       `\
OR #08                        ` |ponowne zlecenie dzwonienia na TPSA
LD (HL),A                     `/
LD A,(#8803)           @nic7e `
`   #8803 -1b TimeGuard alarmowego wywoływania TPSA
AND A                         `
JR Z,@nic7f                   `
DEC A                         `
LD (#8803),A           @nic7f `
RET                           `
`---------------------------------
`
`cyka czasy trwania dzwonka i otwartych drzwi
` cyka czas trwania rozmowy TPSA, 
` cyka czas blokady ponownego zgłoszenia brąz alarmu
` cyka 5-cio sekundowy TimeGuard odbioru CID w TPSA
` cyka stoperek sekundowy braku napięcia 230V
`trwa: +698tkt
LD HL,(#86D6)          @LTm8_ `CTOD =czas trwania otwartych drzwi
BIT 7,H                       `
JR NZ,@nic8a                  `
INC HL                        `
LD (#86D6),HL          @nic8a `
LD HL,(#86D8)                 `CPZD =czas od ostatniego zamknięcia drzwi
BIT 7,H                       `
JR NZ,@nic8b                  `
INC HL                        `
LD (#86D8),HL          @nic8b `
LD HL,(#86DA)                 `czas trwania dzwonka
BIT 7,H                       `
JR NZ,@nic8c                  `
INC HL                        `
LD (#86DA),HL          @nic8c `
LD HL,(#86DC)                 `CPDZ =czas przerwy od ostatniego dzwonka
BIT 7,H                       `
JR NZ,@nic8d                  `
INC HL                        `
LD (#86DC),HL          @nic8d `
LD HL,#8738                   `adres sekund trwania rozmowy/dzwonka
INC (HL)                      `cyknij sekundy
LD A,(HL)                     `
CP #3C                        `
JR C,@nic8e                   `
SUB A                         `=0
LD (HL),A                     `sekundy trwania rozmowy/dzwonka
INC HL                        `adr. minut
INC (HL)                      `cyknij minuty
LD A,(HL)                     `
CP #3C                        `
JR C,@nic8e                   `
SUB A                         `=0
LD (HL),A                     `minuty trwania rozmowy/dzwonka
INC HL                        `adr. godzin
INC (HL)                      `cyknij godziny
BIT 7,(HL)                    `
JR Z,@nic8e                   `
LD (HL),#80                   `= &128 godzin i już nie cykaj
`#8738 -3b czas trwania dzwonka/rozmowy w sek/min/godz od 0 do &128 godzin potem nie idzie już
` #8738 -1b sekundy \
` #8739 -1b minuty  |
` #873A -1b godziny / od 0 do &127, gdy &128 (#80) tzn że przekroczył 127:59:59...
`---                           
LD HL,(#87FE)          @nic8e `tutaj stoperek gaszący po upływie
LD A,H                        `znacznik zgłoszenia zdarzenia brąz alarmu
OR L                          `
JR NZ,@n_c8g                  `
LD A,(#8800)                  `
AND A                         `
JR Z,@nic8g                   `
DEC A                         `
LD (#8800),A                  `
DEC HL                 @n_c8g `
AND A                         `
JR NZ,@nic8g                  `
LD A,H                        `
OR L                          `
JR NZ,@nic8g                  `
LD BC,#86D5                   `usterka/alarm
LD A,(BC)                     `
RES 0,A                       `gdy =1 to było już alarmowane o brąz alarmie
LD (BC),A                     `
LD (#87FE),HL          @nic8g `
`---                           
LD A,(#86F6)                  `czas 5 sekund na odbiór FSK CID
AND A                         `
JR Z,@nic8i                   `
DEC A                         `
LD (#86F6),A                  `
JR NZ,@nic8i                  `
` tutaj sprawdza, jeśli przeskoczył na 0 to wychodzi z podstanu oczekiwania na CID...
LD A,(#86F8)                  `
CP #04                        `czy to etap incomming ring?
JR NZ,@nic8i                  `
LD A,#0D                      `zakończ rozpoznanie FSK
LD (#86FB),A                  `
`---                           
LD HL,#872D            @nic8i `
`#872D -1b czas trwania braku napięcia w sekundach gdy =#00 to stoi
LD A,(HL)                     `
AND A                         `gdy =0 to stoi i nic nie blokuje
JR Z,@nic8j                   `
INC A                         `po przejściu #FF ma znów wrócić na #00 i zostać
LD (HL),A              @nic8j `
RET                           `
`---------------------------------
`
`    cyka stoper blokady zdarzenia brak nap. linii telefonicznej
`    cyka w każdej 16-ej sekundzie odebrany czas z DCF77, dla porównania 
`trwa +160tkt max              
LD HL,(#8804)          @LTm9_ `stoper 12 godzinnej blokady zdarzenia typu
LD A,H                        `brak napięcia na linii telefonicznej
OR L                          `
JR Z,@nic9a                   `
DEC HL                        `
LD (#8804),HL          @nic9a `
LD A,(#8004)                  `bieżąca sekunda
CP #10                        `cyka czasy wszystkich SMSów oczekujących na potwierdzenie
RET NZ `JR NZ,@nic9b                  `hop -> to nie &16 sekunda
`tutaj jest raz na minutę, w każdej &16 sekundzie cyka zegar względnego/próbnego DCF77
`dla oceny czy odebrane czasy z DCF77 są identyczne
`#88D0 -6b czas odczytany z DCF w naszym formacie, do porównania z kolejnym odczytanym
`          w celu akceptacji, kolejno min, godz, dnimca, mce, rok, dni-tyg
`          cykany przez zegar systemu raz na minutę (tylko minuty i godziny)
LD HL,#88D0                   `adr. minut
INC (HL)                      `cyknij minuty
LD A,(HL)                     `sprawdź minuty
CP #3C                        `czy minuty <&60
RET C `JR C,@nic9b                   `hop -> bez przeskoku godziny
LD (HL),#00                   `minuty =0
INC HL                        `adr. godzin
INC (HL)                      `cyknij godziny
RET                    `@nic9b `
`---------------------------------
`
`jest tutaj 2 razy w sekundzie [f(uł.sek)]
`procedura analiz wolnych i długotrwałych
`np. analizy zasięgu GSM
`trwa +1312tkt max                
LD A,(#807C)              @2razS `poziom bieżący
`#807C -> 1b poziom sygnału GSM i stan komunikacji mbus 
`                                   #00 to brak komunikacji z tel.
`                                   #01 to poziom GSM odpowiadający 0 kresek na wyśw. NOKIA
`                                   #02-#05 to poziom GSM odpowiadający 1-4 kresek na wyśw. NOKIA
`#80B4 -2b licznik sekundowy =#0000 lub 15bit=1 to stoi, 
`                     else idzie ->licznik pozytywnego poziomu GSM
`#80B6 -3b licznik sek/min/godz braku poziomu GSM, stoi gdy 7bit sek =1 else idzie
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM:
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
`         bit5: =0 nic, =1 
`         bit4: =0 nic, =1 
`         bit3: =0 nic, =1 
`         bit2: =0 nic, =1 
`         bit1: =0 nic, =1 
`         bit0: =0 nic, =1 
`#80BA -3b czas najdłuższego braku sygnału GSM
CP #02                           `
LD HL,#80B9                      `adres wskaźników
JR C,@brGSM                      `hop -> brak poziomu GSM
BIT 7,(HL)                       `czy był przyjęty?
SET 7,(HL)                       `ustaw że przyjęty pozytywny
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
JR NZ,@GSafW                     `hop -> był przyjęty, wstępna analiza ok
LD DE,(#80B7)                    `czas braku sygnału GSM    \tylko min/godz
LD HL,(#80BB)                    `max. czas braku sygn. GSM /
`AND A                           `\
SBC HL,DE                        `/max - ostatni
JR NC,@GSnoM                     `hop -> nie większy od maksymalnego
LD (#80BB),DE                    `zapisz maksymalny min/godz
LD A,(#80B6)                     `\
LD (#80BA),A                     `/sek też
LD HL,#80B6               @GSnoM `\
SET 7,(HL)                       ` \zeruj i zatrzymaj licznik braku sygnału
LD HL,#0000                      ` /
LD (#80B7),HL                    `/
LD HL,#0001                      `\
LD (#80B4),HL                    `/startuj licznik pozytywnego sygnału
JR @GSafW                        `hop -> wstępna analiza ok
BIT 7,(HL)                @brGSM `brak poziomu GSM, czy był przyjęty
RES 7,(HL)                       `ustaw że przyjęty brak sygnału
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
JR Z,@GSafW                      `hop -> był przyjęty brak, wstępna analiza ok
LD HL,#0000                      `\
LD (#80B4),HL                    `/zeruj i zatrzymaj licznik sygnału pozytywnego
LD HL,#0000                      `\
LD (#80B6),HL                    ` |startuj licznik braku sygnału
LD (#80B7),HL                    `/
`wstępna analiza ok               
LD DE,(#80B7)             @GSafW `czas braku poziomu GSM: E=min, D=godz
LD HL,#0A00                      `=&10 minut 
AND A                            `\
SBC HL,DE                        `/10min - bieżący czas braku
LD HL,#80B9                      `adres wskaźników
JR NC,@no10m                     `hop -> mniej niż 10 minut
SET 6,(HL)                       `zaznacz że brak >10 minut
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
LD DE,(#80B4)              @no10m `czas trwania sygnału GSM
LD HL,#0258                      `=&10 minut w sekunach =&600 sekund
AND A                            `\
SBC HL,DE                        `/10min - bieżący czas trwania
LD HL,#80B9                      `adres wskaźników
RET NC                           `ret -> mniej niż 10 minut
BIT 6,(HL)                       `czy brak był >10 minut
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
RET Z                            `ret -> nie było braku powyżej 10min
RES 6,(HL)                       `kasuj znacznik
`                                  
` tutaj trzeba by jakąś inteligentną procedurkę, aby nie wypsztykał się na brakach zasięgu
`                                  
LD BC,#0B0B                      `długość, IDkod=(#0B) brak sygnału GSM
CALL @_PZD_                      `+17+712tkt ->wykonaj reakcję na podzdarzenie Brej
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres roku
JR NC,@nzpGS                     `hop -> nie zakwalifikowano do zapisu
INC HL                           `adr za rokiem
LD A,(#80BA)                     `sek      \
LD (HL),A                        `sek       \
INC HL                           `           \  tutaj 
LD DE,(#80BB)                    `min/godz    | dodaj 3bajty czasu
LD (HL),E                        `min        /  max. zaniku GSM
INC HL                           `          /
LD (HL),D                        `godz     /  
LD HL,#0000               @nzpGS `\
LD (#80BA),HL                    ` |zeruj max czas braku GSM
LD (#80BB),HL                    `/
RET                              `
`---------------------------------
` 
` <<<<<<<<<<<<<<<< dotąd tylko kernelNOKIA >>>>>>>>>>>>>>>>>>
`                                                             
` poniżej wypisane etykiety będą wykazywane jako niezdefiniowane po odcięciu reszty
` od kernela, poniważ są odpowiedzialne za:
`@wsad+ -> reset części dodanej
`@TPSA_ -> analiza all do telefou stacjonarnego 
`@analB -> analizuj i rozpoznawaj wstępnie ton 420Hz i trochę dla brąza
`@Dcf77 -> realizuje całość DCF77
`@DorGo -> analizuj brąz linię pod kątem /dzwonek/drzwi/alarm/ też usterkę
`@ts230 -> sprawdzenie obecności 230V i generacja odpow. zdarzeń
` oraz:   
`@SMSsp ->do generacji SMSów specjalnych
` a także procedury związane z obsługą LOGu:
`@DzZda -> realizacja SMSów jeśli są nowe zdarzenia w LOGu
`@RLoRa (i @RLoRz) -> sprawdzenie i zerowanie LOGu
`@_PZD_ -> zapisanie zdarzenia do LOGu
`@MkSAI -> ustawianie odpowiedniej siatki dla profilu LOGu
`@%_LOG -> obliczanie wskaźnika zapełnienia LOGu dla blueLED
`
`trzeba także powywalać wywołania z następujących procedur:
` z @_tme0
`-------
` @TPSA_ 
` @analB 
` @Dcf77 
` @DorGo 
` @ts230 
` oraz niektóre procedury z tabeli @LTime
`
` z @_tme1
`-------
` /?/ @RS_PC -obsługa RS232 z komputerem
` /zostaje/ obsłuż wyświetlacz LCD
` /zostaje/ obsłuż diody LED
` /zostaje/ @2lLCD czyli obsługa zapełniania IIgiej linijki LCD
` @2razS czyli analiza zasięgu poziomu GSM i generacja zdarzeń
`
` zaś @_tme2 jest pusty i można go wykorzystać
`-------
` pusty -do wykorzystania
`
` oprócz oprócz jest jeszcze sprawa stoperów sekundowych w Ltim, które trzeba wyłączyć:
`DEFTABE LTm7_
`DEFTABE LTm8_
`DEFTABE LTm9_
`---------------------------------
`
`===========================================================================
`========= procedury do obsługi LOGu =======================================
`===========================================================================
` 
`---------------------------------
`
`procedura rezerwacji obszaru na zdarzenie w RAM LOGu
` sprawdza czy zdarzenie o zadanym kodzie ma być zapisane w logu, 
` jeśli tak to zapisuje oraz w wersji skompresowanej także czas
`wejście: Brej =l.bajtów zdarzenia (wraz z 2-ma bajtami długości)
`         Crej =ID (kod) zdarzenia,
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres roku
`trwa +718tkt ++++++++++++25tkt ----13tkt max  
LD A,C                    @_PZD_ `kod podzdarzenia do logu
RRCA                             `\
RRCA                             ` | div 8
RRCA                             `/
AND #07                          `wyzeruj niepotrzebne bity
LD E,A                           `\
LD D,#00                         `/delta adresu
LD HL,(#88CA) `#8518             `adr. matrycy dla LOGu
ADD HL,DE                        `oblicz adres bajtu -klucza
LD A,#01                         `zapalony tylko bit0
BIT 2,C                          `czy *4 =0?
JR Z,@ni2bC                      `hop -> *4=zero
RLCA                             `\
RLCA                             ` |
RLCA                             ` |*4
RLCA                             `/
BIT 1,C                   @ni2bC `czy *2 =0?
JR Z,@ni1bC                      `hop -> *2=zero
RLCA                             `\
RLCA                             `/*2
BIT 0,C                   @ni1bC `czy *1 =0?
JR Z,@ni0bC                      `hop -> *1=zero
RLCA                             `*1
AND (HL)                  @ni0bC `+586tkt sprawdź szukany bit w kluczu
` Z  -> bit =0 więc nie zapisuj tego zdarzenia do LOGu
` NZ -> bit =1 więc zapisz zdarzenie do LOGu
RET Z                            `NC = brak =nie zakwalifokowano do zapisania
LD A,(#8FFF)                     `zapisz podzdarzenie do logu/SMSów
AND A                            `
JR Z,@RRLfr                      `hop -> zdarzenie zmieści się przed górną granicą LOG RAMu
DEC A                            `-1 (aby nie gdy były by równe)
SUB B                            `max - dł.zdarzenia
JR NC,@RRLfr                     `hop -> zdarzenie zmieści się przed górną granicą LOG RAMu
LD HL,#9000                      `początek RAM LOGu
LD (#8FFD),HL                    `zapisz do WOLNEGO
SUB A                            `=#00
LD (#8FFF),A                     `=#00 czyli dużo wolnych bajtów
LD HL,#8FF4                      `\zapal bit Pre_Over_LOG
SET 7,(HL)                       `/
LD HL,(#8FFD)             @RRLfr `+492tkt adres gdzie zapisujemy zdarzenie
LD (HL),B                        `bajt długości (a)
INC HL                           `adr. dla bajtu ID
LD (HL),C                        `ID zdarzenia
INC HL                           `adr. dla bajtu sekund
PUSH HL                          `zapamiętaj dla procedury zewnętrznej adr. kodu zdarzenia
LD D,#00                         `
LD E,B                           `długość w bajtach całego zdarzenia
DEC E                            `\
DEC E                            `/-2 te na początku
ADD HL,DE                        `obl. adres za zdarzeniem
LD (#8FFD),HL                    `zapamiętaj dla kolejnego zdarzenia
LD (HL),#00                      `długość następnego
DEC HL                           `zapisz bajt długości (g)
LD (HL),B                        `
LD DE,#F7FF                      `ostatni bajt LOG RAMu
EX DE,HL                         `
AND A                            `NC
SBC HL,DE                        `ostatni bajt - (pierwszy wolny-1) =liczba bajtów
LD A,H                           `
AND A                            `
LD A,L                           `tyle właśnie wolnych bajtów gdy H=#00
JR Z,@duzeC                      `hop -> L wolnych bajtów
SUB L                            `=#00 oznacza więcej niż #FF wolnych bajtów
LD HL,(#8FFB)             @duzeC `+309tkt PIERWSZY_ZA_OSTATNIM
LD DE,(#8FFD)                    `WOLNY
SBC HL,DE                        `CY/NC z [(PIERWSZY_ZA_OSTATNIM)-(WOLNY)]
JR NC,@finRL                     `hop -> nie trzeba popchnąć
EX DE,HL                         `HL := WOLNY
LD (#8FFB),HL                    `PIERWSZY_ZA_OSTATNIM := WOLNY
LD (#8FFF),A              @finRL `+231tkt
POP HL                           `odtwórz adres ID (kod) tego zdarzenia
LD DE,(#8004)                    `E=sekundy, D=minuty
LD (HL),E                        `
INC HL                           `
LD (HL),D                        `
INC HL                           `
LD DE,(#8006)                    `E=godziny(#00..#1F), D=dni m-ca(#00..#1F)
LD A,(#8001)                     `Status Time (#00..#07)
RRCA                             `\
RRCA                             ` |przesuń na pozycję bitów7..5
RRCA                             `/
OR E                             `dopisz do godzin
LD (HL),A                        `
INC HL                           `
LD A,(#800A)                     `dni tygodnia (#00..#07)
RRCA                             `\
RRCA                             ` |przesuń na pozycję bitów7..5
RRCA                             `/
OR D                             `dopisz do dni miesiąca
LD (HL),A                        `
INC HL                           `
LD DE,(#8008)                    `E=miesiące(#00..#0F), D=rok
LD (HL),E                        `tu można by coś dopisać, np. klasyfikację i gotowość
`INC HL                           `
`LD (HL),D                        `
SCF                              `CY=zapisano zdarzenie
RET                              `zakończono, HL =adres roku
`------------------------------------
`
`sprawdza czy wartość adresu z HL mieści się w granicach RAM_LOGu
`wyjście NC- ok, CY -> poza granicami
`trwa: +tkt
LD L,E                    @ckZRL `\zapamiętaj w DE
LD D,H                           `/
LD BC,#9000                      `\
AND A                            ` |czy nie poniżej dolnej granicy
SBC HL,BC                        `/
RET C                            `-> CY error
LD HL,#F7FF                      `
SBC HL,DE                        `
RET                              `NC -ok, CY-> error
`------------------------------------
`
`reset RAM_LOGu sprawdza czy poprawny, jak nie to zeruje zmienne
`trwa: +tkt
LD HL,(#8FF9)             @RLoRa `adr. pierwszego bajtu za ostatnim zrealizowanym zdarzeniem
CALL @ckZRL                      `sprawdź czy mieści się w zakresie 
JR C,@RLoRz                      `hop -> zeruj zmienne RAM_LOGu
LD HL,(#8FFB)                    `adr. pierwszego bajtu ZA ostatnim zapisem przed górną granicą logu
CALL @ckZRL                      `sprawdź czy mieści się w zakresie 
JR C,@RLoRz                      `hop -> zeruj zmienne RAM_LOGu
LD HL,(#8FFD)                    `adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
LD A,(HL)                        `bajt za ostatnim wpisem powinien być =#00
AND A                            `czy = #00 ?
JR NZ,@RLoRz                     `hop -> zeruj zmienne RAM_LOGu
PUSH HL                          `zachowaj
CALL @ckZRL                      `sprawdź czy mieści się w zakresie 
POP HL                           `odtwórz
JR C,@RLoRz                      `hop -> zeruj zmienne RAM_LOGu
PUSH HL                          `zachowaj
LD A,(#8FFF)                     `długość w bajtach do końca (lub #00)
LD E,A                           `\
LD D,#00                         ` |dodaj czy długość dobra
ADD HL,DE                        `/
CALL @ckZRL                      `sprawdź czy mieści się w zakresie 
POP HL                           `odtwórz
JR C,@RLoRz                      `hop -> zeruj zmienne RAM_LOGu
DEC HL                           `adres za -1 to długość ostatniego
LD A,(HL)                        `długość 'druga' ostatniego
LD E,A                           `\
LD D,#00                         `/długość w 16bitach
AND A                            `\
SBC HL,DE                        ` |obl adres długości 'pierwszej'
INC HL                           `/
CP (HL)                          `czy taka sama jak druga?
JR NZ,@RLoRz                     `hop -> zeruj zmienne RAM_LOGu
LD HL,(#8FF9)                    `adr. [DO_REALIZACJI] pierwszego bajtu za ostatnim zrealizowanym 
`                                 zdarzeniem używany tylko przez CPU w czasie realizacji zdarzeń,
`                                 zerowany gdy RESET i syf, ew. przesuwany za zdarzenie po 
`                                 jego realizacji
LD B,#0A                         `do &10 zdarzeń sprawdza (coby nie zbyt długo)
EX DE,HL                  @nxZDc `adr. do DE
LD HL,(#8FFD)                    `adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
AND A                            `NC
SBC HL,DE                        `adresy równe -> ok
RET Z                            `ret -> RAM_LOG poprawny, nie wymaga zerowania zmiennych
LD A,(DE)                        `odczytaj długość
LD L,A                           `\
LD H,#00                         `/
ADD HL,DE                        `obl. adres następnego
DJNZ @nxZDc                      `pętla -> sprawdź następne zdarzenie
`   tutaj jest gdy odstęp pomiędzy 'do realizacji' a 'wolny' jest większy niż &10 zdarzeń
`   tutaj error -> więc resetuj zmienne RAM_LOGu
LD HL,#9000               @RLoRz `zeruj zmienne RAM_LOGu
LD (#8FFD),HL                    `adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
SUB A                            ` = #00 -> NC
LD (HL),A                        `długość=0 => brak zdarzenia
LD (#8FF9),HL                    `adr. pierwszego bajtu za ostatnim zrealizowanym zdarzeniem
LD (#8FFB),HL                    `adr. pierwszego bajtu ZA ostatnim zapisem przed górną 
`                                 granicą logu podbijany przez WOLNY
`     LD L,#09 `LD HL,#9009      `i tak pierwszym zdarzeniem będzie RESET!
LD (#8FF7),HL                    `adr. [DO_ODCZYTANIA]
LD (#8FFF),A                     `max. długość zdarzenia do zapisu lub #00
LD (#8FF4),A                     `bity OVER_LOG i PRE_OVER_LOG
LD L,A                           `\
LD H,A                           `/=LD HL,#0000
`#8EFC - 2b licznik 'absolutny' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
LD (#8EFC),HL                    `\
LD (#8EFE),HL                    `/zerowanie liczników wiadomości przyjętych do DzZd
RET                              `NC
` po wyjściu z @RLoRz musi być NC !
`---------------------------------
`
`oblicza procentową zajętość RAM_LOGu, wynik w (#8FF4)
`trwa: +257tkt max (gdyby był RET) ----
`      +473tkt max gdy jest JR @LED_B ----
LD A,(#8FF4)              @%_LOG `bitY 7 i 6 czyli (PRE_OVER_LOG i OVER_LOG)
LD DE,(#8FF7)                    `DO_ODCZYTANIA #9000
LD HL,(#8FFD)                    `WOLNY         #
AND A                            `
SBC HL,DE                        `WOLNY - DO_ODCZYTANIA 
JR NC,@%lo_2                     `hop -> WOLNY > DO_ODCZYTANIA
LD HL,#F7FF                      `koniec_logu
AND A                            `
SBC HL,DE                        `koniec_logu - do_odczytania 
LD DE,(#8FFD)                    `wolny                       
ADD HL,DE                        `koniec_logu - do_odczytania +wolny 
LD DE,#9000                      `początek_logu
AND A                            `
SBC HL,DE                        `koniec_logu - do_odczytania + wolny - początek_logu
`SET 7,A                          `ustaw PRE_OVER_LOG /jest ustawiany przez @_PZD_/
JR @%lo_3                        `
BIT 7,A                   @%lo_2 `+87 czy ustawiony PRE_OVER_LOG ?
JR NZ,@%lo_4                     `hop -> ustawiony
LD L,A                    @%lo_3 `+62 bity OVER_LOG i PRE_OVER_LOG
LD A,H                           `wynik
RRCA                             `div 2
AND #3F                          `tylko bity procentowej zajętości
LD H,A                           `+43
LD A,L                           `bity OVER_LOG i PRE_OVER_LOG
AND #C0                          `tylko bity 7 i 6 (OVER_LOG i PRE_OVER_LOG)
OR H                             `dopisz procentową zajętość logu
LD (#8FF4),A              @%lo_5 `zapisz bity i wartość zapełnienia logu
JR @LED_B `RET                   `
SET 6,A                   @%lo_4 `ustaw OVER_LOG 
JR @%lo_5                        `
`---------------------------------
`
`oblicza sposób zachowania LED Blue w zależności od procenta zapełnienia LOG_RAM
`trwa +215tkt max ++
LD HL,(#8FF7)             @LED_B `
`#8FF7- 2b -[DO ODCZYTANIA] adr. wykorzystywany tylko przez PC i ustawiany tylko przez PC,
`                ew. zerowany przez RESET gdy syf w logu
`                zmieniany tylko gdy syf po RESET lub podbijany przez WOLNY
`#8FFD- 2b -[WOLNY] adr. pierwszego wolnego bajtu w logu do zapisu zdarzenia
LD DE,(#8FFD)                    `
AND A                            `
SBC HL,DE                        `
LD B,#05                         `
LD A,(#8FF4)                     `
JR NZ,@daLEj                     `hop-> różne, a więc poziomy #00..#04
BIT 6,A                          `bit7 -> OVER_LOG gdy =1
JR Z,@LEdBg                      ` ->5 /bardzo dobrze/
DEC B                     @daLEj `
AND #7F                          `bez bitu PRE_OVER_LOG [100% = #67FF -> #33 -> &51]
LD B,#04                         `
CP #19                           ` #19 = &25 -> 49% 
JR C,@LEdBg                      ` ->4 /dobrze/
DEC B                            `
CP #26                           ` #26 = &38 -> 74%
JR C,@LEdBg                      ` ->3 /znośnie/
DEC B                            `
CP #2D                           ` #2D = &45 -> 88%
JR C,@LEdBg                      ` ->2 /kiepsko/
DEC B                            `
CP #31                           ` #31 = &49 -> 96%
JR C,@LEdBg                      ` ->1 /źle/
DEC B                            `=0   /bardzo źle/
LD A,B                    @LEdBg `
LD (#8FF3),A                     `wskaźnik 'kierujący' sposobem świecenia LED_BLUE
RET                              `
`---------------------------------
`
`uaktualnia siatki bieżące w/g profilu
`trwa +242tkt max                    
LD HL,#8559               @MkSAI `procedura utworzenia siatek dla info i alarmu 
LD A,(HL)                        `
AND #7F                          `odrzuć bit 'priorytet INFORMACJA'
CP #0E                           `w RAM na podstawie bajtów konfigu informacji i alarmów z konfigu
LD L,#18 `LD HL,#8518            `siatka MISC dla LOG, info i alarmu z konfigu
JR NC,@AIntL                     `hop -> wybierz tą bo to MISC
ADD A,A                          `\ 28
ADD A,A                          ` |56
ADD A,A                          ` |112
LD E,A                           `  \
LD D,#00                         `  /
LD HL,@EVia_                     `adr. siatek #01-#07 w RAM
ADD HL,DE                        `adr. +8
ADD HL,DE                        `adr. +16
ADD HL,DE                        `adr. +24 =adr. siatki dla odp. profilu
LD (#88CA),HL             @AIntL `siatka zapisu do LOGu i analiza
LD E,#08 `LD DE,#0008            `8 bajtów 
ADD HL,DE                        `
LD (#88CC),HL                    `+64tkt info
`LD DE,#0008                      `8 bajtów 
ADD HL,DE                        `
LD (#88CE),HL                    `alarm
RET                              `
`----------------------------------
`
DEFETYK @EVia_ `konfiguracja klasyfikacji poszczeg. zdarzeń w zależn od konfigu
`     konfig >=#0F to klasyfikacja zaawansowana (umieszczona w SIM ->konfigu)
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `LOG   \        |czyli wszystko do LOGu
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `info  |dla #00 |nic na SMS
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `LOG   \         |czyli wszystko do LOGu
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `info  |dla #01  |wszytsko na SMS jako info
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `LOG   \        |czyli do LOGu wszystko prócz
DEFBAJT1 #F7 #FF #99 #00 #00 #00 #00 #00 `info  |dla #02 |kilku telefonicznych,
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |na SMS drzwi, TPSA po fakcie i awaryjne
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `LOG   \         |czyli do LOGu wszystko prócz
DEFBAJT1 #F7 #FF #99 #00 #00 #00 #00 #00 `info  |dla #03  |kilku telefonicznych,
DEFBAJT1 #30 #04 #00 #00 #00 #00 #00 #00 `alarm /         |na SMS drzwi, TPSA po fakcie i awaryjne
`                                                         |ALARM gdy drzwi lub brąz!
DEFBAJT1 #FF #FF #FF #00 #00 #00 #00 #00 `LOG   \        |czyli sprawdzenie układu
DEFBAJT1 #03 #FC #01 #00 #00 #00 #00 #00 `info  |dla #04 | RESETy, zaniki GSM, odłączenie 230V
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |odłączenie telefonu...
` dalej jeszcze hućpa                                      
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \         |
DEFBAJT1 #31 #EB #98 #00 #00 #00 #00 #00 `info  |dla #05  |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \        |
DEFBAJT1 #10 #04 #8C #00 #00 #00 #00 #00 `info  |dla #06 |tylko drzwi i po telefonie
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \         |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `info  |dla #07  |nic nie wysyła!
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #08 |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #09  |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #10&|
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #11& |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #12&|
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #13& |
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /         |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \        |
DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #14&|
DEFBAJT1 #00 #00 #00 #00 #00 #00 #00 #00 `alarm /        |
`DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `LOG   \
`DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `info  |dla #15& jest MISC w konfigu
`DEFBAJT1 #FF #FF #FF #FF #FF #FF #FF #FF `alarm /
`---------------------------------
`
`sprawdza czy są nowe zdarzenia w LOGu i ew. je wykonuje,
` do momentu aż nie ma nowych zdarzeń lub error w LOGu
`trwa /poza NMI/
CALL @MkSAI               @DzZda `odświerz adresy siatek LOG, alarm, informacja
LD HL,(#8FF9)                    `odczytaj adres za ostatnim zrealizowanym
`#8FF9- 2b -adr. pierwszego bajtu za ostatnim zrealizowanym zdarzeniem
`                używany tylko przez CPU w czasie realizacji zdarzeń,
`                zerowany gdy RESET i syf, ew. przesuwany za zdarzenie po jego realizacji
LD A,(HL)                        `wartość bajtu
AND A                            `czy =#00 ?
JR NZ,@jeZda                     `hop -> bo jest zdarzenie do realizacji
LD DE,(#8FFD)                    `adr. "WOLNY"
SBC HL,DE                        `jeśli równe, to rzeczywiście nie ma nic do zrobienia
RET Z                            `równe -> rzeczywiście nic nie ma
` tutaj różne, a więc może być albo przejście na początek LOGu, albo
` zostało zdarzenie nadpisane w czasie 'pomiędzy' powyższymi rozkazami
` zaraz to sprawdzimy, jeszcze raz dla pewności
JR C,@DzZda `RET C               `DE > HL a więc nie przeskok, tylko dopisano zdarzenie
LD HL,#9000                      `\
LD (#8FF9),HL                    ` |przechodzimy na początek Dziennika Zdarzeń
JR @DzZda `RET                   `/ bo nowe zdarzenia są już na początku
PUSH HL                   @jeZda `adr. w zdarzeniu długości pierwszej zdarzenia
LD C,(HL)                        `długość przed
LD B,#00                         `
ADD HL,BC                        `
LD E,L                           `\adres za zdarzeniem
LD D,H                           `/
DEC HL                           `
LD A,(HL)                        `długość za
CP C                             `
POP HL                           `adr. w zdarzeniu długości pierwszej zdarzenia
JR NZ,@dł<>d                     `hop -> długości na początku i na końcu różne czyli ERROR
` tutaj równe długości, sprawdzimy czy nie mniejsze niż minimalna
CP #08                           `
JR NC,@dł=dł                     `hop -> równe długości, poprawnej wartości
` tutaj error, trzeba by chyba zresetować Dziennik Zdarzeń
LD A,(#8000)              @dł<>d `
AND #7F                          `\
LD (#8000),A                     `/wyłącz przerwania
`#8000 -> bity systemowe:         
` bit7 -> =0 to zablokowana obsługa przerwań NMI
PUSH AF                          `
CALL @RLoRz                      `
POP AF                           `
OR #80                           `\
LD (#8000),A                     `/włącz przerwania
RET                              `
PUSH HL                   @dł=dł `adr. w zdarzeniu długości pierwszej zdarzenia
LD C,#06  `LD BC,#0006           `
ADD HL,BC                        `
BIT 7,(HL)                       `
JR Z,@noBus                      `hop -> zapis gotowy /nie czeka na uzupełnienie/
PUSH HL                          `zachowaj adres klasyfikacji
LD HL,#8003                      `\adr. ułamka sekund
LD C,(HL)                        ` \
LD A,(HL)                 @L1/2s `  \
XOR C                            `   \
BIT 7,A                          `    | ` poniżej eksperymantalny delay 0,5...1[s]
JR Z,@L1/2s                      `jeśli 7bit uł. sekund nie zmienił wartości to czekaj
LD C,(HL)                        `    |
LD A,(HL)                 @H1/2s `   /
XOR C                            `  /
BIT 7,A                          ` /
JR NZ,@H1/2s                     `jeśli 7bit uł.sek. nie zmienił znów wart. to czekaj
` minęło delay od 0,5 do 1 [s]    
POP HL                           `odtwórz adres klasyfikacji
BIT 7,(HL)                       `
JR NZ,@wcBus                     `hop -> ciągle zajęte, potraktuj jakby było już 
`                                        sklasyfikowane, czyli omiń
LD A,(HL)                 @noBus `
AND #60                          `tylko klasyfikacja lub jej brak
POP HL                    @wcBus `odtwórz adres zdarzenia /pierwsza długość/
JR Z,@zrbZd                      `
LD (#8FF9),DE                    `zapisz adres za zdarzeniem, bo albo już wykonane (sklasyfik.),
`                                 albo nie doczekano się na uzupełnienie zdarzenia
JR @DzZda                 @DzZd2 `
PUSH HL                   @zrbZd `sprawdzone, zrób je po sklasyfikowaniu
CALL @ZdaHL                      `
POP HL                           `
RET C                            `wyjdź, bo nie zrobiono zadania
LD C,(HL)                        `
LD B,#00                         `
ADD HL,BC                        `
LD (#8FF9),HL                    `zapisz adres za zdarzeniem
LD HL,(#8EFC)                    `\
INC HL                           ` \
LD (#8EFC),HL                    `  \ cyknij duży i mały
LD HL,(#8EFE)                    `  / licznik zdarzeń
INC HL                           ` /
LD (#8EFE),HL                    `/
JR @DzZd2 `RET                   `po zdarzeniu /czy jeszcze jakieś zdarzenia?/
`---------------------------------
`
`wykonaj klasyfikację zdarzenia z adresu HL    
`trwa /poza NMI/                  
`              w Acc mamy klasyfikację: #20 (CY) to uzupełnienie,
`                                       #40 (NC) informacja
`                                       #60 (NC) alarm
INC HL                    @ZdaKl `po inc adr. kodu zdarzenia
LD C,(HL)                        `kod zdarzenia
LD A,C                           `ID kod zdarzenia
RRCA                             `\
RRCA                             ` | div 8
RRCA                             `/
AND #07                          `
LD E,A                           `\delta adresu w masce info/alarm
LD D,#00                         `/
LD A,#01                         `zapalony tylko bit0
BIT 2,C                          `czy *4 =0?
JR Z,@nI2bC                      `hop -> *4=zero
RLCA                             `\
RLCA                             ` |
RLCA                             ` |*4
RLCA                             `/
BIT 1,C                   @nI2bC `czy *2 =0?
JR Z,@nI1bC                      `hop -> *2=zero
RLCA                             `\
RLCA                             `/*2
BIT 0,C                   @nI1bC `czy *1 =0?
JR Z,@nI0bC                      `hop -> *1=zero
RLCA                             `*1
LD B,A                    @nI0bC `szukany bit =1, pozostałe =0
` DE=delta do adresu, Brej ma zapalony bit odp. danemu zdarzeniu
LD HL,(#88CE)                    `dla alarmu
ADD HL,DE                        `
LD A,(HL)                        `
AND B                            `szukany bit klucz
LD A,#60                         `wartość dla alarmu
RET NZ                           `ret -> to alarm
LD HL,(#88CC)                    `dla informacji
ADD HL,DE                        `
LD A,(HL)                        `
AND B                            `szukany bit klucz
LD A,#40                         `wartość dla informacji
RET NZ                           `ret -> to informacja
LD A,#20                         `wartość dla uzupełnienia
SCF                              `
RET                              `
`---------------------------------
`
`wykonuje wszystko co potrzeba w reakcji na zdarzenie z LOGu o odresie (HL),
`klasyfikuje je i wysyła SMSa lub dzwoni TPSA
`wyjście: NC =zakończono reakcję na zdarzenie
`         CY =nie zakończono reakcji na zdarzenie /tylko gdy brak zasięgu!/
`trwa /poza NMI/
PUSH HL                   @ZdaHL `adres w LOGu
CALL @ZdaKl                      `sklasyfikuj zdarzenie (HL)
POP HL                           `\adres w LOGu
PUSH HL                          `/
PUSH AF                          `klasyfikacja bieżącego zdarzenia
CALL @ZroTx                      `wykonaj text opisu zdarzenia do bufora SMSa
POP AF                           `klasyfikacja bieżącego zdarzenia
LD L,A                           `wstępnie: klasyfikacja bieżącego zdarzenia
LD H,#00                         `wstępnie: brak reakcji SMS/TPSA na bieżące zdarzenie
LD C,A                           `klasyfikacja bieżącego zdarzenia
LD (#8801),HL                    `zapisz tmp
JR C,@finZD                      `hop -> finalizuj zdarzenie /zapisz klasyfikację i RET/ 
`                                        bo to UZUPEŁNIENIE              
LD A,(#80B9)                     `tu ALARM lub INFORMACJA, 
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit7: =0 nic, =1 przyjęty pozytywny poziom
BIT 7,A                          `czy mamy zasięg GSM?
JR NZ,@yesGS                     `hop -> jest zasięg
` tutaj brak zasięgu              
LD A,C                    @ifLAR `klasyfikacja bieżącego zdarzenia
CP #60                           `
JR NZ,@nforI                     `hop -> to informacja
` to alarm, brak zasięgu GSM, rób alarm przez TPSA
LD HL,(#88E3)             @stLAR `zrób larum na stacjonarnym
`#88E3 -2b sekundy od ostatniego wykonania telefonu stacjonarnego
`          na alarmowy numer wraz z informacją foniczną z IDS1420 [1h = #0E10]
LD A,H                           `\czy czas blokady 
OR L                             `/  larum stacjonarnego =0?
JR NZ,@finZD                     `hop -> nie rób larum bo było ostatnio
LD HL,#0E10                      `czas 1h co jaki może być robione larum ze stacjonarnego
LD (#88E3),HL                    `zapisz
LD A,#C0                         `\tmp. próbowano połączenia TPSA
LD (#8802),A                     `/
` tutaj zrób zlecenie wykonania telefonu stacjonarnego na dany numer
` ponieważ w oczekiwanym czasie nie został dostarczony żaden z wysłanych SMSów alarmowych
CALL @ALdTP                      `wykonaj alarmowanie foniczne przez TPSA
JR @finZD                        `hop -> zakończ obsługę zdarzenia
LD A,C                    @yesGS `klasyfikacja bieżącego zdarzenia
PUSH BC                          `
CP #60                           `czy to alarm?
JR Z,@laRmm                      `hop -> to alarm
`!`#8559 -1b profil ustalający siatkę zdarzeń generujących alarm/informację (0...&15)
`!`       AND #0F oczywiście, siatka >#0E to siatka z SIM =MISC=
`!`       bit7=0  ='priorytet ALARM'
`!`           =1  ='priorytet INFORMACJA'
LD A,(#8559)                     `\ustal czy INFORMACJA jest priorytetem
BIT 7,A                          `/
LD A,(#855D)                     `numery na które wysyłamy SMSem INFORMACJĘ
JR NZ,@laRm2                     `hop -> priorytet INFORMACJA
CALL @SMd8N                      `wyślij SMSa na wyznaczone numery, ale tylko pod warunkiem
`                                 że otrzymały wcześniejsze delivery
JR @poSL8                        `
LD A,(#855C)              @laRmm `numery na które wysyłamy SMSem ALARM
CALL @SMb8N               @laRm2 `wyślij SMSa na wyznaczone numery, niezależnie od tego
`                                 czy otrzymały delivery
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
`   Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
LD (#8802),A              @poSL8 `
`  #8802 -1b wstępnie jak zareagowano na zdarzenie z LOGu
POP BC                           `
JR Z,@ifLAR                      `hop -> nie wysłano na żaden
LD A,C                           `klasyfikacja bieżącego zdarzenia
CP #60                           `czy to alarm?
JR NZ,@finZD                     `hop -> kończ obsługę zdarzenia
CALL @ALdlv                      `sprawdź, czy dostarczono którykolwiek SMS
JR C,@stLAR                      `hop ->nie dostarczono na żaden
LD HL,(#80B7)             @nforI `
LD A,H                           `\
OR L                             `/
JR Z,@waiZD                      `hop -> zasięgu brak poniżej 1 minuty
LD A,(#8559)                     `
BIT 7,A                          `
`       bit7=0  ='priorytet ALARM'
`           =1  ='priorytet INFORMACJA'
JR Z,@finZD                      `hop -> priorytet ALARM, więc olej to
SCF                       @waiZD `CY =nie zrealizowano zadania
POP HL                           `
RET                              `priorytet 'INFORMACJA', nie możesz olać, czekaj na zasięg
POP HL                    @finZD `finalizuj zdarzenie /zapisz klasyfikację i RET/
INC HL                           `
INC HL                           `
INC HL                           `+#03 /tutaj dopisz wykonanie/
LD A,(HL)                        `
AND #3F                          `zostaw minuty
LD B,A                           `
LD A,(#8802)                     `wstępnie jak zareagowano na zdarzenie z LOGu
AND #C0                          `zostaw tylko wykonanie
OR B                             `minuty
LD (HL),A                        `zapisz
INC HL                           `
INC HL                           `
INC HL                           `+#06 /tutaj dopisz klasyfikację/
LD A,(HL)                        `
AND #1F                          `zostaw miesiące i bit4 (na future)
LD B,A                           `
LD A,(#8801)                     `wstępnie jak sklasyfikowano zdarzenie z LOGu
AND #60                          `zostaw tylko klasyfikację
OR B                             `miesiące
LD (HL),A                        `zapisz
` utwórz z tekstu SMSa tekst dla LCD
SUB A                            `\
LD (#88E5),A                     `/=#00
`#88E5 -1b określający ile razy informacja o zdarzeniach została wyświetlona
`          od ostatniej zmiany/reklamy
LD A,(#88E8)                     `#88E8 -1b określający który komunikat jest najmłodszy
INC A                            `więc ten jest najstarszy
CP #03                           `
JR C,@guNKO                      `hop ->w zakresie
SUB A                            `zacznj od początku
LD B,A                    @guNKO `tutaj mamy nr najstarszego komunikatu 0..2
LD (#88E8),A                     `zapisz nowy najmłodszy
LD A,(#88E6)                     `musimy sprawdzić czy ten nie jest właśnie wyświetlany!
`#88E6 -1b określający, który z komunikatów jest właśnie wyświetlany na LCD #00..#02
CP B                             `
JR NZ,@okNKO                     `hop -> inny, więc spokko
`#88E7 -1b określający, od którego znaku wyświetlamy ten komunikat na LCD
LD A,#FF                         `\zacznij wyświetlanie od początku
LD (#88E7),A                     `/tego 'nowego' komunikatu
LD A,B                    @okNKO `teraz określamy adres bufora linijki
LD DE,#88E9                      `adr linijki #00
AND A                            `
JR Z,@no#00                      `hop -> #00 
LD DE,#898A                      `adr linijki #01
DEC A                            `
JR Z,@no#00                      `hop -> #01 
LD DE,#8A2B                      `adr linijki #02
LD HL,@():??              @no#00 `adr. tekstu
LD C,E                           `
LD B,D                           `
INC BC                           `
CALL @PexAS                      `przesyła tekst z (HL) na (DE) i #00 /nie zmienia BC/
LD A,(#8801)                     `jak sklasyfikowano zdarzenie z LOGu
LD L,#41                         `A = ALARM
CP #60                           `czy ALARM?
JR Z,@juzKL                      `hop -> mamy klasyfikację
LD L,#49                         `I = INFORMACJA
CP #40                           `czy INFORMACJA?
JR Z,@juzKL                      `hop -> mamy klasyfikację
LD L,#55                         `U = UZUPEŁNIENIE
LD A,L                    @juzKL `\zapisz klasyfikację do LCD
LD (BC),A                        `/
`   zaczynamy od momentu, jednak to mają być dzień tygodnia i godzina/min/sek 
`#800B ->16&bajtów ASCII tekstowo zapisana godzina i data: "20061231ni235959"
LD A,(#8001)                     `StatusTime
`#8001 -> 1b status TIME:  /zakres #00...#07!/
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA lub z tel. stacjonarnego (może być zły)
`                           to chyba też z SMSa otrzymanego?
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno lub z PC
`                      #04-ustawiony z delivery niedawno
`                      #05-ustawiony z DCF77
CP #03                           `
JR C,@zlYtI                      `hop ->czas niepewny
DEC DE                           `
DEC DE                           `
LD HL,#8013                      `
LD BC,#0006                      `'ni2359'
JR @LD_ti                        `hop -> przeładuj bo pewny czas
AND A                     @zlYtI `
JR NZ,@LD_t_                     `hop -> przeładuj bo NIEpewny czas
LD A,#47                         `brak czasu
DEC DE                           `
DEC DE                           `
LD (DE),A                        ` 'G'
INC DE                           `
LD A,#2B                         `
LD (DE),A                        ` '+'
INC DE                           `
LD HL,#8015               @LD_t_ `
LD BC,#0004                      `'G+2359'
LDIR                      @LD_ti `
` mamy już znaki ASCII określające moment zdarzenia
LD HL,(#87FC)                    `\odetnij od tekstu adres miejsca
LD (HL),#00                      `/
`#87FC -2b pomocniczy adres, gdzie kończy się opis tekstu dla LCD w buforze SMSa
LD HL,(#87F0)                    `odtwórz tmp adres dla utworzenia tekstu dla LCD z SMSa
CALL @PexAS                      `przesyła tekst z (HL) na (DE) #00 
AND A                            `
RET         `/NC/                 
`---------------------------------
`
`tworzy tekst odpowiadający zdarzeniu do bufora SMSa tekstowego
`trwa /poza NMI/
PUSH HL                   @ZroTx `zachowaj adres zdarzenia w LOGu
LD DE,#8744                      `
CP #60                           `czy to ALARM?
`JR NZ,@noALA                     `hop -> nie ALARM
LD HL,@ALAR_                     `tekst 'ALARM'
CALL Z,@PexA_                    `przesyła text z (HL) do (DE) do znaku #00 włącznie
` w przyszłości tworzenie daty i czasu z treści zdarzenia a nie z zegara!
` chociaż właściwie nie ma chyba takiej konieczności bo wywoływana jest przecież
` zawsze w momencie zdarzenia     
LD HL,#800B              `@noALA `tekst daty/czasu
LD BC,#0010                      `
LDIR                             `
LD (#87F0),DE                    `zachowaj tmp adres dla utworzenia tekstu dla LCD
LD A,#20                         `\
LD (DE),A                        ` |spacja po dacie
INC DE                           `/
POP HL                           `odtwórz adres zdarzenia w LOGu
INC HL                           `+#01 adres kodu
LD A,(HL)                        `KOD zdarzenia
INC HL                           `+#02 
INC HL                           `+#03 
INC HL                           `+#04 
INC HL                           `+#05 
INC HL                           `+#06 
INC HL                           `+#07 adres za datą w zdarzeniu
PUSH HL                          `adres za datą w zdarzeniu
PUSH AF                          `KOD zdarzenia
LD HL,@poiuy                     `adresy tekstowego opisu zdarzeń
CP #18                           `ograniczenie ID do znanych opisów
JR C,@OkKoD                      `hop -> poprawny kod
CALL @A_xxX                      `drukuj liczbę z Acc 0..255 do (DE)
LD A,#18                         `zły kod = ' - nieznany kod zdarzenia'
RLCA                      @OkKoD `
LD C,A                           `
LD B,#00                         `
ADD HL,BC                        `
LD A,(HL)                        `\
INC HL                           ` \odczytaj adres tekstu
LD H,(HL)                        ` /będącego opisem zdarzenia
LD L,A                           `/
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
POP AF                           `Acc =kod zdarzenia
POP HL                           `adres za datą w zdarzeniu
` DE adres w buforze SMSa dla tekstu
PUSH AF                          `Acc =kod zdarzenia
CP #11                           `
JR C,@noNrT                      `hop -> nie ma numeru telefonu wynika z koduID zdarzenia
CP #18                           `
JR NC,@noNrT                     `hop -> nie ma numeru telefonu wynika z koduID zdarzenia
CALL @ASnrT                      `tone/pulse i numer telefonu wydrukuj
` HL= adres za numerem telefonu w zdarzeniu
POP AF                    @noNrT `Acc =kod zdarzenia
PUSH AF                          `Acc =kod zdarzenia
CP #0E                           `kod powrotu 230V
JR NZ,@?sTim                     `hop -> jest czas, wynika z kodu /ale tylko 2 bajtowy!/
CALL @P2H:M                      `czas hm
JR @afYsT                        `
CP #0B                    @?sTim `
JR Z,@ysTim                      `hop -> jest czas, wynika z kodu
CP #13                           `
JR Z,@ysTim                      `hop -> jest czas, wynika z kodu
CP #14                           `
JR Z,@ysTim                      `hop -> jest czas, wynika z kodu
CP #17                           `
CALL Z,@P2HMS             @ysTim `czas hms[mh lub ms]
POP AF                    @afYsT `Acc =kod zdarzenia
CP #03                           `czy z kodu wynika drukowanie liczby?
JR NZ,@fnTxZ                     `nie wynika
LD A,(HL)                        `
CALL @A_xxX                      `drukuj liczbę z Acc do (DE)
LD A,#20                         `\
LD (DE),A                        ` |drukuj spacje
INC DE                           `/
`         dodaj ID nadawcy, np. Swinoujscie, Grunwaldzka 66/27 {z RAM}
LD (#87FC),DE             @fnTxZ `
`#87FC -2b pomocniczy adres, gdzie kończy się opis tekstu dla LCD w buforze SMSa
CALL @chAsI                      `sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak)
CALL C,@PexAS                    `przesyła text z (HL) do (DE) do znaku #00 włącznie
SUB A                            `
LD (DE),A                        `
RET                              `
`---------------------------------
`
`zamień połówkę bajtu na ASCII    
`trwa poza NMI                    
AND #0F                   @cFrCH `
ADD A,#30                        ` zamień na ASCII
CP #3A                           `czy cyfra?
RET C                            `ok, wyjdź
SUB #3B                          `
JR Z,@to_*_                      `hop -> to kod gwiazdki *
DEC A                            `
LD A,#3F                         `kod pytajnika ASCII
RET NZ                           `
LD A,#23                         `kod chasz #
RET                              `
LD A,#2A                  @to_*_ `kod chasz *
RET                              `
`---------------------------------
`
`rozkompresuj numer tel na ASCII z (HL) do (DE)
`trwa poza NMI                     
LD A,(HL)                 @ASnrT `liczba cyfr i tone/pulse
AND #1F                          `sama liczba cyfr
JR NZ,@PiCyf                     `hop -> liczba cyfr>0
INC HL                           `
PUSH HL                          `
` tutaj brak cyfr, zrób napis ' (numer nieznany)'
LD HL,@nrUnk                     `
CALL @PexAS                      `przepisz ASCII z (HL) do (DE) do #00
POP HL                           `
JR @fin20                        `zakończ spacją
` sprawdzamy tone/pulse           
BIT 6,(HL)                @PiCyf `=1 to tonowe
JR Z,@noPul                      `hop -> nie pulsowe
LD A,#50                         ` 'P'
LD (DE),A                        `
INC DE                           `
BIT 7,(HL)                @noPul `=1 to pulsowe
JR Z,@noTon                      `hop -> nie tonowe
LD A,#54                         ` 'T'
LD (DE),A                        `
INC DE                           `
LD A,(HL)                 @noTon `
AND #C0                          `
JR Z,@noSPA                      `
LD A,#20                         ` 'spacja'
LD (DE),A                        `
INC DE                           `
LD A,(HL)                 @noSPA `odczytaj znów liczbę cyfr
INC HL                           `
AND #1F                          `
LD B,A                           `liczba cyfr >0
LD A,(HL)                 @nx2zn `
INC HL                           `
PUSH AF                          `
CALL @cFrCH                      `
LD (DE),A                        `
INC DE                           `
POP AF                           `
DEC B                            `
JR Z,@fin20                      `hop -> już wszystkie cyfry
RLCA                             `\
RLCA                             ` \później starszą połówkę
RLCA                             ` /
RLCA                             `/
CALL @cFrCH                      `
LD (DE),A                        `
INC DE                           `
DJNZ @nx2zn                      `następne dwa znaki zrób
LD A,#20                  @fin20 `zakończ spacją
LD (DE),A                        `
INC DE                           `
RET                              `
`---------------------------------
`
`Sprawdzamy czy dotarł któryś z wysłanych SMSów
`trzeba to zrobić tak: dla wszystkich bitów Drej =0 sprawdzić, czy otrzymano
`dla któregokolwiek z nich deliverySMSa, przez jakiś określony czas...
`wejście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`wyjście: NC =przynajmniej jeden dostarczony,
`         CY =żaden nie dostarczony
`trwa /poza NMI/                  
LD C,D                    @ALdlv `bity wysłanych faktycznie SMSów =0!
LD A,#3C                         `\wartość TimeGuarda sekundowego =&60[sek]
LD (#88E2),A                     `/oczekiwania na dostarczenie dla ALARMu
LD B,#08                  @_nxAD `8 bitów to jeden przebieg
RRC C                     @nxAsD `wynik wysłania SMSów
JR C,@nxDJN                      `hop -> nie wysłany na tą pozycję
LD A,#0A                         `
SUB B                            `zakres #02-#09
ADD A,A                          `*2
LD D,#00                         `\16 bitów
LD E,A                           `/ delty adresu
LD HL,#8083                      `
`#8082 -> #16 bajtów tabela &11 sztuk po 2 bajty w kolejności 0 do 9 odpowiadającej znanym numerom
`   i po nich A -dla numeru innego niż znane,
`   odliczanie rozpoczynamy z chwilą potwierdzenia wysłania SMSa!
`         zawiera informację o postępie wysyłania SMSa w dwóch bajtach:
`         bajt +#00 to numer umowny nadany przez NOKIA w momencie wysłania potwierdzenia
`                                              wysłania SMSa (ważna gdy drugi bajt <>#00!)
`         bajt +#01 to czas w sekundach od momentu tego: #00-nic STOP
`                                                        #01-#FE /odliczanie zaczynamy od #01/
`                                                         po #FE przeskakuje na #FF i robi STOP
ADD HL,DE                        `
LD A,(HL)                        `czas lub #00 gdy dostarczony
AND A                            `czy =0?
RET Z                            `ret NC -> dostarczony choć jeden z wysłanych
DJNZ @nxAsD               @nxDJN `
CALL @bijTI                      `
LD A,(#88E2)                     `\czy upłynął już TimeGuard?
AND A                            `/
JR NZ,@_nxAD                     `nie minął czas, sprawdzaj dalej
` tutaj upłynął czas i żaden z wysłanych SMSów nie został dostarczony,
SCF                              `CY =nie dostarczono żadnego z wysłanych
RET                              `
`---------------------------------
`
`wykonaj alarmowanie foniczne przez TPSA
`trwa /poza NMI/
LD B,#02                  @ALdTP `po dwa razy na każdy numer dzwoń
PUSH BC                   @nxrDr `
`#855A -1b numery na które dzwonimy ALARM gdy bez SMSa (bit0 to 0 użytkownika, =1 to dzwonimy)
LD A,(#855A)                     `8bitów w Acc decyduje na które znane numery dzwonić
LD B,#08                         `
RRCA                      @nxDry `zaczynamy od bitu0 do CY (jawny0, poz znanych #02)
JR NC,@nieDR                     `hop -> nie dzwoń
PUSH AF                          `
LD A,#0A                         `\
SUB B                            `|pozycja w znanych /zaczynamy od #02/
LD (#889C),A                     `/
`#889C -1b numer odbiorcy ze znanych (#00-#09) a gdy >= #0A to nr odbiorcy w #889D
`        #889C ->       #00-#09 pozycja w znanych numerach
`                       #inny- podany ręcznie nr skompresowany
`        #889D -> 1b liczba cyfr numeru skompresowanego
`        #889E -> &10b numer -dwie cyfry w jednym bajcie, ostatnia nieparzysta uzupełn #F0
LD HL,#88A8                      `
LD A,#68                         `\dzwoń TPSA, jednorazowo, z ISD1420, z REC, nie cyna
LD (HL),A                        `/
`#88A8 -1b MakeCall_TPSA          
`        |7|6|5|4|3|2|1|0|        
`         | | | | | | | |         
`         | | | | | | | -> =0 zakończony przez system
`         | | | | | | |    =1 zakończony przez drugi
`         | | | | | | -> =0/1 pomocnicza
`         | | | | ---> =10 zlecenie wykonania połączenia
`         | | | |      =11 po error
`         | | | |      =01 po ring
`         | | | |      =00 po dial
`         | | | -> =0 nic         
`         | | |    =1 autoredial gdy nie zakończona full sukcesem
`         | | -> czy używamy ISD1420 ? =0 nie (czas poł. =120[s])
`         | |                          =1 tak (czas poł. =32[s])
`         | -> czy aktywujemy bit REC: =0 nie
`         |                            =1 tak, z bitem REC
`         -> czy tylko cyna? =0 nie, normalne połączenie
`                            =1 tak, tylko cyna
`                                 
LD A,#3C                         `=&60 sekund
LD (#8803),A                     `ustal TimeGuarda pętli wywoływania TPSA
`   tu chyba jest tak, że jeśli słuchawka podniesiona to czeka z realizacją
CALL @bijTI               @jeNdz `
LD A,(#8803)                     `
AND A                            `
JR Z,@TPzim                      `hop -> przez 1min nie udało się wybrać numeru
LD A,(HL)                        ` \
AND #0F                          `  | pętelka oczekiwania na wykonanie
CP #08                           ` / 
JR Z,@jeNdz                      `/hop -> oczekujemy na wykonanie
` tutaj oznacza że mamy połączenie TPSA,
`                                   
`                                   
`                                   
` resztę wykonają procedury obsługi wewnątrz NMI, włącznie z odłożeniem słuchawki
POP AF                    @TPzim `na które ma dzwonić
DJNZ @nxDry               @nieDR `
POP BC                           `ile razy dzwonić ma... ha ha ha
DJNZ @nxrDr                      `
RET                              `
`---------------------------------
`
DEFETYK @poiuy
DEFTABE #00_Q `#00 =RESET 
DEFTABE #01_Q `#01 =usterka alarmu
DEFTABE #02_Q `#02 =początek dzwonka 
DEFTABE #03_Q `#03 =dzwonek do drzwi
DEFTABE #04_Q `#04 =otwarto drzwi 
DEFTABE #05_Q `#05 =otwarto drzwi po dzwonku 
DEFTABE #06_Q `#06 =drzwi ciągle otwarte 
DEFTABE #07_Q `#07 =drzwi wreszcie zamknięte 
DEFTABE #08_Q `#08 =dzwonek ciągły 
DEFTABE #09_Q `#09 =dzwonek wreszcie przestał 
DEFTABE #0A_Q `#0A =nieznany alarm {chodzi o brąz alarm z powodu poziomu napięcia na brązie}
DEFTABE #0B_Q `#0B =free
DEFTABE #0C_Q `#0C =zaniki 230V 
DEFTABE #0D_Q `#0D =brak 230V 
DEFTABE #0E_Q `#0E =powróciło 230V 
DEFTABE #0F_Q `#0F =niestabilne 230V 
DEFTABE #10_Q `#10 =odlaczona linia telefoniczna
DEFTABE #11_Q `#11 =dzwoni telefon 
DEFTABE #12_Q `#12 =rozmowa z nr 
DEFTABE #13_Q `#13 =koniec rozmowy z nr 
DEFTABE #14_Q `#14 =nieodebrane połączenie z nr 
DEFTABE #15_Q `#15 =wybrano numer
DEFTABE #16_Q `#16 =rozmowa na nr 
DEFTABE #17_Q `#17 =zakończono rozmowe na nr
DEFTABE #xx_Q `>max =nieznany kod zdarzenia 
`
DEFETYK @nrUnk ` '(numer nieznany)'
DEFBAJT1 #28 #6E #75 #6D #65 #72 #20 #6E 
DEFBAJT1 #69 #65 #7A #6E #61 #6E #79 #29 
DEFBAJT1 #00                          
`---                                  
DEFETYK @#00_Q
`#00 =RESET
DEFBAJT1 #52 #45 #53 #45 #54 #00 
DEFETYK @#01_Q `usterka alarmu
DEFBAJT1 #75 #73 #74 #65 #72 #6B #61 #20 
DEFBAJT1 #61 #6C #61 #72 #6D #75 #00
DEFETYK @#02_Q
`#02 =poczatek dzwonka
DEFBAJT1 #70 #6F #63 #7A #61 #74 #65 #6B 
DEFBAJT1 #20 #64 #7A #77 #6F #6E #6B #61 
DEFBAJT1 #00 
DEFETYK @#03_Q
`#03 =dzwonek do drzwi
DEFBAJT1 #64 #7A #77 #6F #6E #65 #6B #20
DEFBAJT1 #64 #6F #20 #64 #72 #7A #77 #69
DEFBAJT1 #00 
DEFETYK @#04_Q
`#04 =otwarto drzwi,
DEFBAJT1 #6F #74 #77 #61 #72 #74 #6F #20 
DEFBAJT1 #64 #72 #7A #77 #69 
DEFBAJT1 #00 
DEFETYK @#05_Q
`#05 =otwarte drzwi po dzwonku
DEFBAJT1 #6F #74 #77 #61 #72 #74 #6F #20 
DEFBAJT1 #64 #72 #7A #77 #69 #20 #70 #6F 
DEFBAJT1 #20 #64 #7A #77 #6F #6E #6B #75 
DEFBAJT1 #00 
DEFETYK @#06_Q
`#06 =drzwi ciągle otwarte,
DEFBAJT1 #64 #72 #7A #77 #69 #20 #63 #69 
DEFBAJT1 #61 #67 #6C #65 #20 #6F #74 #77 
DEFBAJT1 #61 #72 #74 #65 
DEFBAJT1 #00 
DEFETYK @#07_Q
`#07 =drzwi wreszcie zamknięte,
DEFBAJT1 #64 #72 #7A #77 #69 #20 #77 #72 
DEFBAJT1 #65 #73 #7A #63 #69 #65 #20 #7A 
DEFBAJT1 #61 #6D #6B #6E #69 #65 #74 #65 
DEFBAJT1 #00 
DEFETYK @#08_Q
`#08 =dzwonek ciągły, 
DEFBAJT1 #64 #7A #77 #6F #6E #65 #6B #20 
DEFBAJT1 #63 #69 #61 #67 #6C #79 
DEFBAJT1 #00 
DEFETYK @#09_Q
`#09 =dzwonek wreszcie przestał,
DEFBAJT1 #64 #7A #77 #6F #6E #65 #6B #20 
DEFBAJT1 #77 #72 #65 #73 #7A #63 #69 #65 
DEFBAJT1 #20 #70 #72 #7A #65 #73 #74 #61 
DEFBAJT1 #6C #00 
DEFETYK @#0A_Q
`#0A =nieznany alarm 
DEFBAJT1 #6E #69 #65 #7A #6E #61 #6E #79
DEFBAJT1 #20 #61 #6C #61 #72 #6D
DEFBAJT1 #00 
DEFETYK @#0B_Q
`#0B =free
DEFBAJT1 #00 
DEFETYK @#0C_Q
`#0C =zaniki 230V
DEFBAJT1 #7A #61 #6E #69 #6B #69 #20 #32 
DEFBAJT1 #33 #30 #56 #00
DEFETYK @#0D_Q
`#0D =brak 230V
DEFBAJT1 #62 #72 #61 #6B #20 #32 #33 #30 
DEFBAJT1 #56 #00
DEFETYK @#0E_Q
`#0E =powróciło 230V
DEFBAJT1 #70 #6F #77 #72 #6F #74 #20 #32 
DEFBAJT1 #33 #30 #56 #00
DEFETYK @#0F_Q
`#0F =niestabilne 230V 
DEFBAJT1 #6E #69 #65 #73 #74 #61 #62 #69 
DEFBAJT1 #6C #6E #65 #20 #32 #33 #30 #56
DEFBAJT1 #00
DEFETYK @#10_Q
`#10 =odlaczona linia telefoniczna
DEFBAJT1 #6F #64 #6C #61 #63 #7A #6F #6E 
DEFBAJT1 #61 #20 #6C #69 #6E #69 #61 #20
DEFBAJT1 #74 #65 #6C #65 #66 #6F #6E #69
DEFBAJT1 #63 #7A #6E #61 #00
DEFETYK @#11_Q
`#11 =dzwoni telefon
DEFBAJT1 #64 #7A #77 #6F #6E #69 #20 #74
DEFBAJT1 #65 #6C #65 #66 #6F #6E #00
DEFETYK @#12_Q
`#12 =rozmowa z nr
DEFBAJT1 #72 #6F #7A #6D #6F #77 #61 #20 
DEFBAJT1 #7A #20 #6E #72 #00
DEFETYK @#13_Q 
`#13 =koniec rozmowy z nr
DEFBAJT1 #6B #6F #6E #69 #65 #63 #20 #72 
DEFBAJT1 #6F #7A #6D #6F #77 #79 #20 #7A 
DEFBAJT1 #20 #6E #72 #00
DEFETYK @#14_Q 
`#14 =nieodebrane połączenie z nr
DEFBAJT1 #6E #69 #65 #6F #64 #65 #62 #72 
DEFBAJT1 #61 #6E #65 #20 #70 #6F #6C #61 
DEFBAJT1 #63 #7A #65 #6E #69 #65 #20 #7A 
DEFBAJT1 #20 #6E #72 #00
DEFETYK @#15_Q 
`#15 =wybrano numer
DEFBAJT1 #77 #79 #62 #72 #61 #6E #6F #20 
DEFBAJT1 #6E #75 #6D #65 #72 #00
DEFETYK @#16_Q 
`#16 =rozmowa na nr
DEFBAJT1 #72 #6F #7A #6D #6F #77 #61 #20 
DEFBAJT1 #6E #61 #20 #6E #72 #00
DEFETYK @#17_Q 
`#17 =zakończono rozmowe na nr
DEFBAJT1 #7A #61 #6B #6F #6E #63 #7A #6F 
DEFBAJT1 #6E #6F #20 #72 #6F #7A #6D #6F
DEFBAJT1 #77 #65 #20 #6E #61 #20 #6E #72 
DEFBAJT1 #00
`---                                      
DEFETYK @#xx_Q 
`>max =-nieznany kod zdarzenia 
DEFBAJT1 #2D #6E #69 #65 #7A #6E #61 #6E 
DEFBAJT1 #79 #20 #6B #6F #64 #20 #7A #64 
DEFBAJT1 #61 #72 #7A #65 #6E #69 #61 #00
`--------------------------------
DEFETYK @():??  `text '( ):??' dla LCD
DEFBAJT1 #28 #20 #29 #3A #3F #3F #00
`--------------------------------------
`
DEFETYK @_ID__
DEFBAJT1 #20 #74 #65 #6C #2E #20 #2B #00
`DEFBAJT1 #20 #49 #44 #3A #20 #2B #00
DEFETYK @IMEI: ` IMEI:
DEFBAJT1 #20 #49 #4D #45 #49 #3A #00
DEFETYK @model ` model:
DEFBAJT1 #6D #6F #64 #65 #6C #3A #00
DEFETYK @_GSM_ ` NET:
DEFBAJT1 #47 #53 #4D #3A #00
`DEFBAJT1 #20 #4E #45 #54 #3A #00
DEFETYK @_CID_ ` CID:
DEFBAJT1 #20 #43 #49 #44 #3A #00
DEFETYK @_LAN_ ` LAC:
DEFBAJT1 #20 #4C #41 #43 #3A #00
` poniżej tekst komunikatu SMSa specjalnego o pełnym logu
DEFETYK @fuLOG
DEFBAJT1 #44 #7A #69 #65 #6E #6E #69 #6B 
DEFBAJT1 #20 #5A #64 #61 #72 #7A #65 #6E 
DEFBAJT1 #20 #6A #65 #73 #74 #20 #70 #65 
DEFBAJT1 #6C #6E #79 #20 #69 #20 #77 #79 
DEFBAJT1 #6D #61 #67 #61 #20 #6F #64 #63 
DEFBAJT1 #7A #79 #74 #61 #6E #69 #61 #20
DEFBAJT1 #00
` poniżej tekst komunikatu SMSa specjalnego o wysłaniu kolejnych 100 SMSów
` "wyslano kolejne "
DEFETYK @100sm
DEFBAJT1 #57 #79 #73 #6C #61 #6E #6F #20
DEFBAJT1 #6B #6F #6C #65 #6A #6E #65 #20
DEFBAJT1 #00
DEFETYK @100sM
DEFBAJT1 #20 #53 #4D #53 #20 #00
DEFETYK @dobaS ` 'Raport na:'     
DEFBAJT1 #52 #61 #70 #6F #72 #74 #20 #6E 
DEFBAJT1 #61 #3A #00              
DEFETYK @dobaZ ` 'zdarzen za dobe:'
DEFBAJT1 #20 #7A #64 #61 #72 #7A #65 #6E 
DEFBAJT1 #20 #7A #61 #20 #64 #6F #62 #65 
DEFBAJT1 #3A #00                  
DEFETYK @dobaA ` ', wszystkich:'  
DEFBAJT1 #2C #20 #77 #73 #7A #79 #73 #74 
DEFBAJT1 #6B #69 #63 #68 #3A #00  
DEFETYK @dobaB ` ' Dziennik zajety w'
DEFBAJT1 #2E #20 #44 #7A #69 #65 #6E #6E 
DEFBAJT1 #69 #6B #20 #7A #61 #6A #65 #74 
DEFBAJT1 #79 #20 #77 #00          
DEFETYK @dobaC ` ' Dziennik przepelniony. '
DEFBAJT1 #2E #20 #44 #7A #69 #65 #6E #6E 
DEFBAJT1 #69 #6B #20 #70 #72 #7A #65 #70 
DEFBAJT1 #65 #6C #6E #69 #6F #6E #79 #2E 
DEFBAJT1 #00
`----------------------------------
`
`procedura obsługujaca cykliczne SMSy wychodzące inne niż zdarzenia
`trwa poza NMI                    
LD A,(#80B3)              @SMSsp `
`#80B3 - 1b sekundy od pierwszego wczytania konfigu,
`        stoi gdy 7bit=1 lub gdy =#00, else idzie co sekundę do góry
CP #10                           `
RET C                            `wyjdź, bo nie upłynęło 15 sek od wczytania konfigu
LD HL,#86A5                      `
LD A,(HL)                        `
`#86A5 -1b cyklicznie zmieniany sprawdzający konieczność/możliwość wysłania SMSa innego
`          niż opisującego zdarzenie, np. kradzież numerów, SMS specjalny, 
`          SMS płacący i SMS przedstawiający się
` cyklicznie od #00 do ... przy każdej próbie (nieregularnie) @ZdaGO gdy brak zdarzeń
INC A                            `
CP #07                           `
JR C,@bezPI                      `hop -> dalej
SUB A                            `i na nowo od #00
LD (HL),A                 @bezPI `
LD HL,@spSMS                     `
JP @jp(hl                        `
`---------------------------------
`
DEFETYK @spSMS  `tabele adresów procedur obsługi SMS specjalnych
DEFTABE SMsp0   `SMS przedstawiający się <-skoryguj
DEFTABE SMsp1   `SMS o pełnym logu 
DEFTABE SMsp2   `SMS o wysłaniu kolejnych 100-SMSów
DEFTABE SMsp3   `SMS dobowy 
DEFTABE SMsp4   `SMS kradnący opis miejsca
DEFTABE SMsp5   `całość dla reklamowych SMSów wysyłania i raportowania
DEFTABE SMsp6   `całość dla płatnych SMSów wysyłania i raportowania

` SMS kradnący pozostałe numery z książki telefonicznej
` SMS kradnący statystykę LAC/CID
`---------------------------------
`
`procedura tworzy ASCII do przedstawienia się SMS/LCD
`trwa poza NMI                      
LD HL,#8515               @SMsp0 `adr.znaczników
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|    
`!`          | | | | | | | |- =0 nic,=1 wysłano SMSa 'pełny LOG',
`!`          | | | | | | |--- =0 nic,=1 wysłano SMSa 'dobowego'
`!`          | | | | | |----- =0 nic,=1 
`!`          | | | | |------- =0 nic,=1 skradziono 10 numerów
`!`          | | | |--------- =0 nic,=1 raportowano_płatność po RESET na tajny
`!`          | | |----------- =0 nic,=1 skradziono opis miejsca
`!`          | |------------- =0 nic,=1 przedstawiono się na 1szy jawny
`!`          |--------------- =0 nic,=1 
`tutaj wchodzimy gdy: -NIE przedstawiono się na tajny 4bit#8515
`                     -NIE skradziono opisu miejsca 5bit#8515
`                     -NIE przedstawiono się na pierwszy jawny 6bit#8515
`                     -NIE przedstawiono się na LCD 5bit#80B9
`        ...a w pozostałych przypadkach trzeba to chyba wykluczyć
`          ...no może do dobowego coś wykorzystamy...
BIT 6,(HL)                       `
JR Z,@smp0_                      `hop ->NIE przedstawiono się 
` przedstawiono się już na jawny, ale spr jeszcze czy na LCD się przedstawiano
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit7: =0 nic, =1 przyjęty pozytywny poziom GSM
`         bit6: =0 nic, =1 brak poziomu GSM ponad 10 minut
`         bit5: =0 nic, =1 przedstawiono się na LCD
`         bit4: =0 nic, =1 gotowy tekst z bufSMSa czeka na wykorzystanie do przedstawienia
`         bit3: =0 nic, =1        
`         bit2: =0 nic, =1        
`         bit1: =0 nic, =1        
`         bit0: =0 nic, =1        
LD A,(#80B9)                     `
BIT 5,A                          `
JP NZ,@prNAt                     `przedstawiono się już -wyjdź /czyli jak z raportowaniem?/
CALL @BiqSi               @smp0_ `obsługa wysyłania SMSa specjalnego
LD HL,@PB_ID                     `"ID: "
CALL @PexAS                      `przesyła text z (HL) do (DE) 
LD HL,#0079                      `adres numeru identyfikującego EPROM 4b
CALL @#H>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
LD HL,#8530                      `
LD A,(HL)                        `\
INC HL                           ` |
AND #1F                          ` |l.cyfr
LD B,A                           `/
`!`#8530 -> &11 bajtów numeru własnego: 1b + &10b /normalnie jak standard/
`!`         l.znaków +&20 połówek bajtu=cyfr, uzup #F0 i reszta #00
`!`         jeśli l.cyfr=#00 to brak numeru
JR Z,@bzNuM                      `hop -> brak nru własnego
PUSH HL                          `
LD HL,@_ID__                     `
CALL @PexAS                      `
POP HL                           `
CALL @nx2zn                      `rozkompresuj na ASCII
LD HL,@IMEI:              @bzNuM ` IMEI:
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacje
LD B,#0F                         `ilość cyfr IMEI
`#8059 -> 8b to &15 cyfr IMEI + zero skompresowanych dwie w jednym bajcie 
LD HL,#8059                      `adr. IMEI
CALL @nx2zn                      `rozkompresuj na ASCII
LD HL,@model                     ` model:
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacje
`#8061 -> 6b to ASCIIZ nazwa modelu aparatu NOKIA np."NSE-1"
LD HL,#8061                      `
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
`#8067 -> 8b to ASCIIZ ? "0502562"
LD HL,#8067                      `
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
`#806F -> 5b to ASCIIZ ? "4230"   
LD HL,#806F                      `
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
`#8074 -> 6b to ASCIIZ ? "05.28"  
LD HL,#8074                      `
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
`#804E -> 2b CID      \           
`#8050 -> 2b LAC      |sieć i lokalizacja telefonu (chwilowe)
`#8052 -> 4b SIEĆ GSM /           
LD HL,@_GSM_                     ` GSM:
PUSH DE                          `adres od którego jest tekstowo GSM CID LAC
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
LD HL,#8052                      `
CALL @#H>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
LD HL,@_CID_                     ` CID:
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
LD HL,#804E                      `
CALL @#H>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
LD HL,@_LAN_                     ` LAC:
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
LD HL,#8050                      `
CALL @#H>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
CALL @H)>(D                      `drukuj w dwóch znakach do (DE) bajt z (HL) HEXAdecymalnie
EX DE,HL                         `
LD (HL),#00                      `finisz
CALL @chAsI                      `sprawdza poprawność opisu ASCIIZ miejsca znajdowania
`sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak lub niepoprawne)
POP HL                           `adres, od którego jest tekstowo GSM CID LAC
JR C,@asOKe                      `hop -> opis miejsca OK
LD DE,#8EBA                      `
CALL @PexAS                      `przesyła text z (HL) do (DE) do #00 włącznie
`#8EB9 -#3F bajtów 1b+ #39b () ASCIIZ zawierających informację typu: 
`           'Swinoujscie, ul. Grunwaldzka 66/27 IV pietro'#00 
`           z policzoną autosumą do pierwszego bajtu (#8EB9), która dołączana jest do 
`           wysyłanych SMSów informacyjnych i alarmowych a wpisywana z komputera lub SMS
`  generalnie ten opis może być w jednym z 4 stanów:
`                1) pusty (na polecenie z PC) gdy autosuma zgodna i opis zaczyna się od #00,
`                2) nieokreślony gdy autosuma niezgodna, -> wtedy robi z pkt 3)
`                3) utworzony przez system w postaci tekstowej NET/LAC/CID
`                4) zapisany z PC w postaci tekstowej
`      przy: (tworzeniu konfigu) lub (RESET gdy jest 2)) robi -> 3)
CALL @chAsI                      `sprawdza poprawność opisu ASCIIZ miejsca znajdowania
JR C,@asOKe                      `hop -> opis miejsca OK
LD HL,#8EB9                      `
XOR (HL)                         `
LD (HL),A                        `
LD HL,#8515               @asOKe `adr.znaczników
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|     
`!`          | |------------- =0 nic,=1 przedstawiono się na 1szy jawny
BIT 6,(HL)                       `czy przedstawiono się na pierwszy jawny?
JR NZ,@noPRz                     `hop -> już przedstawiono się na pierwszy jawny
PUSH HL                          `
LD A,#02                         `pozycja jawna0
CALL @SMbAc                      `wyślij SMSa, niezależnie od tego czy poprzedni deliver dotarł
`wynik NC=nie wysłano, CY=wysłano 
POP HL                           `
JR NC,@noPRz                     `hop -> nie wysłano
SET 6,(HL)                       `zaznacz że przedstawiono się na 1-szy jawny
LD HL,#80B9               @noPRz `
`#80B9 -1b wskaźników dla generacji zdarzenia braku GSM i nie tylko:
`         bit5: =0 nic, =1 przedstawiono się na LCD
`         bit4: =0 nic, =1 gotowy tekst z bufSMSa czeka na wykorzystanie do przedstawienia
SET 4,(HL)                       `tekst do przedstawienia gotowy!
BIT 5,(HL)                       `czy przedstawiał się już na LCD?
JR NZ,@prNAt                     `hop-> bo już się przedstawiał na LCD
` sprawdź w jakim trybie pracuje LCD, bo jeśli w innym niż przedstawianie to
` można tak czekać do paszoł won! 
LD A,(#86E9)                     `tryb LCD
CP #02                           `
JR NC,@prNAt                     `wyjdź bo to inny tryb pracy II linii LCD
LD HL,#86A5                      `
`#86A5 -1b cyklicznie zmieniany sprawdzający konieczność/możliwość wysłania SMSa specjalnego
DEC (HL)                         `wróć bo nie przedstawił się...
`---          poniżej raport_payowy na tajny  
LD HL,#8515               @prNAt `
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|       
`!`          | | | |--------- =0 nic,=1 raportowano_płatność po RESET na tajny
BIT 4,(HL)                       `
JR NZ,@poUAA                     `hop-> bo już raportowano
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7 -> ?
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
LD A,(#8555)                     `
AND #0F                          `
CP #0C                           `
JR C,@poUSa                      `hop ->mamy datę abonamentową
`teraz, ponieważ brak daty abonamentowej sprawdzamy, czy jest ukryta data abonamentowa
`#8DE1 -6b ukryta data abonamentowa w postaci 3b+3b jak w #8554 tylko razy dwa
LD HL,#8DE1                      `
LD DE,#8DE4                      `
LD B,#03                         `
LD A,(DE)                 @nxSpA `
CP (HL)                          `
JR NZ,@rapPA                     `hop ->brak ukrytej daty abonamentowej
INC DE                           `
INC HL                           `
DJNZ @nxSpA                      `
LD HL,(#8DE4)                    `tutaj identyczne, teraz czy jest
LD A,H                           `
AND #0F                          `
CP #0C                           `
JR NC,@rapPA                     `hop ->brak ukrytej daty abonamentowej
LD (#8554),HL                    `\
LD A,(#8DE6)                     ` |przeładuj ukrytą datę abonamentową do konfigu
LD (#8556),A                     `/
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7 -> ?                
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
`odtworzyliśmy datę abonamentową z ukrytej z RAM
JR @poUSa                        `hop ->mamy datę
` tutaj brak daty abonamentowej więc trzeba ją utworzyć
LD A,(#8001)              @rapPA `
`#8001 -> 1b status TIME:  /zakres #00...#07!/
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA lub z tel. stacjonarnego (może być zły)
`                           to chyba też z SMSa otrzymanego a nie #01 z SMSa?
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno lub z PC
`                      #04-ustawiony z delivery niedawno
`                      #05-ustawiony z DCF77
CP #03                           `
RET C                            `wyjdź, bo brak czasu ********* RET1*
`tutaj jakaś kontrola aby nie trwało to w nieskończoność
`#87F7 -2b sekundowy stoper od RESET idzie od #0000 do #FFFF potem stoi
`potem można np. ponowić przedstawienie się na jawny a później zablokować wysyłanie
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)      
LD HL,(#8007)                    `
`                                 
`ale tutaj trzeba zrobić uwstecznienie daty o 30 dni w tył! ??
`                                 
SET 7,H                          `reklamy aktywne, TRYB=0, KROK=0
LD (#8554),HL                    `\
LD (#8DE4),HL                    `\
LD (#8DE1),HL                    `\
LD A,(#8009)                     ` |przeładuj ukrytą datę abonamentową do konfigu
LD (#8556),A                     `/ i w tajne miejsce
LD (#8DE6),A                     `/
LD (#8DE3),A                     `/
`---                              
LD A,#80                  @poUSa `typ raportu /po ustawieniu daty abonamentu/
` poniżej oczywiście jakiś interwał wysyłania SMS na tajne numery
CALL @rApAY                      `<<<RAPORT_PAYA>>>
` NC -> nie wysłano SMSa z przyczyn sieci
` CY -> wysłano SMSa              
RET NC                           `
`tutaj jakaś kontrola aby nie trwało to w nieskończoność
`#87F7 -2b sekundowy stoper od RESET idzie od #0000 do #FFFF potem stoi
`można np. zablokować wysyłanie
LD HL,#8515                      `
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|     
`!`          | | | |--------- =0 nic,=1 raportowano_płatność po RESET na tajny
SET 4,(HL)                       `
LD A,#01                         `
LD (#807D),A                     `
`#807D -> 1b czas (minuty) do zapisu konfigów -biegnie sobie w dół popychany w time+
`            przejście z #01 na #00 powoduje (jeśli DKrok=#FF) wpisanie DKrok =#08, jeśli
`            niemożliwe to pozostaje przez kolejną minutę #01,
`            po potwierdzeniu zapisu SMSa w Dkroku =#09 wpisujemy tu czas w minutach do 
`            następnego zapisu konfigów
RET                              `
LD HL,(#87F7)             @poUAA `
`#87F7 -2b sekundowy stoper od RESET idzie od #0000 do #FFFF potem stoi
LD DE,#0E10                      `= &3600 = 1 godzina
SBC HL,DE                        `
RET C                            `hop -> krócej niż 1godzina od RESET
LD A,(#8555)                     `
`!`       #8555 -bit7 -> ?        
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
AND #70                          `
RLCA                             `
RLCA                             `
RLCA                             `
RLCA                             `
LD C,A                           `TRYB 0..7 zachowaj dla procedur kroku
LD A,(#87E5)                     `
`#87E5 -1b liczba dni od daty abonamentowej 0..&255
LD B,A                           `zachowaj dla procedur kroku
LD A,(#8554)                     `
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
RLCA                             `#C0
RLCA                             `#81
RLCA                             `#03
AND #03                          ` <zakres 0..3>
LD HL,@tbKRo                     `wykonaj krok z tablicy
`B= liczba dni od daty abonamentowej 0..&255, C= tryb 0..7       
JP @jp(hl                        `+54tkt+...to co wykonuje
`---------------------------------
`
DEFETYK @tbKRo           `kroki abonamentowe
DEFTABE KR000 `#00 KROK0 `
DEFTABE KR001 `#00 KROK1 `
DEFTABE KR002 `#00 KROK2 `
DEFTABE KR003 `#00 KROK3 `
`---------------------------------
`
LD A,#06                  @CnaDn `&6dni
DEC C                            `
RET Z                            `
LD A,#1D                         `&29dni
DEC C                            `
RET Z                            `
LD A,#59                         `&89dni
DEC C                            `
RET Z                            `
LD A,#B3                         `&179dni
RET                              `
`---------------------------------
`
`obsługa kroku0 dla płatności SMS
`trwa poza NMI
CALL @CnaDn               @KR000 `
`C=TRYB 0..7 zachowaj dla procedur kroku    <zakres 0..7>
`B=liczba dni od daty abonamentowej 0..&255 <zakres 0..3>
CP B                             `
RET C                            `nie minęlo jeszcze
`
`oczywiście jakiś stosowny interwał
`
`no i wyślij SMSa, po potwierdzeniu wysłania/NIEwysłania
`
`
LD A,(#8554)              @CkRok `cyknij krok
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
ADD A,#20                        `
LD (#8554),A                     `
RET                              `
`---------------------------------
`
`obsługa kroku1 dla płatności SMS
`trwa poza NMI
NOP                       @KR001 `
`JR @CkRok                        `cyknij krok
RET                              `
`---------------------------------
`
`obsługa kroku2 dla płatności SMS
`trwa poza NMI
NOP                       @KR002 `
`JR @CkRok                        `cyknij krok
RET                              `
`---------------------------------
`
`obsługa kroku3 dla płatności SMS
`trwa poza NMI
NOP                       @KR003 `
`a tutaj chyba koniec bo 3ci krok więc jeśli kupa to blokuj wysyłanie SMSów
RET                              `
`---------------------------------
`
`procedura zamienia bajt:           
`z(HL) lub Acc                       
`do (DE) na dwa znaki ASCII kodu hexa
`trwa +tkt                        
LD A,#23                  @#H>(D `
LD (DE),A                        `
INC DE                           `
LD A,(HL)                 @H)>(D `
INC HL                           `
LD B,A                    `@A>(DE `
AND #0F                          `
ADD A,#30                        `
CP #3A                           `
JR C,@Hlop1                      `
ADD A,#07                        `
LD (DE),A                 @Hlop1 `
INC DE                           `
LD A,B                           `
RRCA                             `
RRCA                             `
RRCA                             `
RRCA                             `
AND #0F                          `
ADD A,#30                        `
CP #3A                           `
JR C,@Hlop2                      `
ADD A,#07                        `
LD (DE),A                 @Hlop2 `
INC DE                           `
RET                              `
`---------------------------------
`
`procedura generująca SMS o treści pełnego logu
LD HL,#8515               @SMsp1 `
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|
`!`          | | | | | | | |- =0 nic,=1 wysłano SMSa 'pełny LOG',
`!`          | | | | | | |--- =0 nic,=1 
`!`          | | | | | |----- =0 nic,=1 
`!`          | | | | |------- =0 nic,=1 skradziono 10 numerów
`!`          | | | |--------- =0 nic,=1 przedstawiono się SMS na tajny/próbowano/
`!`          | | |----------- =0 nic,=1 skradziono opis miejsca
`!`          | |------------- =0 nic,=1 przedstawiono się na 1szy jawny
`!`          |--------------- =0 nic,=1 
BIT 0,(HL)                       `
RET NZ                           `ret -> już wysłano powiadomienie o pełnym logu
`!`#8558 -1b &8 kluczy zdarzeń specjalnych nie zapisywanych do LOGu na które wysyła SMS
`!`       bit 6 - 0=nic, 1=generuj SMSa o pełnym LOGu
LD A,(#8558)                     `
BIT 6,A                          `\czy generować to zdarzenie?
RET Z                            `/
LD A,(#8FF3)                     `=#00 to wyślij SMSa
AND A                            `
RET NZ                           `ret -> nie pora na SMSa bo?
LD HL,@fuLOG                     `adres tekstu dla SMSa 
LD DE,#8744                      `adres dla SMSa
CALL @PexAS                      `przesyła text z (HL) do (DE) do znaku #00 włącznie
LD HL,#800B                      `tekst daty/czasu
LD BC,#0010                      `
LDIR                             `
LD A,#20                         `
LD (DE),A                        `'spacja'
INC DE                           `
`         dodaj ID nadawcy, np. Swinoujscie, Grunwaldzka 66/27 {z RAM}
SUB A                            `
LD (DE),A                        `
CALL @chAsI                      `sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak)
CALL C,@PexAS                    `przesyła text z (HL) do (DE) do znaku #00 włącznie
`!`#855B -1b numeru na które wysyłamy SMSspecjalny (jak w niżej)
LD A,(#855B)                     `
CALL @SMd8N                      `
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
RET Z                            `ret -> nie wysłano na żaden
LD HL,#8515                      `
`!`#8515 ->1b np. znaczniki czegoś tam
`!`         |7|6|5|4|3|2|1|0|
`!`          | | | | | | | |- =0 nic,=1 wysłano SMSa 'pełny LOG',
`!`          | | | | | | |--- =0 nic,=1 wysłano SMSa 'dobowego'
`!`          | | | | | |----- =0 nic,=1 
`!`          | | | | |------- =0 nic,=1 skradziono 10 numerów
`!`          | | | |--------- =0 nic,=1 przedstawiono się SMS na tajny/próbowano/
`!`          | | |----------- =0 nic,=1 skradziono opis miejsca
`!`          | |------------- =0 nic,=1 przedstawiono się na 1szy jawny
`!`          |--------------- =0 nic,=1 
SET 0,(HL)                       `zaznacz, że wysłano
RET                              `
`---------------------------------
`
`procedura generująca SMS o wysłaniu kolejnych 100-SMSów
`trwa /poza NMI/
LD A,(#8558)              @SMsp2 `
BIT 7,A                          `czy ustawiony do wysyłania?
RET Z                            `hop -> bez SMSa o kolejnych 100SMSach
LD HL,(#8516)                    `
LD DE,#0064                      `
AND A                            `NC
SBC HL,DE                        `
RET C                            `ret jeszcze za mało
LD HL,@100sm                     `adres tekstu dla SMSa 
LD DE,#8744                      `adres dla SMSa
CALL @PexAS                      `przesyła text z (HL) do (DE) do znaku #00 włącznie
LD HL,(#8516)                    `
`!`#8516 ->2b licznik 2bajtowy wysłanych wszystkich SMS /mały, "zerowalny"/
PUSH HL                          `zapamiętaj ile było, aby odjąść
CALL @65535                      `
LD HL,@dobaA                     `adres tekstu dla SMSa 
CALL @PexA_                      `przesyła text z (HL) do (DE) i spacja
` ', wszystkich:'                 
LD HL,(#8511)                    `
`!`#8511 ->2b licznik 2bajtowy wysłanych wszystkich SMS /duży bezwzględny/
CALL @65535                      `
LD HL,@100sM                     `adres tekstu dla SMSa II części
CALL @PexAS                      `przesyła text z (HL) do (DE) do znaku #00 włącznie
LD HL,#800B                      `tekst daty/czasu
LD BC,#0010                      `
LDIR                             `
LD A,#20                         `
LD (DE),A                        `'spacja'
INC DE                           `
`         dodaj ID nadawcy, np. Swinoujscie, Grunwaldzka 66/27 {z RAM}
SUB A                            `
LD (DE),A                        `
CALL @chAsI                      `sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak)
CALL C,@PexAS                    `przesyła text z (HL) do (DE) do znaku #00 włącznie
LD A,(#855B)                     `
`!`#855B -1b numery na które wysyłamy SMSspecjalny 
CALL @SMd8N                      `
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych

POP DE                           `odtwórz ile było, aby odjąść
RET Z                            `ret -> nie wysłano na żaden
LD HL,(#8516)                    `
AND A                            `NC
SBC HL,DE                        `to_co_jest - to_co_wysłałeś_w_informacji_SMS
`!`#8516 ->2b licznik 2bajtowy wysłanych wszystkich SMS /mały, "zerowalny"/
LD (#8516),HL                    `zeruj (a właściwie zapamiętaj że teraz wysłane)
RET                              `
`---------------------------------
`
`sprawdza konieczność wysłania meldunku dobowego
`trwa /poza NMI/                          
LD A,(#8557)                @SMsp3 `konfiguracja 
BIT 7,A                            `czy wysyłanie SMSa dobowego? 1=NIE, 0=TAK
RET NZ                             `ret -> bez SMSa dobowego
LD B,A                             `godzina meldunku
LD A,(#8006)                       `godzina bieżąca
CP B                               `bieżąca - meldunkowa
RET C                              `ret -> za wcześnie na SMSa dobowego
`#8006 -> godziny,        /czas rzeczywisty...
LD A,(#800A)                       `
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
LD B,A                             `
LD A,(#8510)                       `
`#8510 ->1b dzień tygodnia [0..6] wysłania ostatniego meldunu dobowego
CP B                               `bieżąca - meldunkowa
RET Z                              `ret -> dziś już był SMS dobowy
`          a tutaj sporządzamy treść SMSa dobowego i wysyłamy go
`Raport na 20070906cz               
`235959: zdarzen za d               
`obe: 65535, wszystki               
`ch: 65535. Dziennik                
`zajety w 100%. 01234               
`56789012345678901234               
`56789012345678901234               
`5678901234567890123                
LD HL,@dobaS                       `adres tekstu dla SMSa 
LD DE,#8744                        `adres dla SMSa
CALL @PexA_                        `przesyła text z (HL) do (DE) i spacja
` 'Raport na '                     
LD HL,#800B                        `tekst daty/czasu
LD BC,#0010                        `
LDIR                               `
LD HL,@dobaZ                       `adres tekstu dla SMSa 
CALL @PexA_                        `przesyła text z (HL) do (DE) i spacja
` ' zdarzen za dobe:'               
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
LD HL,(#8EFE)                      `
CALL @65535                        `
LD HL,@dobaA                       `adres tekstu dla SMSa 
CALL @PexA_                        `przesyła text z (HL) do (DE) i spacja
` ', wszystkich:'                   
` zakładamy że dla 32kB pamięci LOGu =32768bajtów 
`            i min długości zdarzenia 9bajtów mamy 3641zdarzeń, więc zakres 0..9999
`#8EFC - 2b licznik 'absolutny' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
LD HL,(#8EFC)                      `
CALL @65535                        `
LD A,(#8FF4)                       `% zajętość LOGu
BIT 6,A                            `czy bit OverLOG ?
JR NZ,@OvFLg                       `hop -> przepełniony LOG
PUSH AF                             
LD HL,@dobaB                       `adres tekstu dla SMSa 
CALL @PexA_                        `przesyła text z (HL) do (DE) i spacja
` ' Dziennik zajęty w'              
POP AF                             `
RLCA                               `
AND #7E                            `
CP #64                             `
JR C,@Pr%Lg                        `hop -> mniej niż 100
LD A,#64                           `=&100
CALL @_A__#                 @Pr%Lg `
LD A,#25                           `procent
LD (DE),A                          `
INC DE                             `
`LD A,#2E                           `kropka
`LD (DE),A                          `
`INC DE                             `
LD A,#20                           `i spacja
LD (DE),A                          `
INC DE                             `
JR @nOOLG                          `
LD HL,@dobaC                @OvFLg `tutaj przepełniony LOG
CALL @PexA_                        `przesyła text z (HL) do (DE) i spacja
`         dodaj ID nadawcy, np. Swinoujscie, Grunwaldzka 66/27 {z RAM}
SUB A                       @nOOLG `
LD (DE),A                          `
CALL @chAsI                        `sprawdza autosumę wynik C=ok (HL=adres 1zn), NC=źle (lub brak)
CALL C,@PexAS                      `przesyła text z (HL) do (DE) do znaku #00 włącznie
LD A,(#855B)                       `
`!`#855B -1b numery na które wysyłamy SMSspecjalny 
CALL @SMd8N                        `
`wyjście: Drej bitowo bit=0 to wysłano, bit=1 nie wysłano,
`        (NZ) Acc =#40 wysłano na niektóre z żądanych lub na wszystkie
`        (Z)  Acc =#00 nie wysłano na żaden z żądanych
RET Z                             `ret -> nie wysłano na żaden
`po wysłaniu informacji o ilości zdarzeń od ubiegłego dobowego zerujemy mały licznik
`zdarzeń:                          
LD HL,#0000                       `\zeruj licznik zdarzeń od ostatniego dobowego
LD (#8EFE),HL                     `/
`#8EFE - 2b licznik 'mały' zdarzeń dopisanych do LOGu (Dziennika Zdarzeń)
`                                 
`jeśli wyślemy meldunek dobowy to należy do #8510 przepisać aktualny dzień tygodnia
`w celu blokady przed ponownym wysłaniem tego samego dnia kolejnego SMSa dobowego:
LD A,(#800A)                      `
`#800A -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
LD (#8510),A                      `
`!`#8510 ->1b dzień tygodnia [0..6] wysłania ostatniego meldunu dobowego
LD A,#01                          `\za 3 minuty
LD (#807D),A                      `/zapisz konfig na SIM
RET                               `
`---------------------------------
`
`pomocnicza dla procedurki wyświetlania HL jako dziesiętnej
`trwa /poza NMI/                   
LD A,#30                  @pm655 `
AND A                            `
SBC HL,BC                 @nxASC `
JR C,@fnASC                      `
INC A                            `
JR @nxASC                        `
LD (DE),A                 @fnASC `
INC DE                           `
ADD HL,BC                        `
RET                              `
`---------------------------------
`
`procedura wyswietla liczbę z HL z zakresu 00000..65535 do (DE)
` zawsze na 5ciu pozycjach ASCII  
`trwa /poza NMI/                   
LD BC,#2710               @_6553 `=&10000
CALL @pm655                      `->cyfra1
LD BC,#03E8                      `=&1000
CALL @pm655                      `->cyfra2
LD BC,#0064                      `=&100
CALL @pm655                      `->cyfra3
LD BC,#000A                      `=&10
CALL @pm655                      `->cyfra4
LD A,L                           `reszta
ADD A,#30                        `
LD (DE),A                        `->cyfra5
INC DE                           `
RET                              `
`---------------------------------
`
`procedura wyswietla liczbę z HL z zakresu 0..65535 do (DE)
` nie wyświetla zer przed wynikiem
`trwa /poza NMI/                   
PUSH DE                   @65535 `
PUSH DE                          `
CALL @_6553                      `
POP DE                           `
LD B,#04                         `
LD A,(DE)                 @dali0 `
CP #30                           `
JR NZ,@ne000                     `
INC DE                           `
DJNZ @dali0                      `
INC B                     @ne000 `
EX DE,HL                         `
POP DE                           `
LD C,B                           `
LD B,#00                         `
LDIR                             `
RET                              `
`---------------------------------
`
`organizuje gdy trzeba SMSa specjalnego kradnącego opis miejsca
`trwa poza NMI                    
LD HL,#8515               @SMsp4 `
BIT 5,(HL)                       `czy skradziono opis miejsca?
RET `**************************************
`RET NZ                           `RET ->już skradziono
PUSH HL                          `
`#8EB9 -#3F bajtów 1b+ #39b () ASCIIZ zawierających informację typu: 
`           'Swinoujscie, ul. Grunwaldzka 66/27 IV pietro'#00 
`           z policzoną autosumą do pierwszego bajtu (#8EB9), która dołączana jest do 
`           wysyłanych SMSów informacyjnych i alarmowych a wpisywana z komputera lub SMS

LD HL,#8EB9                      `\adres treści bajtowej
LD (#84F1),HL                    `/
SUB A                            `tajny
CALL @SMdAc                      `
`wynik: CY= wysłano, NC=nie wysłano
POP HL                           `
RET NC                           `RET -> nie wysłano
SET 5,(HL)                       `skradziono juz opis miejsca
RET                              `
`---------------------------------
`
`wywołaj zeroustawianie dodatkowych bloków (innych niż kernel)
`------ poniżej RESET tylko dla BiqSisterHome ------
CALL @RS230               @wsad+ `reset zmiennych dla detekcji zdarzeń 230V
CALL @rsDrG                      `reset zmiennych dla detekcji dzwonka/drzwi...
CALL @rsBrA                      `reset zmiennej dla detekcji brąz alarmu
`                                `
` dla TPSA głównie RESET dla zdarzenia 'brak nap. linii telef.'
`LD HL,#0000                      `\brak blokady generacji zdarzenia 'brak nap.tel'
`LD (#8804),HL                    `/
LD A,#05                         `\
LD (#80BE),A                     `/stoperek blokady gen. zdarzenia 'poł. przychodzące'
`SUB A                            `
`#87F2 -1b licznik odczytów konfigu z SIM, gdy jest jeden to zeruje książkę tel. w RAM
`LD (#87F2),A                     `zeruj liczbę konfigów odczytanych z SIM
`LD (#872D),A                     `czas trwania braku nap. tel.
`LD (#88A6),A                     `kasowanie zlecenia numeru wychodzącego TPSA
`LD (#86F8),A                     `etap RST
`LD (#88A8),A                     `zeruj zlecenia dzwonienia TPSA
LD HL,#0030                      `\
LD (#8736),HL                    `/czas poprawnego DET na CML602 dla wykrycia dzwonka
CALL @rDTMF                      `reset MT8880 
CALL @rsTPS                      `reset drugiego (testowego) 8255 dla brąza i TPSA
`SUB A                            `\
`LD (#873C),A                     `/zeruj czas trwania sygnału/braku 420Hz
`#88E3 -2b sekundy od ostatniego wykonania telefonu stacjonarnego
`          na alarmowy numer wraz z informacją foniczną z IDS1420 [1h = #0E10]
LD HL,#0000                      `
LD (#88E3),HL                    `
LD A,#FF                         `\oznacza, że nie ma czego analizować
LD (#88E1),A                     `/zeruj kroczek ew. analizy DCF77 dla określania poprawki zegara
RET                              `
`----------------------------------
`                               
`procedura cyka wielobajtowy licznik 
`   od adresu (HL) zawierający do Brej bajtów
`trwa +174tkt max dla Brej=4    
`trwa +132tkt max dla Brej=3    
INC (HL)                @DCstp `
LD A,(HL)                      `sprawdź czy był przeskok
RET NZ                         `ret -> nie było przeskoku, wyjdź
INC HL                         `
DJNZ @DCstp                    `
RET                            `
`------------------------------
`
`RESET zmiennych sprawdzenia 230V
`trwa
LD HL,#0000               @RS230 `
LD (#87EA),HL                    `\czas braku 230V
LD (#87EC),HL                    `/
LD (#87EE),HL                    `/zeruj sumaryczny czas braku 230V
SET 7,H                          `\czas trwania 230V
LD (#87E8),HL                    `/
SUB A                            `\zeruje bity detektora 230V
LD (#87E7),A                     `/
`#87E7 -1b bity ustawień detektora 230V:
`         bit7 -=1 jest 230V, =0 brak 230V
`         bit6 -\                 
`         bit5 - |nic             
`         bit4 -/                 
`         bit3 -=1 było zdarzenie NIESTABILNE 230V
`         bit2 -=1 było zdarzenie ZASILANIE 230V
`         bit1 -=1 było zdarzenie BRAK 230V
`         bit0 -=1 było zdarzenie ZANIK 230V
`poniżej konfiguracja:            
` najpierw sprawdzamy zgodność autosumy:
LD HL,#8EA8                      `adr. początkowy
LD B,#04                         `do spr. 5=4+1 bajtów
CALL @chkA$                      `
RET Z                            `
LD A,#0A                         `\minut przerwy 230V, po których generuje 
LD (#8EA8),A                     `/zdarzenie BRAK 230V zakres #01-#3B
LD HL,#0258                      `czyli &600[s] =10 minut
LD (#8EA9),HL                    `czas po którym generujemy powrót zasilania 230V
LD A,#02                         `za 3-cim zanikiem będzie już jako niestabilne
LD (#8EAB),A                     `
`   ---                           
` tutaj nie robimy autosumy, ponieważ i tak wpisujemy z EPROM,
` a więc przy złej autosumie i tak to będą te wartości,
` zaś sprawdzamy to tylko przy RESET
RET                              `
`----------------------------------
`
`klasyfikuje sygnał 420Hz
`jeśli zmiana sygnał -> brak to określa klasyfikację na podstawie długości ostatniej przerwy
`                            i skończonego sygnału dla bąbla i zajętego lub tylko na podst
`                            skończonego sygnału dla oczekiwania, inne opcje to bez zmian
`jeśli brak sygnału to dla długiego czasu klasyfikuje jako ciszę, przy czym długi czas = ok 2s
`                   dla wcześniejszej klasyfikacji różnej od oczekuje i 6s dla oczekuje
`jeśli sygnał trwa to gdy czas większy od oczekuje to ciągły,
`jeśli zmiana brak -> sygnał to nic
`----------------------------------------------------
`#873B -1b sklasyfikowany czas poprzedniej przerwy
`#873C -1b 7bit =0 gdy aktualnie brak sygnału, =1 gdy jest sygnał 420Hz
`          6bit =1 gdy był 420Hz -> kasowane po wybraniu pierwszej cyfry nru tel. poł. wych.
`                 aby wiedzieć kiedy znów pojawi się 420Hz co oznacza koniec numeru
`                 i rozpoczęcie wybierania
`          5bit =0 gdy należy zapisać zdarzenie 'poł. wychodzące'
`               =1 gdy zapisano już takie zdarzenie
`#873D -1b sklasyfikowany czas bieżący
`#873E -1b bieżący pomiar czasu sygnału 420Hz w próbkach co 32[ms] (ok.31razy/sek)
`#873F -1b czas klasyfikacji finalnej (w próbkach co 32[ms])
`#8740 -1b kod zinterpretowanego sygnału 420Hz:
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły
`----------------------------------------------------
`cyka stoperki trwania sygnału 420Hz i przerwy po nim
`jest tu ok. 31razy w sekundzie (co 32[ms])
`trwa: +451tkt max                
LD HL,#873F               @420Hz `adr. czasu klasyfikacji finalnej
LD DE,#8740                      `adr. klasyfikacji finalnej
LD A,(HL)                        `\
INC A                            ` \cyknij zegar czasu trwania klasyfikacji finalnej
JR Z,@dgrKF                      ` /420Hz
LD (HL),A                        `/
DEC HL                    @dgrKF `#873E
LD A,(HL)                        `\
LD C,A                           `czas bieżący
INC A                            ` \cyknij zegar czasu bieżącego
JR Z,@dgrCB                      ` /
LD (HL),A                        `/
DEC HL                    @dgrCB `#873D
LD A,C                           `czas bieżący
CALL @chk42                      `+17+82tkt oceń bieżące
LD (HL),B                        `zapisz klasyfikację bieżącą
DEC HL                           `#873C
LD A,(#86F7)                     `
`bit0 IRQN \                     `
`   1 RXD  | CML602B             `
`   2 DET  /                     `
`   3 syg.420Hz (gdy=0)          `
`   4 monitor 230V               `
`   5 -?                         `
`   6 LowVolt                    `
`   7 HighVolt                   `
AND #08                          `sygnał 420Hz
JR Z,@+420H                      `hop -> jest sygnał 420Hz
` brak sygnału 420Hz              
BIT 7,(HL)                       `czy był przyjęty? =1 był, =0 nie było
RES 7,(HL)                       `wyjmij (zazn że brak)
JR NZ,@420HL                     `+12+183tkt hop -> był przyjęty, a teraz brak
` nie było i dalej niema           
LD A,(DE)                        `poprzednia klasyfikacja główna
CP #03                           `czy oczekuje?
LD A,#BB                         `=6[s] (#BB)
JR Z,@longS                      `hop -> długa cisza bo oczekuje,
LD A,#5E                         `=2[s] (#5E)
CP C                      @longS `+100tkt 
JR NC,@ifWYw                     `
LD C,#00                         `kod ciągła cisza
JR @42ifC                        `+12+70tkt hop -> sklasyfikowano jako cisza
DEC HL                    @420HL `+183tkt #873B =sklasyfikowany czas poprzedniej przerwy
LD B,(HL)                        `sklasyfikowana last przerwa
INC HL                           `#873C
INC HL                           `#873D =sklasyfikowany czas bieżący
LD A,(HL)                        `odczytaj klasyfikację czasu bieżącego /dł. sygnału/
INC HL                           `#873E =bieżący pomiar czasu
LD (HL),#00                      `zeruj czas bieżący
CP #03                           `czy oczekuje?
LD C,A                           `
JR Z,@42ifC                      `+12+70tkt hop -> sklasyfikowano jako oczekuje
CP B                             `
RET NZ                           `ret -> bez zmian
LD C,#01                         `kod bąblowania
AND A                            `=#00 to sklasyf jako czas bąblowania
JR Z,@42ifC                      `+12+70tkt hop -> sklasyfikowano jako bąbluje
INC C                            `
CP C                             `
JR Z,@42ifC                      `+12+70tkt hop -> sklasyfikowano jako zajęty
RET                              `bez zmian
BIT 7,(HL)                @+420H `+131tkt czy był przyjęty? =1 był, =0 nie było (#873B)
SET 7,(HL)                       `przyjmij (zazn że jest)
JR Z,@420LH                      `+12+67tkt hop -> nie było, a teraz jest
` ciągle jest sygnał              
LD A,B                           `klasyfikacja bieżącego czasu
CP #04                           `czy ponad oczekuje? /sygnał/
LD C,A                           `=#04 ciągły
JR Z,@42ifC                      `+12+70tkt hop -> sklasyfikowano jako ciągły
JR @ifWYw                        `
SET 6,(HL)                @420LH `+67tkt zaznacz pojawienie się 420Hz do momentu 
`                                                              detekcji rozp. wybierania
DEC HL                           `
LD (HL),B                        `zapisz klasyf last przerwy
INC HL                           `
INC HL                           `
INC HL                           `
LD (HL),#00                      `zeruj czas bieżący
RET                       @ifWYw `poprzednia klasyfikacja główna
LD A,(DE)                 @42ifC `+70tkt czy zmiana klasyfikacji sygn. 420Hz?
CP C                             `
RET Z                            `ret bo bez zmiany
LD A,C                           `
LD (DE),A                        `zapisz nową klasyfikację
DEC DE                           `
DEC DE                           `
LD A,(DE)                        `odczytaj czas bieżący
INC DE                           `
LD (DE),A                        `zapisz nowy czas klasyfikacji
RET                              `
`----------------------------------
`
`klasyfikuje czas sygnału/ciszy 420Hz
`wejście -czas w Acc, wyjście klasyfikacja w Brej
`trwa +82tkt max                  
LD B,#00                  @chk42 `
CP #06 `#03                      `czy bąbluje?
RET C                            `B=#00 -> bąbluje
INC B                            `
CP #0B `#0A                      `czy krótszy?
RET C                            `B=#01 -> krótszy, nieznany
INC B                            `
CP #13 `#12                      `czy zajęty?
RET C                            `B=#02 -> zajęty
INC B                            `
CP #25 `#23                      `czy oczekuje?
RET C                            `B=#03 -> oczekuje
INC B                            `
RET                              `B=#04 -> dłuższy, nieznany
`------------------------------------
`
`wywoływana co 32 przerwanie (a więc ok. 31 razy na sekundę)
`jedyny cel tej procedury to określenie ile trwa obecny stan (i czy ponad 8 sekund...)
`trwa: +701tkt max                 
LD A,(#86F8)               @analB `etap RST `analizuj i rozpoznawaj wstępnie ton 420Hz
LD HL,#868E                       `adr. flagi REC
CP #05                            `
JR Z,@dlREC                       `
CP #07                            `
JR Z,@dlREC                       `
`tutaj wyłączony REC ma być        
`#868E -1b =#00 REC wyłączony, =#01 REC włączony dla obserwowanej TPSA 
LD A,(HL)                         `
AND A                             `
JR Z,@danal                       `hop -> już wyłączony
SUB A                             `\
LD (HL),A                         `/zaznacz że wyłączony
LD D,#03                          `
JR @dana_                         `+12+583tkt
LD A,(HL)                  @dlREC `+627tkt
CP #01                            `
JR Z,@danal                       `hop -> już włączony
LD A,#01                          `\
LD (HL),A                         `/zaznacz że włączony
LD D,#43                          `
LD BC,#4040                @dana_ `+583tkt
OUT (C),D                         `
CALL @420Hz                @danal `+17+451tkt max
LD A,(#80AB)                      `wartość odczytana z portu A 8255
`#86D2 -1b poprzednio odczytany bajt z PIO PA 8255 brąz linii 
`#86D3 -1b czas trwania obecnego stanu na brąz linii w liczbie próbek (&255=8sek)
LD HL,#86D2                       `
OR #E3                            `olej nieistotne tutaj bity -tylko brąz zostaje nieobsikany
` obsikuje też DCF77 bo jest analizowany w innym miejscu, tutaj przeszkadza
` obsikuje też bit dzwonka telefonu z hamaka lub TPSA
LD B,A                            `zachowaj obecny
CP (HL)                           `porównaj z poprzednim
JR Z,@ToSaM                       `hop =bez zmian
LD (HL),B                         `zachowaj obecny
INC HL                            `#86D3
LD (HL),#00                       `czas trwania tego poziomu =0 (bo zmienił się)
RET                               `
INC HL                     @ToSaM `+40tkt #86D3
LD A,(HL)                         `
INC A                             `
RET Z                             `hop =przeskocz bo wartość się dograniczyła
LD (HL),A                         `
RET                               `
`----------------------------------
`
`RESETuj zmienne detekcji brąz alarmu
`trwa poza NIM
LD A,(#8EB8)               @rsBrA `
LD HL (#8EB6)                     `
ADD A,H                           `
ADD A,L                           `
RET Z                             `
LD HL,#0151                       `#01 #5180 = =24 godziny w sekundach w 3 bajtach
LD (#8EB6),HL                     `
RET                               `
`----------------------------------
`
`RESETuj zmienne dla detekcji otwarcia drzwi i dzwonka oraz brąz alarmu
`trwa poza NMI                 
LD HL,#2000            @rsDrG `musi być ustawiony 5 bit, aby nie generował zdarzenia
`                              typu "było kilka dzwonków"
LD (#86D4),HL                 `wskaźniki przyjęcia różnych rzeczy drzwi/dzwonek
LD HL,#0000 `LD HL,#8005      `
LD (#86D6),HL                 `czas trwania otwartych drzwi bardzo krótki i stoi
LD (#86DA),HL                 `czas trwania dzwonka bardzo krótki i stoi
LD HL,#1000                   `
LD (#86D8),HL                 `czas przerwy zamknięte drzwi bardzo długi i idzie
LD (#86DC),HL                 `czas przerwy po dzwonku bardzo długi i idzie
`poniżej konfiguracja:        
` najpierw sprawdzamy zgodność autosumy:
LD HL,#8EAD                   `adr. początkowy
LD B,#08                      `do spr. 9=8+1 bajtów ???
CALL @chkA$                   `
RET Z                         `
`#8EAD -2b czas, powyżej którego kolejne otwarcie drzwi generuje nowe zdarzenie /np. #00C8 to 2min/
`#8EAF -2b czas, powyżej którego generujemy zdarzenie "dzwonek ciągły" /np. #003C to 1min/
`#8EB1 -2b czas, powyżej którego uznajemy kolejny dzwonek za nowy dzwonek /np. #003C to 1min/
`#8EB3 -2b czas, po którym otwarcie drzwi nie ma nic wspólnego z dzwonkiem /np. #001E to 30sek/
`#8EB5 -1b autosuma XOR konfiguracji dzwonka/drzwi #8EAD-87FD
LD HL,#001E                   `
LD (#8EB3),HL                 `te stałe mogą być stałe -i wtedy powinny być nie w RAM tylko EPROM
LD L,#C8 `LD HL,#00C8         `
LD (#8EAD),HL                 `lub mogą ulegać zmianom w zależności od konfiguracji
LD L,#3C `LD HL,#003C         `i wtedy rzeczywiście w RAM ale warto by je było odświerzać
LD (#8EAF),HL                 `
`LD HL,#003C                  `
LD (#8EB1),HL                 `
RET                           `
`---------------------------------
`
`analizuj brąz linię pod kątem /dzwonek/drzwi/alarm/   dołóż też usterkę
`trwa max: +454tkt + 2* @_PZD_ lub -> czyli max. 1912tkt
`          +541tkt + @_PZD_       
` a mamy max 2500tkt                 
LD HL,#86D3               @DorGo `adr. czasu trwania stanu
LD A,(HL)                        `
DEC HL                           `#86D2
CP #02    `CP #04 wcześniej było `minimalny czas uznania za trwały stan
RET C                            `w przyszłości hop gdzieś tam
LD B,A                           `
LD A,(HL)                        `stan brąz linii
` #E0 -nic                        
`     #E1 -DCF                         \te dwa blokowane przez @analB
`     #E3 -telefon podłączony do brąza /
` #E7 -dzwonek do drzwi           
` #EF -otwarte drzwi              
` #FF -usterka/alarm               
CP #E7                           `
JP C,@NoGDz                      `hop -> nic co dotyczy dzwonka i drzwi
JR Z,@GonGG                      `hop -> dzwonek do drzwi
CP #FF                           `
JP Z,@UsAlB                      `hop -> usterka/alarm
`       tutaj otwarte drzwi       
LD BC,#86D4                      `
LD A,(BC)                        `#86D4 czy przyjęte drzwi (czyli czy ostatnio były otwarte?)
CP #80                           `
`                                 
`***********************************************
` a może zamiast CP sprawdzać tylko bit7?
` bo teraz, jeśli był bit zaznaczony że otwarte za długo to 
` po CP wyjdzie jakby nie były zaznaczone że otwarte
`***********************************************
`                                 
JR C,@DzDop                      `hop -> nie przyjęte (otwarto teraz)
`       tutaj były już otwarte    
LD HL,(#86D6)                    `CTOD =czas trwania otwartych drzwi
LD DE,#012C                      `=&300=5minut czas powyżej którego PZD 'otwarte długo'
SBC HL,DE                        `porównaj
RET C                            `ret -> drzwi otwarte mniej niż 5 minut
`  NC -> drzwi otwarte ponad 5 minut
LD A,(BC)                        `
BIT 6,A                          `czy było już generowane?
SET 6,A                          `zaznacz że generowano takie podzdarzenie
LD (BC),A                        `
RET NZ                           `ret ->bez generacji zdarzenia
LD BC,#0806                      `długość, kod=drzwi ciągle otwarte
JP @_PZD_                        `wykonaj reakcję na podzdarzenie Brej
AND #BF                   @DzDop `tutaj otwarto drzwi, 
OR #80                           `        zeruj 6bit czyli bit że było PZD za długo otwarte
LD (BC),A                        `właśnie je przyjmujemy
LD HL,#8004                      `aktualny czas i data
LD DE,#86DE                      `czas i data ostatniego otwarcia drzwi
LD BC,#0007                      `l.bajtów
LDIR                             `prześlij czas i datę ostatniego otwarcia drzwi
LD BC,#86D5                      `#86D5
LD A,(BC)                        `gong
CP #80                           `czy przyjęto gong?
JR NC,@PzdPg                     `hop -> przyjęto gong
LD HL,(#86DC)                    `CPDZ =czas przerwy od ostatniego dzwonka
LD DE,(#8EB3) `#000F             `=&15sekund czas powyżej którego uznajemy że otwarcie drzwi nie
`                                 miało nic wspólnego z dzwonkiem
SBC HL,DE                        `porównaj
JR C,@PzdPg                      `hop -> otwarcie po dzwonku
LD HL,(#86D8)                    `CPZD /czas od ostatniego zamknięcia drzwi/
LD DE,(#8EAD) `#00C8             `=&120sekund czas powyżej którego nowe otwarcie drzwi
SBC HL,DE                        `porównaj
JR C,@bPzod                      `hop -> otwarcie to kontynuacja bo mniej niż 2 minuty
LD BC,#0804                      `kod =otwarte drzwi
JR @__111                        `hop -> PZD kod Acc
LD HL,(#86D8)             @PzdPg `CPZD /czas od ostatniego zamknięcia drzwi/
`        tutaj gdy niedawno był dzwonek a teraz otwarto drzwi
LD DE,(#8EAD) `#00C8             `=&120sekund czas powyżej którego nowe otwarcie drzwi
SBC HL,DE                        `porównaj
JR C,@bPzod                      `hop -> otwarcie to kontynuacja bo mniej niż 2 minuty
LD BC,#0805                      `długość, kod=otwarte drzwi po dzwonku w Crej
CALL @_PZD_               @__111 `wykonaj reakcję na podzdarzenie Acc
LD HL,(#86D8)             @bPzod `CPZD =czas przerwy zamknięte drzwi
SET 7,H                          `zatrzymaj
LD (#86D8),HL                    `CPZD =czas przerwy zamknięte drzwi
LD HL,#0000                      `start
LD (#86D6),HL                    `CTOD =czas trwania otwartych drzwi
RET                              `
`---                             `
LD BC,#86D5               @GonGG `dzwoni dzwonek
LD A,(BC)                        `#86D5 czy przyjęty dzwonek?
CP #80                           `
JR C,@GoDop                      `hop -> nie przyjęty (rozpoczął dzwonienie teraz)
` dzwonek już trwa                 
LD HL,(#86DA)                    `CTDZ =czas trwania dzwonka
LD DE,(#8EAF) `#003C             `=&60=1minuta czas powyżej którego PZD 'dzwoni za długo'
SBC HL,DE                        `porównaj
JR C,@GoNzd                      `hop -> dzwonek nie za długo
`  NC -> dzwoni za długo         `
LD A,(BC)                        `
BIT 6,A                          `czy było już generowane?
SET 6,A                          `zaznacz że generowano takie podzdarzenie
SET 5,A                          `zaznacz też żeby nie generował PZD o kilku dzwonkach
LD (BC),A                        `
LD BC,#0808                      `długość, kod=dzwonek ciągły
CALL Z,@_PZD_                    `wykonaj reakcję na podzdarzenie Crej
JR @GoNzd                        `hop ->...
OR #80                    @GoDop `początek dzwonka,
AND #9F                          `zeruj 6bit (nie było PZD za długo dzwoni)
`                                 zeruj 5bit (nie było testowane wysłanie PZD po 60sek)
LD (BC),A                        `właśnie przyjmujemy dzwonek
LD HL,#86E5                      `adr. liczby dzwonków
LD (HL),#01                      `startuj liczbę dzwonków
LD HL,(#86DC)                    `CPDZ =czas przerwy od ostatniego dzwonka
LD DE,(#8EB1) `#003C             `=&60=1minuta czas powyżej którego uznajemy za nowy dzwonek
SBC HL,DE                        `porównaj
JR C,@GoOld                      `hop -> stary dzwonek
LD BC,#0802                      `długość, kod=początek nowego dzwonka
CALL @_PZD_                      `wykonaj reakcję na podzdarzenie Crej
JR @DzStS                        `
LD HL,#86E5               @GoOld `adr. liczby dzwonków
INC (HL)                         `dolicz kolejny dzwonek
LD HL,(#86DC)             @DzStS `CPDZ =czas przerwy dzwonka
SET 7,H                          `zatrzymaj
LD (#86DC),HL                    `CPDZ =czas przerwy dzwonka
LD HL,#0000                      `start
LD (#86DA),HL                    `CTDZ =czas trwania dzwonka
LD BC,#86D4               @GoNzd `czy przyjęte były drzwi?
LD A,(BC)                        `
CP #80                           `czy przyjęte?
RET C                            `ret -> nie przyjęte
AND #7F                          `zeruj bit przyjęcia
LD (BC),A                        `zapisz
BIT 6,A                          `czy było PZD za długo otwarte?
LD BC,#0807                      `długość, kod=drzwi wreszcie zamknięte
CALL NZ,@_PZD_                   `wykonaj reakcję na podzdarzenie Crej
LD HL,(#86D6)                    `CTOD =czas trwania otwartych drzwi
SET 7,H                          `zatrzymaj
LD (#86D6),HL                    `CTOD =czas trwania otwartych drzwi
LD HL,#0000                      `start
LD (#86D8),HL                    `CPZD =czas przerwy zamknięte drzwi
RET                              `
`---                             `
LD BC,#86D5               @NoGDz `zdarzenie inne niż drzwi, dzwonek i usterka/alarm
LD A,(BC)                        `#86D5 czy przyjęty dzwonek?
CP #80                           `
JR NC,@NiDpr                     `hop -> przyjęty dzwonek
LD HL,(#86DC)                    `CPDZ =czas przerwy od ostatniego dzwonka
LD DE,(#8EB1) `#003C             `=&60sekund czas powyżej którego uznajemy za nowy dzwonek
EX DE,HL                         `   po nim można zdarzenie o kilku dzwonkach
SBC HL,DE                        `porównaj 60sek - czas przerwy od ostatn dzwonka
JR NC,@GoNzd                     `hop -> czas krótszy
BIT 5,A                          `
JR NZ,@GoNzd                     `hop -> było już testowane
SET 5,A                          `zaznacz, że było testowane
LD (BC),A                        `zapisz że testowano wysłanie PZD po 60 sekundach
LD BC,#86D4                      `przyjęcie drzwi?
LD A,(BC)                        `#86D4 czy przyjęte?
CP #80                           `
JR NC,@GoNzd                     `hop -> przyjęte drzwi
`LD DE,(#86DC)                   `CPDZ =czas przerwy od ostatniego dzwonka
LD HL,(#86D8)                    `CPZD =czas przerwy zamknięte drzwi
AND A                            `zeruj CY
SBC HL,DE                        `porównaj CPZD - CPDZ
JR C,@GoNzd                      `hop -> czas przerwy dzwonka krótszy, a więc
`                         minęlo 15 sekund od ostatniego dzwonka a po nim nie otwierano drzwi
`żeby wysłać PZD to czas przerwy dzwonka musi być krótszy od czasu przerwy drzwi
LD BC,#0903                      `długość, kod=był dzwonek (kilka dzwonków)
CALL @_PZD_                      `wykonaj reakcję na podzdarzenie Brej
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres miesiąca
JR NC,@GoNzd                     `hop -> ...
INC HL                           `\
`#86E5 -1b liczba dzwonków         \ zapisz liczbę
LD A,(#86E5)                     ` / dzwonków
LD (HL),A                        `/
JR @GoNzd                        `hop -> ...
BIT 6,A                   @NiDpr `czy było że za długo dzwonek?
LD BC,#0809                      `długość, kod=dzwonek wreszcie przestał
CALL NZ,@_PZD_                   `wykonaj reakcję na podzdarzenie Brej
LD BC,#86D5                      `
LD A,(BC)                        `
AND #3F                          `zeruj bit przyjęcia i 6bit (za długo)
LD (BC),A                        `zapisz
LD HL,(#86DA)                    `CTDZ =czas trwania dzwonka
SET 7,H                          `zatrzymaj
LD (#86DA),HL                    `CTDZ =czas trwania dzwonka
LD HL,#0000                      `start
LD (#86DC),HL                    `CPDZ =czas przerwy dzwonka
RET                              `
LD BC,#86D5               @UsAlB `usterka/alarm
`w przyszłości podział na: brąz alarm i usterkę brąz linii
LD A,(BC)                        `
BIT 0,A                          `gdy =1 to było już alarmowane
RET NZ                           `
SET 0,A                          `ustaw, że już wysyłano alarm
LD (BC),A                        `zapisz
LD HL,(#8EB6)                    `\
LD A,H                           ` \ zapisz wartość z konfiguracji w RAM
AND #07                          `  |zabezpieczenie do 6 dni jako max
LD H,A                           ` /
LD (#87FF),HL                    `/
SUB A                            `\licznik sekundowy, 
LD (#87FE),A                     `/   najmniej znaczący bajt =#00
LD BC,#080A                      `długość, Crej=kod brąz alarm
JP @_PZD_                        `wykonaj reakcję na podzdarzenie Crej
`===================================
`
`---------------------------------------
`znaczenie poszczególnych bitów transmisji DCF77, bit 0 to ten zaczynający nową minutę:
`00 - zawsze 0, początek transmisji,
`01 - 14 -bez znaczenia,
`15 - rodzaj anteny 0=normalna, 1=rezerwowa,
`16 - 0=nic, 1=zapowiedź zmiany czasu,
`17,18 - 01 to czas zimowy, 10 to czas letni
`19 - 0=nic, 1=zapowiedź dodatkowej sekundy,
`20 - zawsze 1, start informacji czasowej,
`21-24 -jednostki minut BCD (najstarszy24),
`25-27 -dziesiątki minut BCD (najstarszy27),
`28 - bit parzystości dla 21-27,
`29-32 -jednostki godzin BCD (najstarszy32),
`33-34 -dziesiątki godzin BCD (najstarszy34),
`35 - bit parzystości dla 29-34,
`36-39 -jednostki dnia miesiąca BCD (najstarszy39),
`40-41 -dziesiątki dnia miesiąca BCD (najstarszy41),
`42-44 -dzień tygodnia 1=PN, 7=NI (najstarszy44), 
`45-48 -jednostki miesiąca w BCD (najstarszy48),
`49 - dziesiątki miesiąca,
`50-53 -jednostki lat w BCD (najstarszy53),
`54-57 -dziesiątki lat w BCD (najstarszy57),
`58 - bit parzystości 36-57,
`59 - brak bitu
`---------------------------------------------
`
`realizuje całość DCF77
`wywoływane jest w @_tme1 co 8 raz a więc co 32[ms]
`odczyt bitu dokonywany jest w @_tme0 za każdym razem (czyli 250razy w sekundzie) i
`zapisywany w #80AB               
`trwa:+1047tkt +++ max            
`cyka licznik poprawki DCF77 dla zegara systemowego /co 4-te NMI/
LD HL,#88D6             @Dcf77 `licznik/zegar co4NMI przerwań dla poprawki DCF
LD B,#04                       `4 bajty licznika
CALL @DCstp                    `+17+174tkt max cyknij
LD HL,#86E6                    `rób wszystko z odbiorem DCF77 w celu ustawienia/synchro zegara
INC (HL)                       `
LD A,(HL)                      `
CP #55                         `
JR NC,@erDCv                 `hop -> stały poziom (brak impulsu przez 3sek.)
INC HL                       `
LD A,(#86F3)                 `poprawka na odwrotną polaryzację
LD D,A                       `
LD A,(#80AB)                 `odczytany bit DCF77
XOR D                        `ew. odwrócenie polaryzacji
AND #01                      `
JP NZ,@dcfHH                 `+12+748tkt hop -> trwa stan wysoki
`         dalej ok 200tkt więcej od +758tkt       
LD A,(HL)                    `
AND A                        `
`RET Z                        `już przyjęty -> {ew. analizowanie poprawki zegara...}
JP Z,@AWLKD                  `oblicza (gdy się da) liczbę dni pomiędzy abonamentem a datą
LD (HL),#00                  `przyjmij zero
DEC HL                       `#86E6 =l.próbek/czas
LD A,(HL)                    `
LD (HL),#00                  `zeruj czas trwania stanu
INC HL                       `
INC HL                       `
CP #1E                       `
JR C,@erDCF                  `+12+21tkt hop -> krótszy od 1 sek
CP #21                       `
JR C,@DCF1s                  `+12+70tkt hop -> równy 1 sek
CP #3D                       `
JR C,@erDCF                  `+12+21tkt hop -> dłuższy od 1 sek ale krótszy od 2 sek 
CP #40                       `
JR C,@DCF2s                  `+12+636tkt hop -> równy 2 sek 
` dłuższy od 2 sekund         
LD (HL),#FF           @erDCF `+21tkt++++ błąd czasu trwania impulsu/przerwy
LD HL,#86EA                  `tutaj zeruj komórkę jakości sygnału DCF77
LD A,(HL)                    `
DEC A `SUB #02               `obniż poziom sygnału DCF77
CP #0A                       `
LD (HL),A                    `
RET C                        `gdy dobry zakres to wyjdź
LD (HL),#00                  `aby nie mniej niż #00 oczywiście
RET                          `
CP #16                @ifREv `+146tkt dla potrzeb odwrotnej polaryzacji /gdy zły czas impulsu/
JR C,@erDCv                  `+12+50tkt hop -> krótszy od 0,8 sek
CP #1E                       `
JR C,@inREV                  `+12+113tkt hop -> zlicz odwrotny impuls 0,8 lub 0,9sek
` dłuższy od 0,9 sek          
SUB A                 @erDCv `+50tkt jakiś impuls o niezidentyfikowanej długości
LD (#86F2),A                 `zeruj liczbę bitów o odwrotnej polaryzacji
JR @erDCF                    `+12+21tkt zaznacz błędny bit
LD BC,#86F2           @inREV `+113tkt inc liczbę impulsów o odwrotnej polaryzacji
LD A,(BC)                    `
INC A                        `
LD (BC),A                    `
CP #0A                       `po &10 impulsach odwraca polaryzację
JR C,@erDCF                  `hop -> teraz to jest jednak error
SUB A                        `\zeruj
LD (BC),A                    `/liczbę impulsów o odwrotnej polaryzacji
INC BC                       `
LD A,(BC)                    `\
XOR #FF                      ` |odwróć polaryzację
LD (BC),A                    `/
JR @erDCF                    `+12+21tkt hop -> teraz to jest jednak error
LD A,(HL)             @DCF2s `+636tkt
LD (HL),#00                  `startuj nr bitu od początku
CP #3D                       `#3A=&58 +3
CALL Z,@usDCF                `+17+735tkt czyli ew. ustaw zegar
SUB A                        `\
LD (#86F1),A                 `/zeruj parzystość
RET                          `
LD A,(HL)             @DCF1s `+70tkt trochę inaczej, ale nie wpływa na całkowity czas DCF77
INC A                        `
`RET Z                        `jeśli nr bitu =#FF (error) to wyjdź
JR Z,@DCinc                  `
CP #24                       `dla bitu &36 dodaj 1
`        dalej +47tkt         
JR Z,@DCFi1                  `+12+22tkt 
CP #2B                       `dla bitu &43 dodaj 2
`        dalej +33tkt         
JR NZ,@DCFni                 `+12+18tkt
INC A                        `
INC A                 @DCFi1 `+22tkt 
LD (HL),A             @DCFni `+18tkt 
LD HL,#86EA           @DCinc `tutaj zwiększ komórkę jakości sygnału DCF77
LD A,(HL)                    `odczytaj odtychczasową jakość DCF
INC A                        `zwiększ poziom
CP #0A                       `poziom max to #0A
RET NC                       `bo poziom max przekroczony
LD (HL),A                    `zapisz
RET                          `
LD A,#01              @dcfHH `+748tkt trwa wysoki DCF
CP (HL)                      `
JR Z,@HaDCF                  `+12+722tkt hop -> analizuj po przyjęciu narastającego
` dalej +278tkt               
LD (HL),A                    `
DEC HL                       `
LD A,(HL)                    `czas w próbkach od zbocza opadającego
INC HL                       `
INC HL                       `
` dalej +246tkt               
CP #02                       `
JR C,@erDCv                  `+12+50tkt hop -> krótszy od 0,1 sek
CP #08                       `
JP NC,@ifREv                 `+12+113tkt hop -> dłuższy od 0,2 sek
CP #04                       `
JR Z,@erDCv                  `+12+50tkt hop -> czas pomiędzy 0,1 a 0,2sek
` dalej +204tkt               
CCF                          `
LD A,#00                     `\zeruj
LD (#86F2),A                 `/liczbę bitów o odwrotnej polaryzacji
`
`        NC ='L', CY ='H'        |--->------->------>---|
RL D                         `  |7|6|5|4|3|2|1|0| -<-- |C|
`                                      Drej
`do &20 olewamy
`bajt+0: #86EB -> minuty
`21-24 -jednostki minut BCD (najstarszy24),
`25-27 -dziesiątki minut BCD (najstarszy27),
`28 - bit parzystości dla 21-27,
`bajt+1: #86EC -> godziny,
`29-32 -jednostki godzin BCD (najstarszy32),
`33-34 -dziesiątki godzin BCD (najstarszy34),
`35 - bit parzystości dla 29-34,
`bajt+2: #86ED -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
` *37-40 -jednostki dnia miesiąca BCD (najstarszy40),
` *41-42 -dziesiątki dnia miesiąca BCD (najstarszy42),
`bajt+3: #86EE -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`   ***45-47 -dzień tygodnia 1=PN, 7=NI (najstarszy44), 
`   ***48-51 -jednostki miesiąca w BCD (najstarszy48),
`   ***52 - dziesiątki miesiąca,
`        dzień tygodnia po sprawdzeniu jest przerzucany do:
`        bajt+5: #86F0 -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
`bajt+4: #86EF -> lata (#00 = 2000r)
`   ***53-56 -jednostki lat w BCD (najstarszy53),
`   ***57-60 -dziesiątki lat w BCD (najstarszy57),
`          luźno dla sprawdzenia bit parzystości:
`   ***61 - bit parzystości bajtów +2,+3,+4
LD A,(#86E8)                 `
CP #3D                       `
JR NZ,@DC_cd                 `+12+133tkt
RRC D                        `
JR @parDC                    `+12+46tkt
RET NC                @DC_cd `+133tkt
SUB #15                      ` ->- olewamy te bity
RET C                        `
LD HL,#86EB                  `
RRCA                         `
RRCA                         `
RRCA                         `
AND #07                      `  ->-|7|6|5|4|3|2|1|0| -->- |C|
ADD A,L                      `  |       D rej         |
LD L,A                       `  -----<---------<-------
RRC D                        `  
RR (HL)                      `  |C| ->- |7|6|5|4|3|2|1|0| ->-...
`                                            (HL)
LD HL,#86F1           @parDC `+46tkt adres bajtu z bitem parzystości i kroczku
LD A,(HL)                    `
XOR D                        `doparuj bit parzystości (7bit)
AND #80                      `zostaw tylko bit parzystości, a kroczek=0
LD (HL),A                    `
RET                          `
`----------------------------
`
`analizuj po przyjęciu narastającego
`trwa +722tkt
LD HL,#86E8           @HaDCF `+722tkt adr.bajtu numeru odczytanego bitu
LD DE,#86F1                  `adr.bajtu parity i kroczku analizy dogłębnej DCF
LD A,(DE)                    `
AND #03                      `
JP NZ,@DCFla                 `+12+676tkt
LD A,(DE)                    `odczytaj bit parzystości i kroczku
INC A                        `zwiększ kroczek
LD (DE),A                    `zapisz
LD BC,#86EB                  `adr. odebranych minut
LD A,(HL)                    `zmodyfikowany nr bitu
CP #1C                       `=&28 czyli odczytano bit parzystości minut
JR Z,@DCmin                  `+12+221tkt
INC BC                       `
CP #23                       `=&35 czyli odczytano bit parzystości godzin
JR Z,@DCgod                  `+12+237tkt 
INC BC                       `
CP #2A                       `=&42* czyli odczytano ostatni bit dnia miesiąca
JR Z,@DCdnm                  `+12+157tkt
INC BC                       `
CP #34                       `=&52*** czyli odczytano ostatni bit DT i miesiąca
JR Z,@DCmca                  `+12+247tkt
`        dalej +211tkt        
INC BC                       `
CP #3D                       `=&61*** czyli odczytano bit parzystości daty
RET NZ                       `to inna sekunda -> nie interesuje nas
LD A,(DE)                    `odczytaj bit parzystości
AND #80                      `tylko bit parzystości
JR NZ,@errDC                 `error parity
LD A,(BC)                    `#86EF =rok
CALL Z,@99>63                `+17+105tkt 
LD (BC),A                    `zapisz po przeliczeniu
RET C                        `gdy error to NC i wtedy kasuje nr bitu => znacznik erroru
LD A,#FF              @errDC `+31tkt error parity
LD (#86E8),A                 `zapisz error
RET                          `
LD A,(BC)             @DCmin `+221tkt odebrano bit parzystości minut
AND #7F                      `
CALL @99>63                  `+17+105tkt
JR NC,@errDC                 `error wartości połówek bajtu
LD (BC),A                    `zapisz po przeliczeniu
CP #3C                       `
JR NC,@errDC                 `error wartości minut
LD A,(DE)             @ifPaE `+57tkt odczytaj bit parzystości
AND #80                      `tylko bit parzystości
JR NZ,@errDC                 `+12+31tkt error parity
RET                          `
LD A,(BC)             @DCgod `+237tkt odebrano bit parzystości godzin
RRCA                         `
AND #3F                      `
CALL @99>63                  `+17+105tkt
JR NC,@errDC                 `error wartości połówek bajtu
LD (BC),A                    `zapisz po przeliczeniu
CP #18                       `
JR NC,@errDC                 `error wartości godzin
JR @ifPaE                    `+12+57tkt
LD A,(BC)             @DCdnm `+157tkt
RRCA                         `
RRCA                         `
AND #3F                      `
CALL @99>63                  `+17+92tkt(źle)
JR NC,@errDC                 `12+31tkt error wartości połówek bajtu
DEC A                        `
`#86ED -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
LD (BC),A                    `zapisz po przeliczeniu
RET                          `
LD A,(BC)             @DCmca `+247tkt
AND #07                      `
`42-44 -dzień tygodnia 1=PN, 7=NI (najstarszy44), 
DEC A                        `
LD (#86F0),A                 `zapisz DT
`#86F0 -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
LD A,(BC)                    `
RRCA                         `
RRCA                         `
RRCA                         `
AND #1F                      `miesiąc
CALL @99>63                  `+17+105tkt
JR NC,@errDC                 `error wartości połówek bajtu
DEC A                        `
`#86EE -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
LD (BC),A                    `zapisz po przeliczeniu
CP #0C                       `
JR NC,@errDC                 `+12+31tkt error wartości miesięcy
RET                          `
CP #03                @DCFla `+676tkt sprawdź ostatnią sekundę /2gi, 3ci... raz/, 
RET Z                        `
LD A,(HL)                    `zmodyfikowany nr bitu
CP #3D                       `=&61*** czyli odczytano bit parzystości daty
RET NZ                       `to inna sekunda -> nie interesuje nas
LD A,(DE)                    `odczytaj bit parzystości i kroczku
INC A                        `zwiększ kroczek
LD (DE),A                    `zapisz
AND #03                      `\który to już raz?
CP #02                       `/
JR NZ,@DCla2                 `hop -> to 3ci raz
`    tu obliczanie poprawności dnia tygodnia z odczytanym...
`#86ED -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#86EE -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#86EF -> lata (#00 = 2000r)  
LD HL,#86ED                  `
LD D,(HL)                    `
INC HL                       `
LD A,(HL)                    `będzie dla H
INC HL                       `
PUSH HL                      `
LD L,(HL)                    `
LD H,A                       `
CALL @jakDT                `+17+463 oblicz DT
`w Acc wychodzi dzień tygodnia roku L (#00 to 2000r),
`                              miesiąca H (#00=styczeń),
`                            i dnia D (#00 to 1 'pierwszy')
POP HL                       `
INC HL                       `
CP (HL)                      `
JR NZ,@errDC                 `hop -> error, bo obliczony jest inny
`#86F0 -> dni tygodnia   [#00 - #06, #00 to poniedziałek]
RET                          `
LD HL,#86EE           @DCla2 `+275tkt
`    tu obliczanie liczby dni w miesiącu, roku -> czy nie więcej
`#86EE -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#86EF -> lata (#00 = 2000r)  
PUSH HL                      `
LD A,(HL)                    `
INC HL                       `
LD E,(HL)                    `
CALL @DmArE                  `+17+149 w Acc wychodzi liczba dni w miesiącu A roku E
POP HL                       `
DEC HL                       `
`#86ED -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
CP (HL)                      ` obliczony_max - odebrany
JP C,@errDC                  `hop -> error, bo obliczony_max jest mniejszy!
RET                          `
`-----------------------------
`
`zamień dwie połówki BCD na wartość liczbową HEX
`wynik poprawny to CY 
`trwa: dla CY 105tkt
`          NC  92tkt(max) (error)
LD H,A                @99>63 `
RRCA                         `
RRCA                         `
RRCA                         `
RRCA                         `
AND #0F                      `
CP #0A                       `
RET NC                       `
LD L,A                       `
ADD A,A                      `
ADD A,A                      `
ADD A,L                      `
ADD A,A                      `
LD L,A                       `
LD A,H                       `
AND #0F                      `
CP #0A                       `
RET NC                       `
ADD A,L                      `
SCF                          `
RET                          `
`----------------------------
`
`ustaw zegar systemowy, jeśli to możliwe z DCF77
`trwa:+735tkt max              
LD DE,(#86EE)          @usDCF `
`odebrana informacja z DCF77:
`#86EB -> #88D0 minuty,         \
`#86EC -> #88D1 godziny,        /
`#86ED -> #88D2 dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#86EE -> #88D3 miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#86EF -> #88D4 lata (#00 = 2000r)
`#86F0 -> #88D5 dni tygodnia   [#00 - #06, #00 to poniedziałek]
LD HL,(#88D3)                 `miesiące & lata
`#88D0 -6b czas odczytany z DCF w naszym formacie, do porównania z kolejnym odczytanym
`          w celu akceptacji, kolejno min, godz, dnimca, mce, rok, dni-tyg
`          cykany przez zegar systemu raz na minutę (tylko minuty i godziny)
SUB A                         `NC I Acc=#00 /tzn. zgodne/
LD C,A                        `
SBC HL,DE                     `
JR Z,@DCzgo                   `hop -> zgodne C=0
LD C,#80                      `niezgodne C=bardzo_dużo
LD (#88D3),DE                 `zapisz nowe
LD DE,(#86EC)          @DCzgo `\godziny i
LD HL,(#88D1)                 `/dni miesiąca
AND A                         `NC
SBC HL,DE                     `
JR Z,@DCzg1                   `hop -> zgodne
LD C,#80                      `niezgodne
LD (#88D1),DE                 `zapisz nowe

LD A,(#86EB)           @DCzg1 `\odebrane minuty
LD B,A                        `/
LD HL,#88D0                   `adr. cykanych minut
LD A,(HL)                     `cykane minuty
LD (HL),B                     `przeładowano cały czas odebrany do cykanego
SUB B                         `cykane - odebrane
CP C                          `dla zgodnych 0 - #80 (bo niezgodne lata)
JR NC,@DCzgd                  `hop -> C mniejsze od Acc -> zgodne all, różnica minut w Acc
LD A,C                        `
INC A                  @DCzgd `przed INC:
`                     różnica między odebranym a cykanym w Acc w minutach lub =#80
`    po INC: gdy była różnica 1 minuty lub identyczne to Acc < #02 else =#81
`  #00 gdy późni 1 sek         
`  #01 gdy identyczne          
`  #02 gdy spieszy 1sek        
CP #03                        `
RET NC                        `wyjdź gdy rozbieżne czasy
DEC A `CP #01                 `
JR NZ,@DCFnt                  `hop -> nie identyczne
LD A,(#8003)                  `uł. sekund bieżącego czasu systemowego
CP #1A                        `uł. sekund jaki wpisuje przy ustawianiu z DCF
JR Z,@DCFpo                   `wyjdź bo identyczne =nie da się ustalić poprawki
LD A,(#8001)           @DCFnt `
`                      #00-nieustawiony
`                      #01-ustawiony z configu lub SMSa lub był w RAM (czyli też zły)
`                      #02-ustawiony z zegara NOKIA (może być zły) lub TPSA lub pierwszy DCF
`                      #03-ustawiony z delivery/DCF77/GPS ale dawno
`                      #04-ustawiony z delivery niedawno
`                      #05-ustawiony z DCF
CP #06                        `
RET NC                        `wyjdź bo lepszy czas niż DCF

LD HL,(#88D6)                 `\
`#88D6 -4b licznik/zegar pędzący z szybkością co 4 NMI a więc do ok. >18 godzin
`          służący do określania czasu (w funkcji naszego kwarca) od ostatniego 
`          ustawienia z DCF77 (GPS) może do wykorzystania dla określania poprawki naszego zegara
LD (#88DA),HL                 ` \
`#88DA -4b przepisane z powyższego w momencie ustalania poprawki
LD HL,(#88D8)                 ` /przepisz okres czasu za jaki ustalano poprawkę
LD (#88DC),HL                 `/
LD HL,#0000                   `\
LD (#88D6),HL                 ` |zeruj dla określania nowej poprawki
LD (#88D8),HL                 `/
LD HL,(#8003)                 `uł. sekund i sekundy
`#8003 -> ułamki sekund zliczane co czwarte NMI. 250 (#FA) przeskakuje na 0 (#00),
`#8004 -> sekundy,             
LD (#88DF),HL                 `zapisz dla ew. określenia poprawki
`#88DF -2b uł. sekund i sekundy w momencie ustawienia zegara systemu z DCF77
` ustaw zegar systemu z DCF77             
LD DE,#8003              `ułamki sekund zegara systemowego
LD A,#1A                 `ułamki sekund z wyprzedzeniem, aby dało się potwierdzić:
`                         3*32[ms] -> 0,096[s] -> 256 * 0,096 = &25 -> #19, przyjmujemy #1A
`                         to przy idealnie chodzącym zegarku
`   wyprzedzenie jest po to, aby przeskok minuty nastąpił przed porównaniem następnej
`   odebranej informacji DCF -co spowoduje ich identyczność gdy obie są poprawne
LD (DE),A                `
INC DE                   `
LD A,#01                 `sekundy =01 wyprzedzenia czasowego:
`   -raz dlatego że niewiadomo jak chodzi nasz zegar i kiedy będzie potwierdzenie DCF
`   -dwa dlatego że text przesyłany SMSem zawierający datę ma jakąś sekundę opóźnienia
`           chodzi oczywiście o wytworzenie textu w zakamarkach procedur obsł. NOKIA
LD (DE),A                `
INC DE                   `
LD HL,#86EB              `
LD BC,#0006              `
LDIR                     `prześlij czas z DCF77 do zegara systemowego
`                                 
LD HL,#8000                `\ustaw, że nieaktualne ASCIIdatyczasu
SET 0,(HL)                 `/
`                              
`LD A,#00                     `+00h poprawki godzin przy ich przeskoku
`LD (#86F5),A                 ` |-bez sensu, a jak ustawi z DCF minutę przed zmianą czasu?
LD HL,#8001                   `
LD A,(HL)                     `dla innego StatusTime niż #05 nie analizuj poprawki
CP #05                        `
LD A,#05                      `status =ustawiony z DCF
LD (HL),A                     `
JR NZ,@DCkon                  `hop -> ustawiłeś zegar z innego statusu, zapisz konfig
SUB A                         `\
LD (#88E1),A                  `/zeruj kroczek ew. analizy dla określania poprawki zegara
`  #88E1 -1b kroczek do analizy, zerowany w momencie odebrania poprawki
LD A,#30               @DCFpo `=&48 godzin uznajemy że jest ustawiony (DCF77)
LD (#809E),A                  `a później tylko orientacyjnie ustawiony
RET                           `
LD A,#01               @DCkon `\za 1 min (za 0:15)
LD (#807D),A                  `/  zapisz konfig
JR @DCFpo                     `hop -> ustaw pogarszacz czasu                           `
`------------------------------
`
LD A,#8A            @rsTPS `resetuj 8255 TPSA, brąz i dom
`------------------------------
`=1  bit7: zawsze 1            
`=00 bit6 i 5: tryb pracy rejestru A: 00-tryb 0, 01-tryb 1, 02 (i 03)- tryb 2
`=0  bit4: kierunek PA: 1-wejście, 0-wyjście
`=1  bit3: kierunek PC4-PC7: 1-wejście, 0-wyjście
`=0  bit2: tryb pracy PB: 0-tryb 0, 1-tryb 1
`=1  bit1:  kierunek PB: 1-wejście, 0-wyjście
`=0  bit0:  kierunek PC0-PC3: 1-wejście, 0-wyjście
`czyli w sumie 1000 1010 -> #8A
`------------------------------
LD BC,#4043                   `
OUT (C),A                     `P@ #4043
LD C,#40                      `PA #4040
LD A,#01                      `
OUT (C),A                     `PA #4040 = #01 czyli CS CML602B nieaktywny
` poniżej ustawiamy czas jaki musi trwać DET (dzwonek) aby przejść do etapu IncommingRing
`LD HL,#0030                      `=ok. 0,3 sekundy
`LD (#8736),HL                    `czas aby wiedzieć, czy nie skończył się dzwonek
RET                           `
`-------------------------------
`
`NOP                    @ansNO `odpowiedź na połączenie przychodzące (np.)
`#86A7 1b IncommingCallFlag
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic się nie dzieje,
`         1 --------------->ring lub dial,
`         dr vvv  G M ----->aktywność głośnika / mikrofonu (=0 to aktywny),
`         dr vvv      rd -->gdy zakończone połączenie to zakończone na ringu(=0) lub dialu (=1),
`         dr vvv        dN->gdy zakończone to przez kogo drugi/system (=0) lub NOKIA (=1),
`         1 011 xx00 => dzwoni, ale czas trwania dzwonka do 3 sekund
`         1 010 xx00 => dzwoni, czas trwania dzwonka powyżej 3 sekund
`         1 010 xx10 => rozmowa,
`         0 011 xx00 => po dzwonku uznanym za cynk,
`         0 010 xx00 => po dzwonku,
`         0 010 xx10 => po rozmowie,
`     np. 0 000 -po RESET...
`LD A,(#86A7)
`AND #F0
`CP #A0
`RET NZ
`
`#86B4 -> 1b numer: z kim/do kogo dzwonisz: #00-#09 pozycja w znanych numerach
`       po 10 wywołaniach CPIR procedurka poCPR robi tak:
`                                           #FF-zastrzeżony
`                                           #FE-nieznany /przeszuk cała ks.tel/
`                                           #FD-nieznany /NIE przeszuk cała ks.tel/
`                                           #FC-błędny
`                                          lub że rozpoznany (#00-#09) 
`                                               umownie  #0A -jako numer konfigu (20znakowy...)
`LD A,(#86B1)             `czas trwania dzwonka
`CP #03
`RET C
`
`LD A,(#86B4)
`CP #0A
`RET NC                      `RET bo nieznany numer
`
`#86A6 1b IncommingCallResponse
`        |7|6|5|4|3|2|1|0|
`         0 ? ? ? ? ? ? ?  =nic nie rób, czekaj na decyzję,
`         1 --------------->zrób to co określają bity 6-0 a później zmień biy 7 na =0,
`         1 ? ? 0 ? ? 0 0  =zakończ outgoing ring/dial
`         1 ? ? 0 G M 0 1  =odbierz połączenie używając G lub M lub GM lub wcale,(0=aktywny),
`         1 ? ? 0 ? ? 1 0  =odrzuć przychodzące połączenie ring/dial,
`
`LD A,#82                  `odrzuć ring/dial
``LD A,#81                  `odbierz ring/dial
`LD (#86A6),A
`RET
`-------------------------------
`
`analiza all do telefou stacjonarnego 
`125razy/sekundę tu jest          
`trwa (+475tkt+@_PZD_) lub (+226+... to co wykonuje) lub (+1066tkt)
`             +712tkt           +@IRrst =+1787tkt (#04) <-----
`                               +@IDrst =+1513tkt (#05)
`                               +@ORrst =+1650tkt (#06)
`                               +@ODrst =+1467tkt (#07)
`                               +@OMRrt = +951tkt (#08)
`        = +1187tkt    lub       +2013tkt 
`                                           
`    może trwać do +2566tkt max !!!
`
LD BC #4041               @TPSA_ `
IN A,(C)                         `
`bit0 IRQN \                     `
`   1 RXD  | CML602B             `
`   2 DET  /                     `
`   3 syg.420Hz                  `
`   4 monitor 230V               `
`   5 -?                         `
`   6 LowVolt                    `
`   7 HighVolt                   `
LD (#86F7),A                     `
LD B,A                           `Brej= bity CML602B, napięcia i 420Hz
AND #C0                          `
LD HL,(#86F9)                    `L= stan. H=czas
CP L                             `
`     odtąd trwa (+409tkt+@_PZD_) lub (+160+... to co wykonuje) lub (+1000tkt)
JR Z,@staly                      `hop =stan się nie zmienił
LD (#80BF),HL                    `zapamiętaj poprzedni stan
LD L,A                           `nowy stan
LD H,#00                         `czas od zmiany
JR @staZr                        `hop -> zapamiętaj stan i czas
INC H                     @staly `+52tkt+...niżej 
JR NZ,@staZr                     `hop -> czas się dograniczył, nie zapisuj
DEC H                            `cofnij o 1 bo przeszedł #FF
LD (#86F9),HL             @staZr `+36tkt+...niżej /zapisz stan i czas
LD A,(#86F8)                     `etap RST
SUB #04                          `
`     odtąd trwa (+327tkt+@_PZD_) lub (+78+... to co wykonuje) lub (+918tkt)
JR C,@st-By                      `hop -> stand-by jakiś
LD HL,@TbRST                     `adr. tabeli adresów obsługi stanów RST
CP #05                           `bezpiecznik
JP C,@jp(hl                      `+54+to co wykonuje
SUB A                            `\
LD (#86F8),A                     ` |zła wartość statusu RST, zeruj
RET                              `/
CP #FC                    @st-By `trwa +315tkt+@_PZD_ lub +906tkt 
`                                 = -#04 (minus) czyli Standby, słuchawka na widełkach
JR NZ,@asjlw                     `hop -> to stan inny niż słuchawka na widełkach
` tutaj słuchawka na widełkach    
BIT 2,B                          `DET z CML602B
JR Z,@asjlw                      `hop -> CML602B NIEwykrył sygnału dzwonka
LD A,(#80BE)                     `
`#80BE - 1b stoperek blokady gen. zdarzenia #14 TPSA (poł. przychodzące)
`          aktywowany po zaniku/pojawieniu się nap linii telefonicznej
`          oczywiście dłuższym niz pulsowe wybieranie numeru
`                gdy #00 to stoi =nie ma blokady,
`                gdy >0 to idzie i blokuje gen zdarzenia #14
`                     cyka co sekundę                          
AND A                            `
JR NZ,@asjlw                     `hop -> jest blokada na wykrywanie DET
`     odtąd trwa +286tkt+@_PZD_ lub +877tkt 
LD DE,#8736                      `\ 
LD A,(DE)                        ` | (na początku było tu #30 -? &48/125 =384[ms])
DEC A                            ` |czas dla uznania pierwszego dzwonka
LD (DE),A                        `/
`      odtąd trwa +258tkt+@_PZD_ lub +849tkt 
JP Z,@dzwon                      `hop -> DET to może być dzwonek telefonu
LD A,H                    @asjlw `trwa +248tkt+@_PZD_ lub +839tkt /czas
CP #20                           `#20-1 = &31/125= 0,25[s]
JR C,@ifPUL                      `-> tutaj chyba hop dla rozpoznania wybierania pulsowego...
`      odtąd trwa +237tkt+@_PZD_ lub +828tkt
LD A,L                           `bity napięcia 6 i 7
RLCA                             `\
RLCA                             `/z #00->#00 Stand-by
`                                    #40->#01 uszkodzenie/error
`                                    #80->#02 podniesiona słuchawka
`                                    #C0->#03 brak napięcia tel.
LD (#86F8),A                     `etap rst
LD D,A                           `
SUB #02                          `czy podniesiona słuchawka?
`LD A,#00    `(już jest #0)       `podniesiona słuchawka
`sprawdź tą wartość, bo przyczyną może być także zimny lut przy potencjometrze lub gdzieś
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni =0 \
`1 MODE \                      =0  \dla poprawnej pracy NE567
`2 ZP   | CML602B              =0  / =detektora sygnału 420Hz
`3 RXCK /                      =0 /
JR Z,@podHa                      `hop -> podniesiona słuchawka
` słuchawka na widełkach, brak nap lub uszkodzenie
LD A,#04                         `j.w. ZP=1 i brąz NIEaktywny
`0 brąz linia ->telefon dzwoni =0 
`1 MODE \                      =0 
`2 ZP   | CML602B              =1 
`3 RXCK /                      =0 
LD BC,#4042               @podHa `trwa +187tkt+@_PZD_ lub +778tkt+++
OUT (C),A                        `
LD A,D                           `TPSA etap (#86F8)
`    #00 Stand-by                    
` -> #01 uszkodzenie/error           
`    #02 podniesiona słuchawka       
` -> #03 brak napięcia tel.          
AND A                            `czy #00 ?
`        odtąd trwa +157tkt+@_PZD_ lub +748tkt
JP Z,@zrTPc                      ` #00 Stand-by -> zeruj bufory cyfr wybieranych tonowo i pulsowo
SUB #02                          `czy #02 ?
`        odtąd trwa +150tkt+@_PZD_ lub +741tkt 
JR Z,@ifPUL                      ` #02 podniesiona słuchawka
`                                `jeśli NC to był stan #03 brak napięcia tel.
`                                       CY to był stan #01 uszkodzenie/error
`        odtąd trwa +143tkt+@_PZD_ max
JR C,@erERR                      `hop -> stan #01 uszkodzenie/error
`        odtąd trwa +131tkt+@_PZD_ max
` tutaj stan #03 brak napięcia tel.
LD A,#05                         `\rusz cykany w dół stoperek blokady gen. zdarzenia
LD (#80BE),A                     `/poł. przychodzące
LD HL,#872D                      `1b czas trwania braku napięcia TPSA w sekundach (#00 to stoi)
LD A,(HL)                        `
AND A                            `czy chodzi?
`        odtąd trwa +110tkt+@_PZD_ max
JR NZ,@brTPs                     `hop -> tutaj już przyjęty, bo chodzi stoper
`        brak więc startuj pomiar czasu (czyli przyjmij)
LD A,#01                         `\
LD (HL),A                        `/startuj pomiar czasu braku nap. TPSA
RET                              `
CP #3C                    @brTPs `+98tkt+@_PZD_ czy <60 sekund?
RET C                            `tak -krócej, olej
SUB A                            `\
LD (HL),A                        `/zatrzymaj pomiar czasu trwania braku,
LD HL,(#8804)                    `czy upłynął czas od wysłania poprzedniego takiego zdarzenia?
LD A,H                           `\
OR L                             ` |jeśli blokada to nie wysyłaj
RET NZ                           `/
LD HL,#A8C0                      `cykany w dół co 1 sekundę [12h = 43200& [s] = #A8C0]
LD (#8804),HL                    `startuj stoper blokady wysyłania tego zdarzenia
LD BC,#0810                      `kod(#10) brak napięcia tel.
JP @_PZD_                        `wykonaj reakcję na podzdarzenie Brej
LD HL,#87E6               @erERR `+62tkt+@_PZD_ uszkodzenie/error
BIT 0,(HL)                       `
`   Z oznacza że nie było jeszcze generacji zdarzenia o kodzie #18 ERROR
SET 0,(HL)                       `ustaw błąd 
RET NZ                           `wyjdź, bo było już takie zdarzenie
LD BC,#0901                      `kod(#01) uszkodzenie/error
CALL @_PZD_                      `wykonaj reakcję na podzdarzenie Brej
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres miesiąca
RET NC                           `
INC HL                           `
LD (HL),#00                      `podkod zdarzenia -rodzaj usterki
`        tutaj usterka czujnika napięcia linii telefonicznej #00
RET                              `
LD A,H                    @ifPUL `+734tkt stan Stand-By krótszy niż 0,5[s] lub dłuższy niż 0,5[s]
AND A                            `A=czas, czy =0?
`              sprawdzaj czy to nie wybieranie pulsowe
`                    odtąd +726tkt
JR NZ,@BzStB                     `hop -> bez zmian stanu Stand-by
` zmiana StandBy nastąpiła właśnie
LD A,(#80BF)                     `to co było wcześniej L=stan
AND A `CP #00                    `czyli czy wcześniej było L,L czyli wysokie nap.
JR NZ,@poPul                     `hop -> inne niż wysokie napięcie
LD A,(#80C0)                     `to co było wcześniej H=czas
` czasy zawierają się w granicy #07 do #08...
CP #05                           `#05 to minimalny czas akceptowalny
JR C,@poPul                      `hop -> zły czas
CP #0B                           `#0A to maksymalny czas akceptowalny
JR NC,@poPul                     `hop -> zły czas
` tutaj mamy sytuację kiedy następiło zbocze opadające po
` impulsie wysokiego napięcia, o czasie akceptowalnym dla impulsu
` zliczymy więc jako impuls       
LD HL,#80C1                      `\
INC (HL)                         `/zlicz impuls
JR @poPul                        `hop -> już po zliczeniu
CP #0D                    @BzStB `+689tkt A=czas stanu napięciowego
`      tutaj bez zmiany Stand-by napięciowego
JR C,@poPul                      `hop -> inny czas niż dla 'wyjęcia' cyfry
LD A,L                           `
AND #C0                          `tylko bity napięć, i czy oba =L,L (=wysokie nap.)
JR Z,@kaBUF                      `hop -> kasuj bufor bo to nie napięcie podn. słuchawki
LD A,(#80C1)                     `licznik pulsów jednej cyfry
AND A                            `czy =0 ?
`                    odtąd +640tkt max
JR Z,@poPul                      `hop -> poza zakresem
`                    odtąd +238tkt max
CP #0B                           `czy <&11 ?
JR NC,@kaBUF                     `hop -> poza zakresem
CP #0A                           `dla &10 impulsów mamy cyfrę 0 (zero)
JR NZ,@no10c                     `
SUB #0A                          `odejmij &10
ADD A,#30                 @no10c `+203tkt aby był kod ASCII cyfry
LD B,A                           `
LD C,#40                         `wybieranie pulsowe
CALL @doBUN                      `dopisz znak ASCII Acc do bufora jeśli można
SUB A                     @kaBUF `+31tkt \zeruj licznik opadających zboczy
LD (#80C1),A                     `       /pulsów cyfry
RET                              `
`           teraz sprawdzimy czy coś tonowego mamy...
LD D,#00                  @poPul `+628tkt wygaś bity sterujące słuchawką i ISD... 
CALL @888rs                      `odczytaj rejestr stanu MT8880
BIT 0,A                          `czy MT8880 żąda przerwania?
JR Z,@poTon                      `hop -> nie ma IRQ w MT8880
BIT 2,A                          `czy jest odczytany bajt w MT8880?
JR Z,@poTon                      `hop -> nie ma bajtu w MT8880
LD D,#00                         `wygaś bity sterujące słuchawką i ISD... 
CALL @888ro                      `odczytaj bajt z odbiornika DTMF
`              odtąd w dół +244tkt +14tkt              
ADD A,#30                        `zamień na ASCII
CP #3A                           `
JR C,@gotTC                      `hop -> gotowe ASCII cyfry tonowej
JR NZ,@gtTcA                     `hop -> to nie cyfra '0'
SUB #0A                          `to cyfra '0'
JR @gotTC                        `hop -> gotowe ASCII cyfry tonowej
CP #3B                           `czy to '*'?
JR Z,@gotTB               @gtTcA `hop -> gotowe ASCII cyfry tonowej
CP #3C                           `+211tkt
LD A,#23                         `znak '#'
JR Z,@gotTC                      `hop -> gotowe ASCII cyfry tonowej
JR NC,@poTon                     `innych (wyższych znaków nie akceptujemy)
LD A,#2A                  @gotTB `znak '*'
LD B,A                    @gotTC `+176tkt
LD C,#80                         `wybieranie tonowe
CALL @doBUN                      `+17+137tkt dopisz znak ASCII Acc do bufora jeśli można
RET                              `
` jeśli jest (zerowany był po 1-szej i drugiej cyfrze) oznacza to że 
` centrala rozpoznała numer jako kompletny i zaczęła jego wybieranie
` czyli można będzie przejść do etapu wybierania numeru
LD HL,#8740               @poTon `+171tkt
LD A,(HL)                        `
`#8740 -1b kod zinterpretowanego sygnału 420Hz:
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`---                                                  
`               =#04 -syg. ciągły
`               =#05 -UFO =niezidentyfikowany
AND A                            `czy cisza?
RET Z                            `wyjdź bo cisza
CP #04                           `czy sygnał bąbel/zajętości/oczekiwania?
RET NC                           `ret ->nie, inny
`#873F -1b czas klasyfikacji finalnej (w próbkach co 32[ms])
DEC HL                           `\
LD A,(HL)                        `/odczytaj czas klasyfikacji
CP #15                           `czy trwa dłużej niż imp. zajętości?
RET C                            `wyjdź bo sygnał za krótko
LD A,(#8701)                     `liczba cyfr w buforze wychodzącym
AND #3F                          `bo bity 7 i 6 wskazują tone/pulse
CP #03                           `
RET C                            `2 lub mniej cyfr
LD HL,#873C                      `
RES 5,(HL)                       `zaznacz że nie było zdarzenia 'wybrano numer'
LD A,#05                         `\
LD (#872E),A                     `/inicjuj kroczek kompresji numeru tel.
LD A,#06                         `outgoing_ring
LD (#86F8),A                     `zapisz 
RET                              `
LD HL,#872D               @zrTPc `
LD A,(HL)                        `
AND A                            `
JR Z,@glutN                      `hop -> stał, więc oki
LD (HL),#00                      `zeruj bo już jest napięcie
` tutaj pojawiło się napięcie, rusz stoper blokady...
SUB A                     @glutN `+166tkt \zeruj bufory cyfr wybieranych tonowo i pulsowo bo
LD (#8701),A                     `        /odłożona słuchawka i zeruj typ: pulsowo/tonowo
` to l.znaków poł. stacjonarnego in/out wyzeruj, czyli brak numeru
`#80B3 - 1b sekundy od pierwszego wczytania konfigu po RESET,
`        stoi gdy 7bit=1 lub gdy =#00, else idzie co sekundę do góry
LD A,(#80B3)                     `\czy minęło kilka sekund od piwrwszego wczytania konfigu?
CP #0A                           `/ (bo wcześniej brak prefixu domyślnego)
RET C                            `
` teraz sprawdzaj czy zlecenie wybrania numeru i jeśli tak i warunki ok
` to zrób RTStryb #08...          
LD A,(#88A8)                     `spr czy jest zlecenie outgoing ring_dial
AND #0F                          `
CP #08                           `
RET NZ                           `ret -> brak zlecenia rozmowy wychodzącej
LD A,#08                         `outgoing_MY_number
LD (#86F8),A                     `zapisz etap rst
LD HL,#03F4 `#01F4               `\TimeGuard wybierania numeru =4[s]
LD (#88C0),HL                    `/ tzn. czas oczekiwania na sygnał ciągły po podniesieniu
`                                 słuchawki tel.
SUB A                            `\
LD (#88BF),A                     `/zeruj kroczek podetapu wybierania numeru
`SUB A                           `\wywal klasyfikację 420Hz jako sygnału ciągłego
LD (#8740),A                     `/
RET                              `
LD A,#04                  @dzwon `+330tkt tutaj DET CML602B świadczy o rozpoczęciu 
`                                    dzwonka telefonu
LD (#86F8),A                     `etap =04
SUB A                            `=00
LD (#86FB),A                     `podetap_etapu_04 =00
LD (#872E),A                     `=#00 wskaźnik interpretacji ASCII CIDa 
LD (#8701),A                     `=#00 długość ASCII odebranego numeru CIDa
LD (#8891),A                     `=#00 długość skompresowanego numeru telef. do zdarzeń
LD (#8717),A                     `=#00 długość ASCII odebranej daty/godziny
`        tutaj zapal brąza        
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni =1 
`1 MODE \                      =0 
`2 ZP   | CML602B              =1 
`3 RXCK /                      =0 
LD A,#05                         `j.w. ZP=1 i brąz aktywny
LD BC,#4042                      `adr. PC
OUT (C),A                        `
LD HL,#0000               @SsPdc `+225tkt start licznika czasu dzwonka/rozmowy
LD (#8738),HL                    `start
LD (#8739),HL                    `start
LD HL,#8004                      `adr daty i czasu aktualnego
LD DE,#872F                      `do zapamiętania
LD BC,#0007                      `7 bajtów
LDIR                             `142 =6*21+16
RET                              `
`---------------------------------
`
`dopisuje znak ASCII z Brej do bufora wybieranych znaków nru tel
`jeśli oczywiście jest w nim miejsce, i zaznacza że doszedł
`znak wybierany tonowo lub pulsowo wg Crej
`trwa +137tkt                       
LD HL,#8701               @doBUN `
`OLD #8892- &21b bufora podglądu wybierania numeru (pulsowego):
` #8892- 1b liczba cyfr (#00 to pusty bufor), 7bit=1 ->tone / 6bit=1 ->pulse
` #8893- &20b ASCII cyfr,
LD A,(HL)                        `\
OR C                             ` |dopisz rodzaj cyfry Tonowo/pulsowo
INC A                            `zwiększ liczbę znaków w buforze
LD (HL),A                        `/
AND #3F                          `bez bitów tone/pulse
CP #15                           `czy nie za dużo znaków już w buforze?
RET NC                           `ret -> pełny bufor =nie dopisuj
LD E,A                           `
LD D,#00                         `
ADD HL,DE                        `aktualny adres dla zapisania znaku
LD (HL),B                        `zapisz znak do bufora
SUB A                            `\=#00 = cisza
LD (#8740),A                     `/czyść rozpoznanie 420Hz
`#8740 -1b kod zinterpretowanego sygnału 420Hz:
`               =#00 -cisza, brak sygnału,
LD HL,#873C                      `
RES 6,(HL)                       `nie było skoku LH przy 420Hz
`#873C -1b 6bit =1 gdy był 420Hz -> kasowane po wybraniu pierwszej cyfry nru tel. poł. wych.
`                 aby wiedzieć kiedy znów pojawi się 420Hz co oznacza koniec numeru
`                 i rozpoczęcie wybierania
RET                              `
`-----------------------------------
`
` kroki telefonu stacjonarnego śledzenia i wybierania
DEFETYK @TbRST  `tabele adresów kroków dla:
DEFTABE IRrst  `#04 = incomming ring    +1787tkt <-----------------
DEFTABE IDrst  `#05 = incomming dial    +1513tkt
DEFTABE ORrst  `#06 = outgoing ring     +1650tkt
DEFTABE ODrst  `#07 = outgoing dial     +1467tkt
DEFTABE OMRrt  `#08 = outgoing MY        +951tkt 
`----------------------------------
`
`połączenie wychodzące wywoływane -śledzone
`postąp zgodnie ze zinterpretowanym sygnałem 420Hz,
`tzn. jeśli jest bąblowanie to czekaj,
`     jeśli będzie oczekiwanie na połaczenie to czekaj,
`     jeśli będzie cisza to przejdź do etapu ODial, chyba że odłożona jest słuchawka
`     jeśli będzie sygn. zajętości lub ciągły to czekaj,
`trwa +1650tkt max                       
LD HL,#873C               @ORrst `\
BIT 5,(HL)                       `/czy generowano już zdarzenie 'wybrano numer'?
JR Z,@gnZ15                      `+12+1362tkt /hop -> generuj zdarzenie
LD HL,(#86F9)                    `stan napięcia tel.L(słuchawka, error, brak) i jego czasH
LD A,L                           `stan
` #00-> Stand-by                  
` #40-> uszkodzenie/error         
` #80-> podniesiona słuchawka     
` #C0-> brak napięcia tel.        
CP #80                           `czy podniesiona słuchawka?
JR Z,@hanUp                      `+12+1582tkt hop -> podniesiona słuchawka
LD A,#3E                         `&63 * 8[ms] =0,5[s]
CP H                             `porównaj czas trwania tego stanu napięciowego
RET NC                           `wyjdź bo za krótko, stan nieustalony
SUB A                            `=#00
LD (#86F8),A                     `etap RSt =Stand-by
RET                              `
LD A,(#8740)              @hanUp `1582tkt tutaj podniesiona słuchawka
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły 
AND A                            `
RET NZ                           `ret -> podniesiona słuchawka, ale 420Hz jakiś sygnał
LD A,#07                         `etap ODial bo podniesiona, i cisza
LD (#86F8),A                     `zapisz etapRST =0 czli Stand-by bo odłożona słuchawka
LD BC,#0916                      `delta1_długość, kod(#16)=rozpoczęto rozmowę wychodzącą
CALL @PZ_TP                      `+17+1278tkt
JP @SsPdc                        `+10+225tkt -> start licznika, zapamiętanie momentu
LD A,(#872E)              @gnZ15 `+1362tkt skompresuj numer pierw
BIT 7,A                          `czy już skompresowany?
JP Z,@CIDan                      `+10+869tkt /hop -> zrób kroczek kompresji numeru
SET 5,(HL)                       `zaznacz że już generowano
LD BC,#0915                      `kod =wybrano numer
CALL @PZ_TP                      `+17+1278tkt delta1_długość, kod(#15)=wybrano numer
RET                              `
`----------------------------------
`
`rozmowa wychodząca śledzona        
`trwa +1451tkt max                 
LD HL,(#86F9)             @ODrst `stan napięcia tel.L(słuchawka, error, brak) i jego czasH
LD A,L                           `stan
CP #80                           `czy podniesiona słuchawka?
` #00-> Stand-by                   
` #40-> uszkodzenie/error          
` #80-> podniesiona słuchawka      
` #C0-> brak napięcia tel.         
RET Z                            `wyjdź bo podniesiona słuchawka
LD A,#3E                         `&62 * 8[ms] =0,5[s]
CP H                             `porównaj czas trwania tego stanu napięciowego
RET NC                           `wyjdź bo za krótko, stan nieustalony
SUB A                            `
LD (#86F8),A                     `zapisz etapRST =0 czli Stand-by bo odłożona słuchawka
LD BC,#0C17                      `
CALL @PZ_TP                      `+17+1278tkt delta1_długość, kod(#17)=zakończono rozmowę wychodzącą
EX DE,HL                  @endTP `+81tkt adr. do HL
`LD (HL),#02                      `kod w LOGu zdarzenia ozn. 3bajty czasu s/m/g
`INC HL                           `
LD A,(#8738)                     `sek,
LD DE,(#8739)                    `min i godz
LD (HL),A                        `\ sek.
INC HL                           ` |
LD (HL),E                        ` |min.
INC HL                           ` |zapisz czas trwania dzwonka
LD (HL),D                        `/ godz.
RET                              `
`----------------------------------
`
`realizuje komplet podczas przychodzcego dzwonka
`rozpoznanie numeru dzwoniacego (czasu) i wykrycie podniesionej słuchawki
`trwa: max. +tkt = +94tkt + to_co_wykonuje (+tkt) 
`         1787tkt= +94    + 1693
` może max trwać 2340tkt                 
LD A,(#86FB)              @IRrst `przychodzący dzwonek
CP #0E                           `zabezpieczenie...
LD HL,@4_pde                     `adr. wykonawczy podetapw etapu 4 rst
JP C,@jp(hl                      `+54+... to co wykonuje
` jeśli zła wartość podetapu to przechodzi tutaj...
LD A,#0D                         `\
LD (#86FB),A                     ` |skocz do kroku
JP @erFSk                        `/
`---                              
DEFETYK @4_pde  `tabele adresów kroków dla:
DEFTABE 4_pd0  `#00 = podetap 0 czekaj na koniec pierwszego dzwonka             +94tkt max +2246tkt
DEFTABE 4_pd1  `#01 =         1 czekaj na modulację FSK                       +1662tkt
DEFTABE 4_pd2  `#02 =         2 czekaj na bajt rozbiegówki #55                +1693tkt <-----
DEFTABE 4_pd3  `#03 =         3 czekaj na bajt nagłówka #80                   +1693tkt
DEFTABE 4_pd4  `#04 =         4 odbierz l.bajtów całości CIDa                 +1693tkt
DEFTABE 4_pd5  `#05 =         5 odbierz nagłówek podtreści                    +1693tkt
DEFTABE 4_pd6  `#06 =         6 odbierz l.bajtów podtreści ważnej             +1693tkt
DEFTABE 4_pd7  `#07 =         7 odbierz bajty podtreści ważnej                +1693tkt
DEFTABE 4_pd8  `#08 =         8 odbierz l.bajtów podtreści nieważnej          +1693tkt
DEFTABE 4_pd9  `#09 =         9 odbierz bajty podtreści nieważnej             +1693tkt
DEFTABE 4_pdA  `#0A =         A odbierz bajt autosumy                         +1693tkt
DEFTABE 4_pdB  `#0B =         B sprawdzaj, czy trwa przerwa przed dzwonkiem/  +1656tkt
`                                                       podniesiono słuchawkę         
DEFTABE 4_pdC  `#0C =         C sprawdzaj, czy trwa dzwonek                   +1528tkt
DEFTABE erFSk  `#0D =         D kończ rozpoznanie FSK bo upłynęło 5 sekund     +179tkt
`---                              
BIT 2,B                   @4_pd0 `+94tkt spr czy skończył się dzwonek
`bit0 IRQN \                     `
`   1 RXD  | CML602B             `
`   2 DET  /                     `
`   3 syg.420Hz                  `
`   4 monitor 230V               `
`   5 -?                         `
`   6 LowVolt                    `
`   7 HighVolt                   `
RET NZ                           `ret -> się nie skończył
` tutaj skończył się dzwonek, przełącz na wykrywanie modulacji FSK
LD BC,#4042                      `adr. PC
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni =0 
`1 MODE \                      =1 
`2 ZP   | CML602B              =0 
`3 RXCK /                      =0 
LD A,#02                         `j.w. ZP=1 i brąz nieaktywny
OUT (C),A                        `
LD A,#05                         `\ustaw 5sec TimeGuarda
LD (#86F6),A                     `/
LD HL,#86FB               @incPD `+32tkt adr bajtu podetapu
INC (HL)                         `zwiększ podetap
RET                              `
`---                              
BIT 2,B                   @4_pd1 `+1662tkt spr czy rozpoznano modulację FSK
JR NZ,@incPD                     `hop => rozpoznano => zwiększ podetap
LD HL,(#86F9)             @inHAN `+1647tkt sprawdź, czy podniesiona słuchawka tel.
LD A,H                           `
CP #40                           `czy czas 64/125 >0,5sek?
RET C                            `za krótko
LD A,L                           `tylko bity 7 i 6 czyli wart nap. linii telef.
CP #80                           ` #80 -podniesiona słuchawka
RET NZ                           `NIE podniesiona słuchawka (np. na widełkach)
`
` tutaj ew. coś aby nie korzystał z informacji CIDa... ???
`                                 
JP @HndUp                        `+10+1589tkt hop -> podniesiona słuchawka
`---                              
` @4_pd2 trwa: gdy brak bajtu to 1693tkt max
`                  jest bajt to 831tkt max
CALL @RdCMX               @4_pd2 `+1693tkt odczytaj bajt z CMXa
`                        +17tkt gdy CY
`                       +751tkt gdy NC
JR C,@inHAN                      `+12+1647tkt jr =brak bajtu, czy podniesiona słuchawka?
CP #55                           `bajt rozbiegówki
RET NZ                           `wyjdź bo inny niż rozbiegówka
JR @incPD                        `hop => bajt rozbiegówki => zwiększ etap
`---                              
` @4_pd3 trwa: gdy brak bajtu to 1693tkt max
`                  jest bajt to 844tkt max
CALL @RdCMX               @4_pd3 `odczytaj bajt z CMXa
`                        +17tkt gdy CY
`                       +751tkt gdy NC
JR C,@inHAN                      `+12+1647tkt jr =brak bajtu, czy podniesiona słuchawka?
CP #80                           `1-szy bajt treści po rozbiegówce
RET NZ                           `wyjdź bo inny niż rozbiegówka
LD (#86FC),A                     `startuj bajt autosumy FSK
JR @incPD                        `hop => zwiększ petap
`---                              
` @4_pd4 trwa: gdy brak bajtu to 1693tkt max
`                  jest bajt to 832tkt max
CALL @RdCMX               @4_pd4 `+827tkt odczytaj bajt z CMXa
`                        +17tkt gdy CY
`                       +751tkt gdy NC
JR C,@inHAN                      `+12+1647tkt jr =brak bajtu, czy podniesiona słuchawka?
` to bajt =liczbie bajtów jeszcze do odczytania PO których jest autosuma
LD (#86FD),A                     `startuj bajt autosumy FSK
JR @incPD                        `hop => zwiększ petap
`---                              
CALL @RdCMX               @4_pd5 `+1693tkt odczytaj bajt z CMXa
`                        +17tkt gdy CY
`                       +751tkt gdy NC
JR C,@inHAN                      `+12+1647tkt jr =brak bajtu, czy podniesiona słuchawka?
` to bajt nagłówka podtreści      
CP #01                           `
LD B,#06                         `podetap odczytu daty i czasu
LD HL,#8717                      `adres dla daty i czasu
JR Z,@CIDda                      `hop -> data i czas
CP #02                           `
LD L,#01 `LD HL,#8701            `adres dla numeru telefonu
JR Z,@CIDda                      `hop -> numer telefonu
` też nagłówek #04 i "P" gdy zastrzeżony...
CP #04                           `
JR Z,@CIDda                      `hop -> numer telefonu
` tutaj inny nagłówek             
LD B,#08                         `podetap odczytu nieważnej-innej podtreści
LD A,B                    @CIDda `
LD (#86FB),A                     `podetap
LD (#86FF),HL                    `adres dla bajtów
LD A,(#86FD)              @_dcLB `+66tkt \
DEC A                            `       |zmniejsz liczbę bajtów do odebrania
LD (#86FD),A                     `       /
RET NZ                           `ret wyjdź do ustalonego podetapu
` tutaj wejdź w podetap odbioru autosumy
LD A,#0A                         `
LD (#86FB),A                     `zmiana podetapu na odczyt autosumy
RET                              `
`---                              
CALL @RdCMX               @4_pd6 `+1693tkt odczytaj bajt z CMXa
JR C,@inHAN                      `jr =brak bajtu, czy podniesiona słuchawka?
` odbiór l.bajtów podtreści do odbioru
LD HL,(#86FF)                    `adres dla bajtów
CP #16                           `
JR NC,@erFSk                     `+12+179tkt błąd -> zbyt dużo bajtów w podtreści
LD (HL),A                        `l.b.odebranej podtreści
INC HL                           `
LD (#86FF),HL                    `adres dla bajtów
LD (#86FE),A              @__4p6 `+127tkt l.b.podtreści do odebrania
CALL @incPD                      `+17+32tkt zwiększ petap na odbiór treści
JR @_dcLB                        `+12+66tkt odlicz bajt
`---                              
CALL @RdCMX               @4_pd7 `+1693tkt odczytaj bajt z CMXa
JR C,@inHAN                      `jr =brak bajtu, czy podniesiona słuchawka?
` odbiór bajtów treści podtreści  
LD HL,(#86FF)                    `adres dla bajtów
LD (HL),A                        `zapisz
INC HL                           `
LD (#86FF),HL                    `adres dla bajtów
LD A,(#86FE)              @__4p7 `+135tkt l.b.podtreści do odebrania
DEC A                            `
LD (#86FE),A                     `l.b.podtreści do odebrania
JR NZ,@_dcLB                     `odlicz bajt
LD A,#05                         `petap odczytu nagłówka
LD (#86FB),A                     `zapisz
JR @_dcLB                        `+12+66tkt odlicz bajt
`---                              
CALL @RdCMX               @4_pd8 `+1693tkt odczytaj bajt z CMXa
JP C,@inHAN                      `jr =brak bajtu, czy podniesiona słuchawka?
` odbiór l.bajtów nieważnej podtreści
JR @__4p6                        `+12+127tkt
`---                              
CALL @RdCMX               @4_pd9 `+1693tkt odczytaj bajt z CMXa
JP C,@inHAN                      `jr =brak bajtu, czy podniesiona słuchawka?
` odbiór nieważnych bajtów treści podtreści  
JR @__4p7                        `+12+135tkt
`---                              
LD A,#55                  @erFSk `+179tkt błąd w FSK, traktuj jak ze złą autosumą
LD (#86FC),A                     `zapisz złą autosumę
JR @_4pdA                        `
`---                              
CALL @RdCMX               @4_pdA `+1693tkt odczytaj bajt z CMXa
JP C,@inHAN                      `jr =brak bajtu, czy podniesiona słuchawka?
` odczytano ostatni bajt =bajt autosumy,
` przełączamy teraz na detekcję dzwonka lub podniesienia słuchawki
LD BC,#4042               @_4pdA `+147tkt adr. PC
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni =0 
`1 MODE \                      =0 
`2 ZP   | CML602B              =1 
`3 RXCK /                      =0 
`4 D0   \                         
`5 D1   | MT8880C                 
`6 D2   |                         
`7 D3   /                         
LD A,#04                         `j.w. ZP=1 i brąz nieaktywny
OUT (C),A                        `
LD A,(#86FC)                     `odczytaj autosumę
AND A                            `
JR NZ,@zlaa$                     `hop => zła autosuma
LD A,#01                         `\
LD (#872E),A                     `/kroczek analizy CIDa startuj
LD HL,#0330               @zlaa$ `+74tkt /max. czas ok. 6,5[s] oczekiwania na dzwonek/przerwę
`         sam młodszy bajt też w okoliczności pierwszego dzwonka...
LD (#8736),HL                    `
LD A,#0B                         `\petap zmień
LD (#86FB),A                     `/
SUB A                            `\zakończ TimeGuarda 5 sekundowego
LD (#86F6),A                     `/
RET                              `
`---                              
BIT 2,B                   @4_pdB `+1656tkt
` #4041 PB IN                     
` 0 IRQN \                        
` 1 RXD  | CML602B                
` 2 DET  /                        
` 3 syg.420Hz                     
` 4 ?monitor 230V                 
` 5 -?                            
` 6 LowVolt                       
` 7 HighVolt                      
JR NZ,@jeDry                     `hop =zaczął dzwonić dzwonek
` tutaj nadal brak dzwonka        
LD HL,(#86F9)                    `stan bitów nap linii tel i czas od zmiany
LD A,H                           `czas
CP #19                           `25/125s >0,2[s]
JR C,@maCZa                      `hop =mały czas
LD A,L                           `tylko bity 7 i 6 czyli wart napięcia linii telef.
CP #80                           ` #80 -podniesiona słuchawka
JR NZ,@maCZa                     `hop =słuchawka na widełkach
`     tutaj brak dzwonka, podniesiona słuchawka przez 0,1[s]
LD A,#05                  @HndUp `+1589tkt \incomming dial
LD (#86F8),A                     `         /
LD BC,#4042                      `adr. PC
LD A,#00                         `brąz nieaktywny
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon NIEdzw =0 
`1 MODE \                      =0 \
`2 ZP   | CML602B              =0  |aby zasilić wzmacniacz do wykrywania
`3 RXCK /                      =0 / tonu przez NE567
OUT (C),A                        `
LD BC,#0912                      `delta1_długość, kod(#12)=rozpoczęto rozmowę przychodzącą
CALL @PZ_TP                      `+17+1278tkt 
JP @SsPdc                        `+10+225tkt -> start licznika, zapamiętanie momentu
`---                              
LD A,#05                  @jeDry `+97tkt /z brązem
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni =1 
`1 MODE \                      =0 \
`2 ZP   | CML602B              =1  |
`3 RXCK /                      =0 / 
LD BC,#4042                      `
OUT (C),A                        `
LD HL,#0330                      `max. czas ok. 6,5[s] oczekiwania na dzwonek/przerwę
`       sam młodszy bajt też w okoliczności pierwszego dzwonka...
LD (#8736),HL                    `
JP @incPD                        `+10+32tkt
LD HL,(#8736)             @maCZa `+1508tkt \
DEC HL                           `          |cyknij czas trwania dzwonka...
LD (#8736),HL                    `         /
LD A,H                           `\
OR L                             `/czy =0?
JR NZ,@trwCD                     `+12+1341tkt
` tutaj minął czas oczekiwania na dzwonek/przerwę
` sprawdź czy nie jest aktywny stoper blokujący po zaniku/pojawieniu się nap na linii tel.
LD BC,#0C14                      `
CALL @PZ_TP                      `delta1_długość, kod(#14)=poł. nieodebrane z numeru, czas dzwonka
LD HL,#0030               @fnCAL `+150tkt \
LD (#8736),HL                    `        /czas do uznania pierwszego dzwonka
SUB A `LD A,#00                  `\
LD (#86F8),A                     `/etap Stand-by 
JP @endTP                        `+10+97tkt
LD HL,#872E               @trwCD `+1341tkt
LD A,(HL)                        `
BIT 7,A                          `czy już nadano zdarzenie do logu?
` jeszcze 1316tkt                  
JR Z,@CIDan                      `hop -> analizuj odebranego CIDa
` jeszcze 1309tkt                  
SUB A                            `
LD (HL),A                        `
LD BC,#0911                      `
JP @PZ_TP                        `delta1_długość, kod(#11)=poł. przychodzące z numeru
DEC A                     @CIDan `+869tkt bo pierwszy krok jest #01
CP #10                           `bezpiecznik
LD HL,@NRana                     `adr. tabeli adresów kroków interpretacji CIDa
JP C,@jp(hl                      ` =+54+to co wykonuje (+max784tkt)
SUB A                            `\troche nieudolne
LD (#872E),A                     `/ale zawsze jakoś odblokuje...
RET                              `
`---                              
BIT 2,B                   @4_pdC `+1528tkt + analizaCIDa
` #4041 PB IN                     
` 0 IRQN \                        
` 1 RXD  | CML602B                
` 2 DET  /                        
` 3 syg.420Hz                     
` 4 ?monitor 230V                 
` 5 -?                            
` 6 LowVolt                       
` 7 HighVolt                      
JR NZ,@maCZa                     `+12+1508tkt /hop =nadal dzwoni dzwonek
` tutaj przestał właśnie dzwonić dzwonek 
LD A,#04                         `bez brąza
LD BC,#4042                      `
OUT (C),A                        `
LD HL,#0330                      `max. czas ok. 6,5[s] oczekiwania na dzwonek/przerwę
`       sam młodszy bajt też w okoliczności pierwszego dzwonka...
LD (#8736),HL                    `
LD A,#0B                         `pdetap na B czyli oczekiwanie na dzwonek
LD (#86FB),A                     `
RET                              `
`---------------------------------
`
`sprawdź czy w CML602B jest bajt i odczytaj go, dolicz do autosumy
`fala prostokątna wymagana przez CML602B to czasy większe niż poniżej:
`               upRXCK -1us-> readRXD -1us-> downRXCK -1us-> upRXCK
` dla tej proc: upRXCK -4us-> readRXD -9,75us-> downRXCK -7us-> upRXCK
`wyjście CY =brak bajtu, NC =jest bajt bajt w Acc
`trwa: +751tkt(NC) lub +17tkt(CY) 
BIT 0,B                   @RdCMX `sprawdź czy jest i odczytaj bajt z rejestru CML602B
SCF                              `
RET NZ                           `ret bo nie ma bajtu CY
LD H,#08                         `
LD DE,#0A02                      `bity CMXa w czasie odczytywania bajtu
LD BC,#4042                      `
`#4042 PC 0-3 OUT / 4-7 IN        
`0 brąz linia ->telefon dzwoni 0  
`1 MODE \                      1  
`2 ZP   | CML602B              0  
`3 RXCK /                      1  
`4 D0   \                         
`5 D1   | MT8880C                 
`6 D2   |                         
`7 D3   /                         
` już 45tkt
OUT (C),D                 @Rx_ck ` [#0A]
DEC C                            `
IN A,(C)                         `
RRCA                             `
RRCA                             `
RR L                             `
INC C                            `
OUT (C),E                        ` [#02]
DEC H                            `
`  jedno przejście pętli bez JR to +71tkt
JR NZ,@Rx_ck                     `
`  osiem razy pętla trwa +659tkt  
`  jeszcze 47tkt
LD DE,#86FC                      `adres autosumy
LD A,(DE)                        `odczytaj autosumę
ADD A,L                          `dodaj do autosumy
LD (DE),A                        `zapisz autosumę
LD A,L                           `odczytany bajt
AND A                            `NCarry
RET                              `
`---------------------------------
`                                 
DEFETYK @NRana  `tabele adresów kroków dla: max trwa +784tkt
DEFTABE MOan1  `#01 =  +748tkt 
DEFTABE MOan2  `#02 =  +361tkt
DEFTABE MOan3  `#03 =  +784tkt <-----
DEFTABE NRan1  `#04 =  +222tkt    \spr. czy to nie zastrzeżony
DEFTABE NRan2  `#05 =  +148tkt    \czyść wszystko
DEFTABE NRan3  `#06 =  +428tkt    |cyfry 0 i 1
DEFTABE NRan3  `#07 =  +428tkt    |cyfry 2 i 3
DEFTABE NRan3  `#08 =  +428tkt    |cyfry 4 i 5
DEFTABE NRan3  `#09 =  +428tkt    |cyfry 6 i 7
DEFTABE NRan3  `#0A =  +428tkt    |cyfry 8 i 9
DEFTABE NRan3  `#0B =  +428tkt    |cyfry 10 i 11
DEFTABE NRan3  `#0C =  +428tkt    |cyfry 12 i 13
DEFTABE NRan3  `#0D =  +428tkt    |cyfry 14 i 15
DEFTABE NRan3  `#0E =  +428tkt    |cyfry 16 i 17
DEFTABE NRan3  `#0F =  +428tkt    |cyfry 18 i 19
DEFTABE NRa10  `#10 =   +31tkt /zakończ rozpoznawanie numeru
`-----------------------------------
`zmiania 2 znaki ASCII cyfr na liczbę do Acc
`wyjście: NC=error, CY=poprawna zamiana
`trwa: +107tkt max
LD A,(HL)                 @_chnG `
SUB #30                          `
CP #06                           `bo max &59
RET NC                           `ret -> zła cyfra pierwsza
LD B,A                           `
ADD A,A                          `*2
ADD A,A                          `*4
ADD A,B                          `*5
ADD A,A                          `*&10
LD B,A                           `
INC HL                           `
LD A,(HL)                        `
SUB #30                          `
CP #0A                           `
RET NC                           `ret -> zła cyfra druga
ADD A,B                          `mamy już z dwóch cyfr
INC HL                           `
SCF                              `CY= poprawna zamiana
RET                              `
`-----------------------------------
`
`zamienia datę/czas otrzymany od CIDa z tel. stacjonarnego 
`na nasz format czasu, jeśli jest taka potrzeba ustawia zegar systemu
`trwa +748tkt max                 
LD HL,#8717               @MOan1 `
LD A,(HL)                        `
CP #08                           `
JP NZ,@zlaMO                     `hop -> zła długość, wyjdź
LD DE,#8724                      `adres dla miesiąca przeliczonego
INC HL                           `
`          47                     
CALL @_chnG                      `124tkt =+17+107
JP NC,@zlaMO                     `hop -> złe znaki miesiąca
DEC A                            `zmiana na nasz zakres
CP #0C                           `

JR NC,@zlaMO                     `hop -> zła wartość miesiąca

LD (DE),A                        `mamy miesiąc
DEC DE                           `
`         209tkt =+162tkt         
CALL @_chnG                      `
JR NC,@zlaMO                     `hop -> złe znaki dnia
DEC A                            `zmiana na nasz zakres
CP #1F                           `
JR NC,@zlaMO                     `hop -> zła wartość dnia
LD (DE),A                        `mamy dzień
DEC DE                           `
`         371=+162tkt             
CALL @_chnG                      `
JR NC,@zlaMO                     `hop -> złe znaki godziny
CP #18                           `
JR NC,@zlaMO                     `hop -> zła wartość godziny
LD (DE),A                        `mamy godzinę
DEC DE                           `
`         529=+158tkt              
CALL @_chnG                      `
JR NC,@zlaMO                     `hop -> złe znaki minuty
CP #3C                           `
JR NC,@zlaMO                     `hop -> zła wartość minuty
LD (DE),A                        `mamy minutę
DEC DE                           `
`         687=+158tkt             
SUB A                            `=#00 ???
LD (DE),A                        `mamy sekundy
`         704=+17tkt              
JP @NRaUP                        `+42tkt =+10+32
`---                              
`trwa +361tkt max                 
LD HL,(#8723)             @MOan2 `L=dni, H=miesiące odebrane z TPSA
LD DE,(#8007)                    `E=dni, D=miesiące naszego zegara
AND A                            `NC
SBC HL,DE                        `jeśli CY to rok bez zmian, gdy NC to rok =bieżący +1
LD A,(#8009)                     `
JR NC,@01_01                     `
INC A                            `
LD (#8725),A              @01_01 `mamy rok
LD E,A                           `rok
LD A,(#8724)                     `miesiąc
CALL @DmArE                      `+17+149 w Acc wychodzi liczba dni w miesiącu A roku E
INC A                            `
LD B,A                           `max dni+1
LD A,(#8723)                     `dni z TPSA (sprawdzane)
SUB B                            `zawsze powinno być CY
JR NC,@zlaMO                     `+60tkt =+12+48tkt hop -> złe dni miesiąca
JR @NRaUP                        `+44tkt =+12+32
`---                               
`oblicza dzień tygodnia i przepisuje czas do zegara
`trwa max. +784tkt
LD HL,(#8724)             @MOan3 `
LD A,L                           `
LD L,H                           `L=#8725 
LD H,A                           `H=#8724 
`         `#8723 <- dni m-ca przeliczone
`         `#8724 <- miesiąc przeliczony
`         `#8725 <- rok oszacowany
LD A,(#8723)                     `
LD D,A                           `D=#8723 
CALL @jakDT                 `w Acc wychodzi dzień tygodnia roku L (#00 to 2000r)
`                            z miesiąca H (#00=styczeń) i dnia D (#00 to 1 'pierwszy')
LD (#800A),A                     `dzień tygodnia
`#8004 -> sekundy        `#8720 <- sekundy =#00
`#8005 -> minuty         `#8721 <- minuty przeliczone
`#8006 -> godziny        `#8722 <- godziny przeliczone
`#8007 -> dni miesiąca   `#8723 <- dni m-ca przeliczone
`#8008 -> miesiące       `#8724 <- miesiąc przeliczony
`---                              
`#8009 -> lata           `#8725 <- rok oszacowany
`#800A -> dni tygodnia            
LD HL,#8720                      `\
LD DE,#8004                      ` \prześlij ustaloną date/czas do zegara
LD BC,#0006                      ` /=ustaw zegar
LD A,(#8001)                     `StatusTime
CP #01                           `czy =#01 /bo mógł się przecież zmienić/
JR NZ,@zlaMO                     `hop -> inny StatusTime
LDIR                             `/
`                                  
LD HL,#8000                `\ustaw, że nieaktualne ASCIIdatyczasu
SET 0,(HL)                 `/
`                                  
LD A,#02                         `\StatusTime
LD (#8001),A                     `/
SUB A                     @zlaMO `+48tkt\zeruj odebraną informację o dacie/czasie
LD (#8717),A                     `      /
LD A,#04                         `\przejdź do analizy numeru tel.
LD (#872E),A                     `/
RET                              `
`---                              
LD A,(#8701)              @NRan1 `+222tkt
SUB #01                          `czy to zastrzeżony (długości 1 znaku)?
JR NZ,@NRaUP                     `hop -> NIE zastrzeżony
CALL @NRa2_                      `+17+135tkt tutaj zastrzeżony, więc czyść numer
JR @NRa10                        `+12+31tkt
`---                              
LD A,(#8701)              @NRan2 `+148tkt
LD (#8891),A              @NRa2_ `+135tkt
LD HL,#0000                      `
LD (#8892),HL                    `
LD (#8894),HL                    `
LD (#8896),HL                    `
LD (#8898),HL                    `
LD (#889A),HL                    `
`#8701 -&22 bajty długość + treść ASCII numeru dzwoniącego  (1+&21) też numeru wychodzącego T/P
`      w przypadku wychodzącego połączenia bity 7i6 (#8701) oznaczają odpow. ton/puls gdy =1
`         kompresowany następnie do #8891
`---                               
`#8891- &11 (#0B) bajtów numeru tel. stacjonarnego skompresowanego z #8701 in/out,
`       zarówno CID jak i tone/pulse
`   #8891- 1b liczba cyfr i tone/pulse,
`   #8892- #889B ->&10 do &20 cyfr skompresowanych 2 w jednym bajcie (jak w GSM), uzupełnione #F0
`                  i reszte zera...
LD HL,#872E               @NRaUP `+32tkt
INC (HL)                         `
RET                              `
`---------------------------------
`
`zamienia dwa znaki ASCII cyfr (i gwiazdka i chasz) na 2 razy 4bity do jednego bajtu
` pobiera z (HL) i (HL+1) wynik w (DE)
` sprawdza też czy nie skończyły się znaki do zamiany itd.
`trwa max +428tkt
LD HL,#8702               @NRan3 `z
LD DE,#8892                      `do
`--- oblicz adresy ---            
LD A,(#872E)                     `krok
SUB #06                          `
LD B,A                           `zapamietaj dla drugiej delty adresu
AND A                            `czyli CY=0 /DEC A nie zmienia CY/
RLCA                             `*2 i wpisz CY na bit0
LD C,A                           `zapamiętaj numer cyfry
ADD A,L                          `\założenie że nie przeskok starszego bitu
LD L,A                           `/
LD A,B                           `
ADD A,E                          `\założenie że nie przeskok starszego bitu
LD E,A                           `/
LD A,(#8701)                     `nieskompresowana l.cyfr &bity tone/pulse
AND #1F                          `tylko l.cyfr
INC C                            `aby było CY gdy równe...
SUB C                            `porównaj to co zrobiliśmy z tym co było do zrobienia
INC A                            `aby dalej łatwiej, nie zmienia CY
LD C,A                           `
JR C,@NRa10                      `+12+31tkt hop -> zakończ
CALL @A__CH                      `+17+89tkt
`AND #0F                         `
LD B,A                           `
INC HL                           `
DEC C                            `czy =0?
JR NZ,@NRzdr                     `hop -> druga cyfra
LD B,#F0                         `
JR @NR#0F                        `hop -> uzupełnij #F0
CALL @A__CH               @NRzdr `+177tkt      /+17+89tkt
`AND #0F                         `
RLCA                             `
RLCA                             `
RLCA                             `
RLCA                             `
OR B                      @NR#0F `+55tkt
LD (DE),A                        `
JR @NRaUP                        `+12+32tkt
`---------------------------------
`
`zamienia kod ASCII znaku na kod do połówki bajtu
`trwa +89tkt max                  
LD A,(HL)                 @A__CH `+89tkt
SUB #30                          `
JR C,@sprCH                      `+12+63tkt hop -> inny znak, sprawdź czy * lub #
CP #0A                           `
RET C                            `już przekształcona cyfra
LD A,#0D                  @innCH `+18tkt kod inny 'A' dla DTMF
RET                              `
CP #F3                    @sprCH `+63tkt #F3 = #23 (kod '#') SUB #30
JR Z,@A_#CH                      `
CP #FA                           ` #FA = #2A (kod '*') SUB #30
LD A,#0B                         `
RET Z                            `wyjdź z kodem '*' dla DTMF w połówce
JR @innCH                        `+12+18tkt
LD A,#0C                  @A_#CH `wyjdź z kodem '#' dla DTMF w połówce
RET                              `->56tkt
`---------------------------------
`
LD A,#80                  @NRa10 `+31tkt
LD (#872E),A                     `zakończ analizę numeru
RET                              `
`---------------------------------
`
`obsługa incomming dial, w czasie tego stanu wywołuje tą procedurę 125razy/sek
`trwa +1513tkt
LD HL,(#86F9)             @IDrst `stan napięcia i czas od zmiany
LD A,H                           `czas
CP #40                           `64/125[s] (ok. 0,5sek)
RET C                            `ret -> zmiana krócej...
LD A,L                           `
CP #80                           `
RET Z                            `ret -> podniesiona słuchawka...
` tutaj słuchawka na widełkach, brak napięcia na linii tel. lub uszkodzenie układu przez >0,5[s]
LD BC,#0C13                      `delta1_długość, kod(#13)=zakończono rozm. przychodzącą z nr
CALL @PZ_TP                      `+17+1278tkt
JP @fnCAL                        `+10+150tkt  /dopisz 3bajty czasu rozmowy... 
`                                              i przejdź do SatusRST #00...
`---------------------------------
`
`odczytaj do Acc rejestr stanu MT8880 
`trwa +159tkt                   
LD A,#06                @888rs `+161tkt odczytaj rejestr stanu
`   0000 0110                   
`bit 3= fi2                0   `zegar 
`bit 2= RS0                1   `L=RxTx / H=stanu/kontrolny
`bit 1= R/w                1   `L= zapis, H=odczyt
`bit 0= cs                 0   `L= wybór
JR @888r_                      `
`odczytaj do Acc rejestr odbiornika MT8880 
`trwa +147tkt                   
LD A,#02                @888ro `+147tkt odczytaj rejestr odbiornika
`   0000 0010                   
`bit 3= fi2                0   `zegar 
`bit 2= RS0                0   `L=RxTx / H=stanu/kontrolny
`bit 1= R/w                1   `L= zapis, H=odczyt
`bit 0= cs                 0   `L= wybór
LD BC,#4040             @888r_ `+140tkt PA MT8880C
OR D                           `
OUT (C),A                      `PA [#4040]
OR #08                         `    fi =H
OUT (C),A                      `PA [#4040]  ->można odczytać PC4-7
`INC C                          `
`INC C                          `
LD C,#42                       `
IN E,(C)                       `PC [#4042]
`DEC C                          `
`DEC C                          `
LD C,#40                       `
AND #F7                        `    fi =L
OUT (C),A                      `PA [#4040]
OR #01                         `0000 0001 nieaktywne CS
OUT (C),A                      `PA [#4040]
LD A,E                         `
RLCA                           `\
RLCA                           ` \przesuń bity 4-7
RLCA                           ` /  na pozycję 0-3
RLCA                           `/
RET                            `
`-------------------------------
`
`zapisz rejestr nadajnika
`trwa +227tkt                          
LD A,#00                @888wn `zapisz rejestr nadajnika
`   0000 0000                   
`bit 3= fi2                0   `zegar 
`bit 2= RS0                0   `L=RxTx / H=stanu/kontrolny
`bit 1= R/w                0   `L= zapis, H=odczyt
`bit 0= cs                 0   `L= wybór
JR @888w_                         `
`zapisz rejestr sterujący     
`trwa +215tkt                          
LD A,#04                @888ws `+215tkt zapisz rejestr sterujący
`   0000 0100                   
`bit 3= fi2                0   `zegar 
`bit 2= RS0                1   `L=RxTx / H=stanu/kontrolny
`bit 1= R/w                0   `L= zapis, H=odczyt
`bit 0= cs                 0   `L= wybór
LD BC,#4043             @888w_ `+208tkt
OR D                           `
LD D,A                         `
`ustawiamy PC4-7 jako wyjściowy    
LD A,#82                       `
`------------------------------------------------------------------------------------------
`=1  bit7: zawsze 1
`=00 bit6 i 5: tryb pracy rejestru A: 00-tryb 0, 01-tryb 1, 02 (i 03)- tryb 2
`=0  bit4: kierunek PA: 1-wejście, 0-wyjście
`=0  bit3: kierunek PC4-PC7: 1-wejście, 0-wyjście
`=0  bit2: tryb pracy PB: 0-tryb 0, 1-tryb 1
`=1  bit1:  kierunek PB: 1-wejście, 0-wyjście
`=0  bit0:  kierunek PC0-PC3: 1-wejście, 0-wyjście
`czyli w sumie 1000 0000 -> #80
`------------------------------------------------------------------------------------------
OUT (C),A                      `P@ #4043
DEC C                          `
LD A,E                         `
RLCA                           `\
RLCA                           ` \przesuń bity 0-3
RLCA                           ` /  na pozycję 4-7
RLCA                           `/
`  tak więc wychodzi że olewamy tutaj bity dla CML602B
OUT (C),A                      `PC [#4042]
LD C,#40
OUT (C),D                      `PA [#4040]
LD A,#08                       ` fi =H
OR D                           `
OUT (C),A                      `PA [#4040]
AND #F7                        ` fi =L
OUT (C),A                      `PA [#4040]
LD C,#43                       `
`       ustawiamy PC4-7 na powrót jako wejściowy 
LD A,#8A                    `
`------------------------------------------------------------------------------------------
`=1  bit7: zawsze 1
`=00 bit6 i 5: tryb pracy rejestru A: 00-tryb 0, 01-tryb 1, 02 (i 03)- tryb 2
`=0  bit4: kierunek PA: 1-wejście, 0-wyjście
`=1  bit3: kierunek PC4-PC7: 1-wejście, 0-wyjście
`=0  bit2: tryb pracy PB: 0-tryb 0, 1-tryb 1
`=1  bit1:  kierunek PB: 1-wejście, 0-wyjście
`=0  bit0:  kierunek PC0-PC3: 1-wejście, 0-wyjście
`czyli w sumie 1000 1010 -> #8A
`------------------------------------------------------------------------------------------
OUT (C),A                      `P@ #4043
LD C,#40                       `
LD A,D                         `
AND #F0                        `
OR #03                         `
`   0000 0011                   
`bit 3= fi2                0   `zegar 
`bit 2= RS0                0   `adresowy
`bit 1= R/w                1   `L= zapis, H=odczyt
`bit 0= cs                 1   `L= wybór
OUT (C),A                      `PA [#4040]
RET                            `
`-----------------------------------
`
`reset MT8880C
`trwa +1390tkt /poza NMI/
LD D,#00                @rDTMF `
CALL @888rs                    `odczytaj rejestr stanu
`LD E,#00                      `aplikacja MT8880
LD DE,#0000                    `
CALL @888ws                    `zapisz rejestr sterujący
LD D,#00                       `
CALL @888ws                    `zapisz rejestr sterujący
`LD E,#09 `#0F                 `
`                bit 0 TOUT 1=zezwolenie na nadawanie
`                bit 1 tryb DTMF/CP 0=DTMF
`                bit 2 IRQ=1: zezwolenie na przerwania
`                bit 3 RSEL=1: następny zapis do rejestru B
LD DE,#0009                    `
CALL @888ws                    `zapisz rejestr sterujący
`LD E,#00                      `
`                bit 0 0= tryb BURST wybrany,
`                bit 1 0= wyłączony tryb TEST
`                bit 2 0= sygnały dwutonowe
`                bit 3 bez znaczenia dla generacji sygn, dwutonowych
LD DE,#0000                    `
CALL @888ws                    `zapisz rejestr sterujący
LD D,#00                       `
CALL @888rs                    `odczytaj rejestr stanu
RET                            `
`---------------------------------
`
`zapisuje do logu zdarzenie dla TPSA z przesłaniem numeru wychodzącego/wchodzącego
`wejście C=kod zdarzenia         
`        B=długość zdarzenia (jest w procedurze powiększana o bajty cyfr numeru)
`trwa max +1278tkt -16tkt  /liczone dla &20 cyfr/
LD HL,#8891               @PZ_TP `adr. numeru dla połączenia wychodzącego
PUSH HL                          `
LD A,(HL)                        `
INC A                            `bo skompresowane jest uzupełnione #F0
RRCA                             `dzielone przez 2 bo skompresowane
AND #0F                          `tylko liczba bajtów /bez ton/pulse/śmieci /
PUSH AF                          `liczba bajtów na stos
ADD A,B                          `
LD B,A                           `
CALL @_PZD_                      `+17+712tkt
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres miesiąca
JR NC,@noPZP                     `hop -> nie zapisano do logu
INC HL                           `
EX DE,HL                         `do DE adres docelowy
POP AF                           `
POP HL                           `
INC A                            `bo też bajt długości i tone/pulse
LD C,A                           `\16& bitów
LD B,#00                         `/
` jeśli zero znaków to wtedy prześle 1bajt, tak ma być!
LDIR                             `415 = 20 * 21 - 5
RET                              `
POP AF                    @noPZP `
POP HL                           `
RET                              `
`---------------------------------
`                                 
`sprawdza autosumę bloku RAM od adresu HL bajtów: B+1
`wynik Z=autosuma zgodna NZ=autosuma niezgodna
`trwa +tkt 
LD A,(HL)                 @chkA$ `
INC HL                    @chk$_ `
XOR (HL)                         `
DJNZ @chk$_                      `nie zmienia rej. F
RET                              `
`---------------------------------
`                                 
`sprawdzenie obecności 230V, w zasadzie wystarczyło by to generować tylko kilka razy w sekundzie
`generuje zdarzenia: ZANIK230V po każdym zaniku 230V
`                    BRAK230V gdy ciągle przez np. 5 minut brak 230V
`                    NIESTABILNE230v gdy liczba zaników przekroczy np.3
`                    STABILNE 230V gdy 230V jest ciągle przez ponad np. 10 minut a był BRAK230V
`trwa +365 +@_PZD_ tkt max                
`          +712tkt         = +1077tkt max
LD A,(#86F7)              @ts230 `testuj 230V i ew. generuj zdarzenia
AND #10                          `
`  bit4 monitor 230V             `
`w Acc mamy bit obecności 230V (=0) lub braku (=1)
LD A,(#87E7)                     `
`#87E7 -1b bity ustawień detektora 230V:
`         bit7 -=1 jest 230V, =0 brak 230V
`         bit6 - \                      
`         bit5 -  | nic                 
`         bit4 - /                      
`         bit3 -=1 było zdarzenie NIESTABILNE 230V
`         bit2 -=1 było zdarzenie ZASILANIE 230V
`         bit1 -=1 było zdarzenie BRAK 230V
`         bit0 -=1 było zdarzenie ZANIK 230V
LD C,A                           `
JP Z,@je230                      `hop -> jest 230V
` tutaj brak 230V                 
` trwa +273tkt + @_PZD_           
BIT 7,A                          `czyli czy było wcześniej 230V
JR NZ,@no230                `hop -> zarejestrowane wcześniej 230V, a więc teraz moment zaniku
` wcześniej nie było 230V, a więc teraz nic się nie zmieniło
BIT 1,A                          `bit1 =1 było zdarzenie BRAK 230V
RET NZ                           `wyjdź bo było już zdarzenie BRAK 230V
LD A,(#8EA8)                     `minut przerwy 230V, po których generuje zdarzenie BRAK
LD B,A                           `
LD A,(#87EB)                     `minut przerwy 230V 
CP B                             `minut_przerwy - krytyczne
RET C                            `przerwa krótsza niż XX minut
LD A,C                           `
SET 1,A                          `
LD (#87E7),A                     `zapisz że proponowano zdarzenie
` tutaj zdarzenie BRAK 230V (przez ponad np.5 minut) 
`wejście: Brej =l.bajtów zdarzenia (wraz z 2-ma bajtami długości)
`         Crej =ID (kod) zdarzenia,
LD BC,#080D                      `kod =brak 230V
JP @_PZD_                        `
RES 7,A                   @no230 `+253tkt+@_PZD_ tutaj niezarejestrowane wcześniej 230V
` było wcześniej 230V, a więc teraz mamy moment zaniku 230V
RES 2,A                          `zeruj zdarzenie ZASILANIE 230V
LD (#87E7),A                     `zapisz że zarejestrowano
LD HL,#0000                      `zeruj i startuj \
LD (#87EA),HL                    `godz i min       |zeruj i startuj czas braku napięcia
LD (#87EB),HL                    `min i sek       /
`#87EA -3b CP230 =czas przerwy 230V
LD HL,(#87E8)                    `\
SET 7,H                          ` |zatrzymaj pomiar czasu trwania napięcia
LD (#87E8),HL                    `/
`#87E8 -2b CT230 =czas trwania napięcia 230V
BIT 0,A                          `bit0 =1 było zdarzenie ZANIK 230V
RET NZ                           `wyjdź bo było już zdarzenie ZANIK 230V
BIT 3,A                          `bit3 =1 było zdarzenie NIESTABILNE 230V
RET NZ                           `wyjdź bo było już 
SET 0,A                          `ustaw zdarzenie ZANIK
LD (#87E7),A                     `zapisz że wykonano zdarzenie
LD C,A                           `
LD A,(#8EAB)                     `
`#8EAB -1b stała, liczba zaników 230V po których generujemy NIESTABILNE 230V
LD B,A                           `
LD A,(#87EF)                     `
`#87EF -1b licznik zdarzeń zanik 230V -> powyżej pewnej wartości generuje NIESTABILNE
CP B                             `l.zdarzeń - krytyczna
`   CY to zanik                   
`   NC to NIESTABILNE             
` tutaj zdarzenie ZANIK 230V (chyba że blokada przez licznik zdarzeń 230V)
`wejście: Brej =l.bajtów zdarzenia (wraz z 2-ma bajtami długości)
`         Crej =ID (kod) zdarzenia,
JR NC,@niest                     `
LD HL,#87EF                      `
LD A,(HL)                        `\
INC A                            ` |zwiększ liczbę zaników
LD (HL),A                        `/
LD BC,#080C                      `kod =zanik 230V
JP @_PZD_                        `
LD A,C                    @niest `+45tkt +@_PZD_
SET 3,A                          `bit0 =1 było zdarzenie NIESTABILNE 230V
LD (#87E7),A                     `zapisz
` tutaj zdarzenie ZANIK 230V (chyba że blokada przez licznik zdarzeń 230V)
`wejście: Brej =l.bajtów zdarzenia (wraz z 2-ma bajtami długości)
`         Crej =ID (kod) zdarzenia,
LD BC,#080F                      `kod =NIESTABILNE
JP @_PZD_                        `
BIT 7,A                   @je230 `+318tkt +@_PZD_ tutaj jest 230V
`   czyli czy było wcześniej 230V  
`   #87E7 -1b bity ustawień detektora 230V:
`   bit7 -=1 jest 230V, =0 brak 230V
JR NZ,@wni23                     `hop -> wcześniej było, teraz jest
` wcześniej nie było, teraz jest a więc zbocze narastające 230V
SET 7,A                          `tutaj zarejestrowane wcześniej 230V
LD (#87E7),A                     `zapisz że jest 230V
LD DE,(#87ED)                    `wcześniej sumaryczny czas przerw 230V
`#87ED -2b (godz/min) =zapamiętany sumaryczny czas przerwy 230V
`    #87ED -godz 0-255&             (E)
`    #87EE -min  0-59&              (D)
BIT 7,E                          `czy dotychczasowa suma >=128godzin?
JR NZ,@>127h                     `
LD HL,(#87EA)                    `
`#87EA -3b CP230 =czas przerwy 230V:
`    #87EA -godz 0-127&  gdy bit7=1 to stoi  (L)
`    #87EB -min  0-59&                       (H)
LD A,H                           `\
ADD A,D                          `/sumuj minuty
CP #3C                           `czy > &59 ?
JR C,@bzCAR                      `hop -> bez przeniesienia
SUB #3C                          `minus &60 minut
INC L                            `+1 godzina
LD H,A                    @bzCAR `
LD A,L                           `\
ADD A,E                          `/sumuj godziny
LD L,A                           `
`          L=godziny -> #87ED     
`          H=minuty  -> #87EE     
LD (#87ED),HL                    `zapamiętaj długość sumarycznego czasu przerw 230V
LD A,(#87EA)              @>127h `\
SET 7,A                          ` |zatrzymaj pomiar przerwy 230V
LD (#87EA),A                     `/
LD HL,#0000                      `\startuj pomiar czasu trwania 230V
LD (#87E8),HL                    `/
` #87E8 -2b CT230 =czas trwania napięcia 230V
RET                              `
LD HL,(#87E8)             @wni23 `+298tkt +@_PZD_ #87E8 -2b CT230 =czas trwania nap. 230V
LD A,#09                         `aby zerować ZANIK dopiero po 10 sekundach
CP L                             `
LD A,C                           `odtwórz bity zdarzeń 230V /z #87E7/
JR NC,@no10s                     `hop -> nie minęło 10 sekund
RES 0,A                          `zeruj zdarzenie ZANIK
LD (#87E7),A                     `zapisz że wykonano zdarzenie
BIT 2,A                   @no10s `bit2 =1 było zdarzenie STABILNE 230V
RET NZ                           `wyjdź bo było już 
LD DE,(#8EA9)                    `stała, czas po którym po brakach i niestabilnym
`                                 generujemy powrót zasilania 230V
AND A                            `
SBC HL,DE                        `czas_trwania_230V - krytyczny
RET C                            `
SUB A                            `\
LD (#87EF),A                     `/zeruj licznik zaników
BIT 1,C                          `bit1 =1 było zdarzenie BRAK
JR NZ,@bylBR                     `hop -> bo było zdarzenie BRAK
BIT 3,C                          `bit3 =1 było zdarzenie NIESTABILNE
LD A,C                    @bylBR `
LD DE,(#87ED)                    `E=min, D=godz
LD HL,#0000                      `\zeruj sumaryczny czas
LD (#87ED),HL                    `/L=min, H=godz
RET Z                            `wyjdź bo nie było
PUSH DE
AND #F0                          `zeruj bity 3,2,1 i 0
SET 2,A                          `ustaw bit ZASILANIE STABILNE
LD (#87E7),A                     `zapisz
LD BC,#0A0E                      `kod =powróciło 230V
CALL @_PZD_                      `
`wyjście: NC -> nie zapisano bo niezakwalifikowano do zapisania, olej
`         CY -> zapisano, HL=adres roku
POP DE                           `sumaryczny zcas trwania zaników 230V
RET NC `JR NC,@zeSUc             `hop -> nie ma zdarzenia, tylko zeruj czas
INC HL                           `
LD (HL),E                        `min
INC HL                           `
LD (HL),D                        `godz
`LD HL,#0000               @zeSUc `\
`LD (#87ED),HL                    `/zeruj sumaryczny czas
`#87ED -2b (godz/min) =zapamiętany sumaryczny czas przerw 230V
`    #87ED -min  0-59&             
`    #87EE -godz 0-255&            
RET                              `
`--------------------------------
`
`zamień Acc na dwa znaki kodu szesnastkowego xx do (HL)
`trwa 131tkt
`zmienia: AFBHL                   
LD B,A                    @##2Cy `
RRCA       
RRCA
RRCA
RRCA
AND #0F
ADD A,#30
CP #3A
JR C,@hlop1
ADD A,#07
LD (HL),A        @hlop1
INC HL
LD A,B
AND #0F
ADD A,#30
CP #3A
JR C,@hlop2
ADD A,#07
LD (HL),A        @hlop2
INC HL
RET
`----------------------------------
`
`wykonuje kroczek wychodzącego połączenia
` max mamy do 1787tkt, a więc na to co wewnątrz ok. 1693tkt!
`trwa: +94tkt + to_co_wykonuje    
`               max +857tkt  = +951tkt max
LD A,(#88BF)              @OMRrt `wykonujemy poł. wychodzące kroczek podetapu
CP #09                           `zabezpieczenie...
LD HL,@OMR__                     `adr. wykonawczy podetapów etapu 8 rst
JP C,@jp(hl                      `+10+54tkt+to_co_wykonuje
` jeśli zła wartość podetapu to przechodzi tutaj...
LD A,#00                         `\
LD (#86F8),A                     ` |Stand-By
LD (#88BF),A                     ` |podetap zeruj
RET                              `/
`----------------------------------
`
`adresy procedur podetapów wychodzącego MY dial
DEFETYK @OMR__
DEFTABE OMrs0  `+857tkt #00 podnosi słuchawkę, czyści MT8880, czeka na ciągły 420Hz <-------
DEFTABE OMrs1  `+266tkt #01 rozkompresowuje cyfry 0..&20
DEFTABE OMrs2  `+397tkt #0B sprawdza format i ew. zamienia go na format dla TPSA
DEFTABE OMrs3  `+605tkt #0C wybiera tonowo zadany numer   
DEFTABE OMrs4  `+171tkt #0D czeka na bąblowanie, rozpoczyna odtwarzanie ISD
DEFTABE OMrs5  `+260tkt #0E czeka na ciszę, wyłącza ISD1420
DEFTABE OMrs6  `+221tkt #0F po małej przerwie, rozpoczyna ISD1420 od nowa
DEFTABE OMrs7  `+247tkt #10 odkłada słuchawkę, wychodzi do Stand-by
DEFTABE OMrs8  `+tkt czeka chwilę po odłożeniu słuchawki
`---------------------------------
`
`podnosi słuchawkę i oczekuje na ciągły 420Hz
`trwa: +857tkt max                
LD D,#13                  @OMrs0 `aby podniesiona słuchawka i nieaktywne CS i fi2 od MT8880
` PIO #4040 PA OUT    #4041 PB IN       #4042 PC 0-3 OUT / 4-7 IN     #4043 P@ -sterujący
`  0 CS  \            0 IRQN \          0 brąz linia ->telefon dzwoni 
`  1 RW  | MT8880C    1 RXD  | CML602B  1 MODE \                      
`  2 RS0 |            2 DET  /          2 ZP   | CML602B              
`  3 fi2 /            3 syg.420Hz       3 RXCK /                      
`  4 przek odb telef. 4 monitor 230V    4 D0   \                      
`  5 =1 to IDS1420    5 ?               5 D1   | MT8880C              
`  6 =1 to REC        6 LowVolt         6 D2   |                      
`  7 =1 ALARMbrąz     7 HighVolt        7 D3   /                      
LD BC,#4040                      `
OUT (C),D                        `podniesienie słuchawki
LD C,#42 `LD BC,#4042            `
SUB A                            `
OUT (C),A                        `dla pracy toru foni CML602B dla detekcji 420Hz
`musi być, bo gdy słuchawka jest normalnie opuszczona to CML602B czeka na dzwonek 
`i nie działa jego wzmacniacz akustyczny, dlatego niemożliwa jest detekcja 420Hz
LD A,(#8740)                     `rozpoznanie 420Hz
CP #04                           `czy sygn. ciągły?
LD E,#0D                         `=kod brak sygn. ciągłego -> redial
` TimeGuard ustalony wcześniej przed wejściem na RST #08 na max czas wymagany dla
` pojawienia się sygnału ciągłego po podniesieniu słuchawki 
JR NZ,@_omFa                     `hop -> nie, jeśli minął czas to wyjdź
LD A,(#889C)                     `zadany numer znany lub ręcznie
CP #0A                           `czy znany (gdy #00..#09)?
JR NC,@tuNum                     `hop -> to numer podany ręcznie /już jest/
LD HL,#856A                      `
`!`#856A: 1b + #856B-#8574 &10b numer 0 (poufnych)
LD E,A                           `
ADD A,A                          `*2
ADD A,A                          `*4
ADD A,E                          `*5
ADD A,A                          `*10
ADD A,E                          `*11
LD E,A                           `\
LD D,#00                         `/16bitów
ADD HL,DE                        `adres źródła w HL
EX DE,HL                         `adres miejsca docelowego do DE
JR @TuNum                        `
LD DE,#889D               @tuNum `\źródło dla rozkompresowania
LD A,(DE)                 @TuNum ` \l.cyfr
INC DE                           ` /na adres pierwszej pary znaków
LD (#88C3),DE                    `/
LD HL,#88AB                      `\miejsce docelowe rozkompresowania
LD (#88C5),HL                    `/
AND #1F                          `bo do &20 znaków może być
LD E,#0F                         `zakończono MakeCall_TPSA przez system, zły numer tel.
`                                     ->redial
JR Z,@_omF_                      `hop -> ok, mamy zły numer
CP #15                           `czy l.znaków <&20
JR NC,@_omF_                     `hop -> ok, mamy zły numer
LD (#88A9),A                     `zapisz rozkopmresowaną ;o) liczbę cyfr
LD (#88AA),A                     `/startuj roboczą liczbę cyfr dla dekompresji
LD HL,#03F4                      `\ #01F4 czas, w ciągu którego powinien wybrać numer tonowo
LD (#88C0),HL                    `/TimeGuard startuj -> 4[s]
`LD E,#09                        `
`                bit 0 TOUT 1=zezwolenie na nadawanie
`                bit 1 tryb DTMF/CP 0=DTMF
`                bit 2 IRQ=0: bez zezwolenia na przerwania
`                bit 3 RSEL=1: następny zapis do rejestru B
LD DE,#1009                      `podniesiona słuchawka, nieaktywny ISD1420, bez REC
CALL @888ws                      `+17+215tkt zapisz rejestr sterujący
`LD E,#00                        `
`                bit 0 0= tryb BURST wybrany,
`                bit 1 0= wyłączony tryb TEST
`                bit 2 0= sygnały dwutonowe
`                bit 3 bez znaczenia dla generacji sygn, dwutonowych
LD DE,#1000                      `podniesiona słuchawka, nieaktywny ISD1420, bez REC
CALL @888ws                      `+17+215tkt zapisz rejestr sterujący
JP @nxPAR                        `+10+32tkt next podetap
CALL @TG_ck               @_omFa `+217tkt TimeGuard czeka do 4 sekund po podniesieniu słuchawki
RET NZ                           `ret bo jeszcze nie upłynął czas
`   tutaj upłynął czas oczekiwania na sygnał ciągły 420Hz i sygnał nie pojawił się
LD HL,#88C2                      `\
INC (HL)                         `/cyknij (#88C2) ilość fauli przy wybieraniu numeru
` ew. może jakiś kod powodu faula?... kod faula =odczytać podetap i wiemy kiedy wyszedł!
LD A,#08                  @_omF_ `+143tkt \
LD (#88BF),A                     `        /kroczek 8 -> czekaj chwilę po odłożeniu słuch.
LD HL,#00FA                      `\TimeGuard oczkiwania po odłożeniu słuch.
LD (#88C0),HL                    `/ =2[s]
LD A,#03                         `odłóż. słuchawka i NIEaktywny IDS1420, nieaktywny MT8880
LD BC,#4040                      `bez REC
OUT (C),A                        `
`jeśli chodzi o CML602B to zostanie on (ZP i MODE) ustawione przez
`początek procedurki @TPSA_       
`zatrzymanie stopera, ISD1420 i REC już nieaktywne:
LD HL,#873A                      `adr. godzin
SET 7,(HL)                       `zatrzymaj
`#8738 -3b czas trwania dzwonka/rozmowy w sek/min/godz od 0 do &128 godzin potem nie idzie już
` #8738 -1b sekundy \
` #8739 -1b minuty  |
` #873A -1b godziny / od 0 do &127, gdy &128 (#80) tzn że przekroczył 127:59:59...
LD HL,#88A8                      `adr. Make_Call_TPSA
LD A,(HL)                        `odczytaj
AND #F0                          `zostaw bity 7,6,5,4 czyli: CYNA, REC, ISD1420, REDIAL, 
OR E                             `
LD (HL),A                        `po wyjściu jak ma wyglądać MakeCall_TPSA
AND #91                          `\czy kwalifikuje się do Redial?
CP #11                           `/
RET NZ                           `wyjdź, bo nie kwalifikuje się do redial
LD A,#1E                         ` =&30[s]
`#88C8 -1b -licznik sekundowy cykający w dół redialu
LD (#88C8),A                     `
RET                              `
`---------------------------------
`
`procedurka cyka TimeGuarda wybierania numeru
`wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
`trwa: +57tkt
LD HL,(#88C0)             @TG_ck `\tutaj brak sygnału ciągłego
DEC HL                           ` |TimeGuard czeka do 4 sekund po podniesieniu słuchawki
LD (#88C0),HL                    `/ 
LD A,H                           `\
OR L                             `/czy =0?
RET                              `ret Z gdy time=0 i NZ gdy nie
`---------------------------------
`
`przekształcamy numer w formacie skompresowany standard 
`na format dla TPSA. dla &20 cyfr musi być wywołana &10 razy
`trwa +266tkt max                   
LD BC,#88AA               @OMrs1 `\bieżąca l.cyfr dla dekompresji
LD A,(BC)                        `/
AND A                            `czy =0?
JR Z,@nxPAR                      `ret -> już całość zdekompresowana
DEC A                            `\
LD (BC),A                        `/-1 cyfra
LD DE,(#88C3)                    `adres pary znaków
LD A,(DE)                        `odczytaj parę znaków
INC DE                           `inkcnij
LD (#88C3),DE                    `adres pary znaków +1
PUSH AF                          `znak drugi
AND #0F                          `
LD HL,(#88C5)                    `miejsce docelowe rozkompresowania
LD (HL),A                        `
INC HL                           `+1
POP AF                           `
RLCA                             `
RLCA                             `
RLCA                             `
RLCA                             `
AND #0F                          `
LD (HL),A                        `
INC HL                           `+1
LD (#88C5),HL                    `miejsce docelowe rozkompresowania +2
LD A,(BC)                        `odczytaj l. znaków do rozkompresowania
AND A                            `czy =0?
JR Z,@nxPAR                      `ret -> już całość zdekompresowana
DEC A                            `\
LD (BC),A                        `/-1 cyfra
RET
`---------------------------------
`
`sprawdza format i ew. zamienia go na format dla TPSA
`trwa +397tkt max                 
LD DE,#850A               @OMrs2 `#0B sprawdza format i ew. zamienia go na format dla TPSA
SUB A                            `\
LD (#88AA),A                     `/zeruj nadanych cyfr
` sprawdzamy czy zaczyna się od domyślnego prefiksu
`
`!`#850A -> 5b to dane o domyślnym prefiksie -dołączanym do każdego nru 
`!`            połączenia przychodzącego, który nie zaczyna się plusem
`!`   #850A -> 1b to liczba cyfr(tylko!) ASCII 0-4 domyślnego prefiksu (=0 gdy brak prefiksu)
`!`   #850B -> 4b to 4 kody ASCII cyfr tego domyślnego numeru prefixu
`
`#88A9- &22b bufor numeru do wybrania w TPSA (gdy 7bit =1 i l.cyfr >#00)
` #88A9- 1b liczba cyfr (AND #7F -> #00 to pusty bufor),
` #88AA- 1b bieżąca cyfra do wybrania (#00-...)
` #88AB- &20b cyfry (mogą być też ASCII bo liczy się tylko prawa połówka bajtu)
`
LD A,(DE)                        `l.cyfr domyślnego prefixu
AND #07                          `czy =0?
LD HL,#88AB                      `adr. pierwszego znaku rozkompresowanych cyfr
LD (#88C5),HL                    `adres cyfr do wybrania (gdy bez prefixu)
JR Z,@nxPAR                      `hop -> nie zaczyna się od prefixu bo nie ma prefixu
LD C,A                           `liczba cyfr prefixu
LD B,A                           `liczba cyfr prefixu
`Brej max 4, sama pętla trwa: +217tkt =4*53-5
INC DE                    @nxPoP `pętla -porównaj next znak
LD A,(DE)                        `     \
AND #0F                          `     /tylko prawa połówka cyfry ASCII prefixu domyślnego
CP (HL)                          ` 
JR NZ,@nxPAR                     `hop -> nie zaczyna się od prefixu bo różne cyfry
INC HL                           `
DJNZ @nxPoP                      `pętla -> next znak do sprawdzenia
` tutaj zaczyna się od prefixu, robimy dodanie zera przed i gotowe
DEC HL                           `
LD (HL),#30                      `
LD (#88C5),HL                    `adres cyfr do wybrania
`   popraw liczbę cyfr do wybrania  
LD A,(#88A9)                     `rozkopmresowanA liczbę cyfr do wybrania
INC A                            `bo dodano zero
SUB C                            `bo odjęto prefix
LD (#88A9),A                     `zapisz liczbę cyfr do wybrania
LD HL,#88BF               @nxPAR `+32tkt adr. podetapu RST wybierania numeru
INC (HL)                         `cyknij podetap
RET                              `
`--------------------------------------
`
`mamy podniesioną słuchawkę i sygnał 420Hz sklasyfikowany jako ciągły
`wybieramy tonowo numer             
`trwa: +605tkt max                 
LD A,(#88AA)              @OMrs3 `dla pierwszej nadawanej cyfry numeru
AND A                            `czy to pierwsza?
JR Z,@02-->                      `hop -> bo jeszcze nic nie nadane
` tutaj, ponieważ już nadane to czekaj aż będzie gotowy
` na następną cyfrę numeru        
LD D,#10                         `aby podniesiona słuchawka
CALL @888rs                      `+17+161tkt odczytaj rejestr stanu
` 3bit DELAYED STEERING - n.c.    
` 2bit RDR FULL         - tutaj n.c.
` 1bit TDR EMPTY        - sprawdzamy: 0=nie gotowy, 1=pusty, gotowy
` 0bit IRQ              - n.c.    
AND #02  `BIT 1,A                `
LD E,#0E                         `nie gotowy nadajnik MT8880 przez zbyt długi czas ->bez redial
JP Z,@_omFa                      `hop -> nie, bo nadajnik nie gotowy
`BIT 1,A                         `nie będziemy sprawdzać ;o)
`JP Z,@_omFa                     `hop -> nie, bo nadajnik nie gotowy
LD HL,#88A9               @02--> `+372tkt 
LD A,(HL)                        `liczba znaków do nadania
INC HL                           `adr. nadanych już znaków
CP (HL)                          `(wszystkich znaków) minus (już nadanych)
JR Z,@allTX                      `hop -> wszystko nadane, bufor pusty
JR C,@allTX                      `hop -> więcej niż wszystko nadane
`+328 tkt dalej                     
LD E,(HL)                        `\ nr znaku do nadania,
LD D,#00                         `/delta adresu
INC (HL)                         `cyknij jakby już nadany
LD HL,(#88C5)                    `adres cyfr do wybrania
ADD HL,DE                        `
LD A,(HL)                        `odczytaj znak do nadania
AND #0F                          `tylko prawa połówka oczywiście
JR NZ,@02_?-                     `\czy zero?
LD A,#0A                         `/
LD D,#10                  @02_?- `podniesiona słuchawka
LD E,A                           `
JP @888wn                        `+10+227tkt zapisz rejestr nadajnika
LD HL,#0177               @allTX `+173tkt \ =3[s]
LD (#88C0),HL                    `        /TimeGuard startuj -> /oczekiwanie na 420Hz/
SUB A                            `=#00     \  zeruj i 
LD (#8738),A                     `          \ startuj stoper czasu 
LD HL,#0000                      `=#0000    / trwania dzwonka
LD (#8739),HL                    `         /
`#8738 -3b czas trwania dzwonka/rozmowy w sek/min/godz od 0 do &128 godzin potem nie idzie już
` #8738 -1b sekundy \
` #8739 -1b minuty  |
` #873A -1b godziny / od 0 do &127, gdy &128 (#80) tzn że przekroczył 127:59:59...
`SUB A                           `\=#00 =cisza 420Hz wyzeruj rozpoznanie!
LD (#8740),A                     `/zapisz jako cisza 420Hz
` jeśli opcja to włącz ISD1420 i REC
LD A,(#88A8)                     `MakeCall_TPSA
AND #60 `BIT 6i5,A               `bit ustalający pracę REC i ISD1420
OR #13                           `podn. słuchawka i aktywny IDS1420, nieaktywny MT8880
LD BC,#4040                      `
OUT (C),A                        `
JP @nxPAR                        `+10+32tkt next podetap
`---------------------------------
`
`oczekuje na sygnał 420Hz inny niż cisza
`trwa: +171tkt max                
LD A,(#8740)              @OMrs4 `sygn 420Hz
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły 
AND A                            `czy cisza?
JR NZ,@NoCis                     `hop -> nie cisza
CALL Z,@TG_ck                    `TimeGuard czeka do 3 sek na 420Hz inne niż cisza
`    wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
RET NZ                           `
LD HL,#09C4               @NoCis `tutaj gdy nie cisza
LD (#88C0),HL                    `/TimeGuard startuj -> 20[s] /oczekiwanie na podn. słuchawki/
JP @nxPAR                        `+10+32tkt next podetap
`---------------------------------
`
`decyduj dalej w zależności od tego, czy jest cisza, oczekujący, zajęty
`trwa: +260tkt max                 
LD A,(#8740)              @OMrs5 `
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły 
AND A                            `czy to cisza?
JR Z,@5cisz                      `hop -> cisza
DEC A                            `czy to bąblowanie?
JR Z,@5ocze                      `hop -> oczekuje (bąblowanie)
DEC A                            `czy to zajęty?
LD E,#05                         `=zajęty -> redial
JP Z,@_omF_                      `hop -> zajęty ->finish
`DEC A                            `czy to oczekuje?
`JR Z,@5ocze                      `hop -> oczekuje
` tutaj sygnał nieoczekiwany (ciągły)
AND A                     @5ocze `jeśli =0 to oczekuje (#03)
LD A,(#88A8)                     `
BIT 7,A                          `=1 to cyna tylko
JR Z,@5ocz_                      `hop -> normalne, nie cyna
` tutaj cyna, zakończ               
LD E,#07                         `nie odebrany -> ale cyna -> bez redial
JP @_omF_                        `+12+117tkt hop -> minął już czas -> odłóż słuchawkę
CALL @TG_ck               @5ocz_ `+210tkt TimeGuard czeka do 20 sek na 420Hz akceptowalne
`    wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
LD E,#07                         `nie odebrany  -> redial
JP Z,@_omF_                      `+12+117tkt hop -> minął już czas -> odłóż słuchawkę
RET                              `czas jeszcze nie minął, oczekuj dalej
SUB A                     @5cisz `+114tkt =#00     \  zeruj i 
LD (#8738),A                     `                  \ startuj stoper czasu 
`LD HL,#0000                      `=#0000           / trwania dzwonka
`LD (#8739),HL                    `                /
`#8738 -3b czas trwania dzwonka/rozmowy w sek/min/godz od 0 do &128 godzin potem nie idzie już
` #8738 -1b sekundy \
` #8739 -1b minuty  |
` #873A -1b godziny / od 0 do &127, gdy &128 (#80) tzn że przekroczył 127:59:59...
`zerujemy tylko sekundy bo i tak nie zdążył tutaj więcej zliczyć...
LD HL,#003E                      `\Time przerwy dla nowego startu IDS1420
LD (#88C0),HL                    `/TimeGuard 
LD A,#13                         `podn. słuchawka i NIEaktywny IDS1420, nieaktywny MT8880
LD BC,#4040                      `i NIE REC
OUT (C),A                        `
JP @nxPAR                        `+10+32tkt next podetap
`---------------------------------
`
`mała przerwa dla ISD1420           
`trwa: +221tkt +++max                   
LD A,(#88A8)              @OMrs6 `
BIT 7,A                          `=1 to cyna tylko
JR Z,@OMr6_                      `hop -> normalne, nie cyna
` tutaj cyna, zakończ               
LD E,#00                         `zakończony przez system
JP @_omF_                        `+12+117tkt hop -> minął już czas -> odłóż słuchawkę
DEFETYK @EPRA$           `\
DEFBAJT1 #00             `/koryguje autosumę całości EPROM
CALL @TG_ck               @OMr6_ `cyknij przerwę
`wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
RET NZ                           `
LD A,(#88A8)                     `MakeCall_TPSA
AND #60 `BIT 6i5,A               `bit ustalający pracę REC i ISD1420
OR #13                           `podn. słuchawka i aktywny IDS1420, nieaktywny MT8880
LD BC,#4040                      `
OUT (C),A                        `
BIT 5,A                          `
LD HL,#0FA0                      `Time odtwarzania dla IDS1420 =32[s]
JR NZ,@ID143                     `hop -> ma być ISD1420
LD HL,#3A98                      `Time dial max 120[s]
LD (#88C0),HL             @ID143 `TimeGuard startuj
JP @nxPAR                        `next podetap
`---------------------------------
`
`rozmowa wychodząca wywołana trwa
`trwa: +247tkt                    
LD A,(#8740)              @OMrs7 `sygn 420Hz
`               =#00 -cisza, brak sygnału,
`               =#01 -syg. wybierania numeru (bąblowania),
`               =#02 -syg. zajętości numeru,
`               =#03 -syg. oczekiwania na połączenie,
`               =#04 -syg. ciągły 
CP #02                           `czy zajęty?
LD E,#01                         `wyjście z rozmowy przez drugiego
JP Z,@_omF_                      `hop -> zajęty ->finish
CALL @TG_ck                      `+17+57tkt cyknij czas
`wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
RET NZ                           `
LD E,#00                         `zakończony przez system
JP @_omF_                        `+10+117tkt finish
`----------------------------------
`
`przerwa po odłożeniu słuchawki, aby zaliczył jako odłożenie
`trwa: +tkt                    
CALL @TG_ck               @OMrs8 `+17+57tkt cyknij czas
`wyjście NZ=jeszcze nie czas, Z=koniec TimeGuarda
RET NZ                           `
SUB A                            `\
LD (#86F8),A                     `/zrób Stand-by
RET                              `
`---------------------------------
`
`oblicza (gdy się da) liczbę dni pomiędzy 
`  datą zagara systemowego a zapamiętaną w konfigu datą abonamentową
`trwa +873tkt max                
LD DE,#8556              @AWLKD `adres roku
`!`   #8554 -3b data abonamentowa: 
`!`       #8554 -bit7 -> reklamy aktywne =1
`!`             -bit5,6 -> krok 0..3
`!`             -bit0..4 -> dzień miesiąca 
`!`       #8555 -bit7 -> ?
`!`             -bit4..6 -> tryb 0..7
`!`             -bit0..3 -> miesiąc /gdy miesiąc>#0B to brak daty/
`!`       #8556 -rok              |
LD HL,#7F0A                     `#8009
`#8007 -> dni miesiąca   [#00 - #1E] /#00 to 1, #1E to &31/
`#8008 -> miesiące       [#00 - #0B] /#00 to styczeń, #0B to grudzień/
`#8009 -> lata (#00 = 2000r)    `
INC H                           `
DEC L                           `mamy adres roku bieżącego
LD A,(DE)                       `\porównaj rok abonament - aktualny
SUB (HL)                        `/
LD BC,#0000                     `=0 dni różnicy
JR Z,@ROgit                     `hop -> rok OK
PUSH AF                         `
LD A,(HL)                       `aktualny rok
DEC A                           `poprzedni rok
PUSH HL                         `
LD HL,#016D                     ` =&365 dni, czyli rok
CALL @ifRoP                     `po tym l.dni poprzedniego roku
LD C,L                          `\
LD B,H                          `/BC = l.dni poprzedniego roku /uwzgl. lata przestępne/
POP HL                          `
POP AF                          `
JR NC,@walek                    `hop -> wielka liczba dni
INC A                           `
JR NZ,@walek                    `hop -> wielka liczba dni
` tutaj gdy różni się o 1 rok, mamy następny w stosunku do abonamentowego
DEC L                    @ROgit `mamy adres miesiąca bieżacego
DEC E                           `adres miesiąca abonamentu
PUSH DE                         `
EX DE,HL                        `DE=adres daty, dla której obliczamy /bieżącej/
PUSH BC                         `
CALL @DE->d                     `przelicz na dni
POP BC                          `
ADD HL,BC                       `
LD C,L                          `\
LD B,H                          `/BC = l.dni dla dzisiejszego dnia
POP DE                          `adres daty abonamentowej
PUSH BC                         `
CALL @DE->d                     `przelicz na dni
EX DE,HL                        `=liczba dni 'abonamentowa'
POP HL                          `=liczba dni 'dzisiejsza'
AND A                           `
SBC HL,DE                       `'dzisiejsza' - 'abonamentowa' = różnica
JR @PoWal                       `
LD A,#FF                 @walek `bardzo duża l.dni różnicy (ponad rok)
JR @ldni+                       `
LD A,H                   @PoWal `
AND A                           `
JR NZ,@walek                    `hop ->
LD A,L                          `
LD (#87E5),A             @ldni+ `
`#87E5 -1b liczba dni od daty abonamentowej 0..&255
`  tą liczbę dni trzeba teraz przełożyć na konieczność wysłania SMSa paya 
`              i na blokadę wysyłania SMSów na jawne numery
`              i na wyświetlany komunikat
`              i na rozsyłanie reklam na jawne
RET                             `
`--------------------------------
`                                
`przelicza datę na kolejny dzień roku,
` wejście: data zawarta w pamięci, DE zawiera adres miesiąca,
`  data to 3bajty, kolejno dzień, miesiąc, rok 
`  w formacie, dzień i miesiąc pierwszy to #00
` wyjście: HL                    
`trwa: +211tkt max               
LD HL,@l.dni             @DE->d `
LD B,#00                        `
LD A,(DE)                       `miesiąc
AND #0F                         `
LD C,A                          `
ADD HL,BC                       `
LD L,(HL)                       `
LD H,B                          `
DEC DE                          `
LD A,(DE)                       `dzień
AND #1F                         `
LD C,A                          `
ADD HL,BC                       `
INC DE                          `
LD A,(DE)                       `miesiąc
CP #09                          `
JR C,@hopMW                     `hop -> bo starszy bajt = #00
INC H                           `bo starszy bajt = #01
CP #02                   @hopMW `
RET C                           `
INC DE                          `
LD A,(DE)                       `rok
AND A                    @ifRoP `2000 -wyjątek =nie jest przestępny
RET Z                           `
CP #64                          `2100 -wyjątek =nie jest przestępny
RET Z                           `
CP #C8                          `2200 -wyjątek =nie jest przestępny
RET Z                           `
AND #03                         `co 4-ty jest przestępny
RET NZ                          `
INC HL                          `
RET                             `
`--------------------------------
`
DEFETYK @l.dni                   
DEFBAJT1 #00 #1F #3B #5A #78 #97 #B5 #D4 #F3 #11 #30 #4E
`--------------------------------
`#87F7 -5b free
`#8ADD -free...
`#8E07 -1b free
`
